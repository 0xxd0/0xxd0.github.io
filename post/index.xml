<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>全部 | 徐旭栋</title><link>/post/</link><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><description>全部</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>Copyright © 2014 - 2021 Xudong Xu. 保留所有权利。</copyright><lastBuildDate>Wed, 09 Sep 2020 00:00:00 +0000</lastBuildDate><image><url>/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>全部</title><link>/post/</link></image><item><title>滑板选配 101</title><link>/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>新的滑板到了&lt;/p>
&lt;h2 id="从零开始了解滑板">从零开始了解滑板&lt;/h2>
&lt;p>滑板大概分为双翘板、小鱼板、大鱼板、长板和柯南板。
&lt;strong>双翘板&lt;/strong>是主流的动作板子，可以带板跳起来做动作。
&lt;strong>鱼板&lt;/strong>方便携带，主要用来代步另外，大鱼和小鱼在板型上没区别，成年人用小鱼板比较难站稳，相对来说更危险，建议成年人用大鱼板，小学生用小鱼板。
&lt;strong>长板&lt;/strong>有舞板和速降板，很重不建议用来代步，虽然很稳。
&lt;strong>柯南板&lt;/strong>是未来科技。&lt;/p>
&lt;p>不同类型的板适用不同的场景，按个人喜好进行选择，刚开始联系时带好护具注意安全即可，如果有毅力坚持练下去的建议亲自配一块专业板一步到位，反之可以考虑组装板。特别不建议购买玩具板，玩具板通常有很多缺点，板面没弹性、轮子大回弹差、桥很脆弱、轴承不顺滑，几个大幅度的动作板可能就断了，其唯一的好处可能就是便宜了。下文主要围绕双翘板展开讨论配件的选择。&lt;/p>
&lt;h3 id="trucks">Trucks&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_db6ad4bfced4c87e5848cb795af4e1d0.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_79599387eb3c99be963f9884ee5ea445.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_db6ad4bfced4c87e5848cb795af4e1d0.png"
width="500"
height="427"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>以目前的工艺水平来看，桥建议一步到位上进口桥，主流品牌有：&lt;/p>
&lt;ul>
&lt;li>I 桥 &lt;a href="https://independenttrucks.com/trucks" target="_blank" rel="noopener">Independent Trucks&lt;/a>&lt;/li>
&lt;li>V 桥 &lt;a href="https://venturetrucks.net" target="_blank" rel="noopener">VENTURE TRUCKS&lt;/a>&lt;/li>
&lt;li>T 桥或者叫雷桥 &lt;a href="https://www.thundertrucks.com" target="_blank" rel="noopener">THUNDER TRUCKS&lt;/a>&lt;/li>
&lt;li>D 桥 &lt;a href="https://destructotrucks.com" target="_blank" rel="noopener">DESTRUCTO&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以出厂硬度来说 Indy 大多为高软桥，V 桥有高有低硬桥，T 桥是低桥，D 桥大多高硬桥。高桥会把板子撑得更高，也能避免轮子太大卡板。板的硬度主要由 PU 决定，PU 全称 Polyurethane，聚氨基甲酸酯。刚接触滑板用硬桥更好，软桥比较考验使用者的平衡能力，从软硬角度考虑硬桥会比较稳，但切记不可通过拧紧主桥螺母来使 PU 变硬，PU 是可能被挤爆的。&lt;/p>
&lt;p>桥的宽度一般要与板匹配，以 I 桥为例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Truck Size&lt;/th>
&lt;th>Axle Width (in)&lt;/th>
&lt;th>Deck Size (in)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>215&lt;/td>
&lt;td>10.00&lt;/td>
&lt;td>9.5 - 10.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>169&lt;/td>
&lt;td>9.125&lt;/td>
&lt;td>9 - 9.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>159&lt;/td>
&lt;td>8.75&lt;/td>
&lt;td>8.6 - 9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>149&lt;/td>
&lt;td>8.50&lt;/td>
&lt;td>8.375 - 8.6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>144&lt;/td>
&lt;td>8.25&lt;/td>
&lt;td>8.2 - 3.375&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>139&lt;/td>
&lt;td>8.00&lt;/td>
&lt;td>7.8 - 8.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>129&lt;/td>
&lt;td>7.60&lt;/td>
&lt;td>7.4 - 7.8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>109&lt;/td>
&lt;td>6.90&lt;/td>
&lt;td>6.25 - 7.6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例如 8.25 的板子配 144 的 I 桥是最优的，根据材料和结构的不同，I 桥划分了几个系列：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>TRUCKS&lt;/th>
&lt;th>Tall&lt;/th>
&lt;th>Hanger&lt;/th>
&lt;th>Baseplate&lt;/th>
&lt;th>Axle&lt;/th>
&lt;th>Kingpin&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>STAGE 11 MID&lt;/td>
&lt;td>55mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>4140 Chromoly&lt;/td>
&lt;td>Grade 8&lt;/td>
&lt;td>215 Available&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 MID&lt;/td>
&lt;td>52mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>4140 Chromoly&lt;/td>
&lt;td>Inverted，Grade 8&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 HOLLOW&lt;/td>
&lt;td>55mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 FORGED HOLLOW&lt;/td>
&lt;td>53.5mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Forged 6061 Aluminum&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>10% Lighter&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 FORGED TITANIUM&lt;/td>
&lt;td>53.5mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Forged 6061 Aluminum&lt;/td>
&lt;td>Solid Titanium&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>15% Lighter&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>个人用的是 I 桥 144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard。&lt;/p>
&lt;figure id="figure-144-stage-11-forged-hollow-chris-joslin-silver-blue-standard">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://ptw.nhs-inc.com/product_images/48367.jpg" alt="144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard" loading="lazy" data-zoomable width="600" />&lt;/div>
&lt;/div>&lt;figcaption>
144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard
&lt;/figcaption>&lt;/figure>
&lt;h3 id="deck">Deck&lt;/h3>
&lt;p>
&lt;figure id="figure-侧视图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="侧视图" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_c29ee4e9d4982a31ba3c4e3bd052d9e5.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_e0e339aa904b3a89c75cc3db87b93938.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_c29ee4e9d4982a31ba3c4e3bd052d9e5.png"
width="550"
height="166"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
侧视图
&lt;/figcaption>&lt;/figure>
&lt;figure id="figure-俯视图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="俯视图" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_0f7588260c8af2202ad1f788dc7847d4.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_efaabd6a5103d31ac0642c332f58eeef.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_0f7588260c8af2202ad1f788dc7847d4.png"
width="550"
height="228"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
俯视图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>比较好的版面有：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://girlskateboards.com/former-amateurs" target="_blank" rel="noopener">Girl Skateboards&lt;/a>&lt;/li>
&lt;li>Almost&lt;/li>
&lt;li>Baker&lt;/li>
&lt;li>&lt;a href="https://santacruzskateboards.com" target="_blank" rel="noopener">SANTA CRUZ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zeroskateboards.com" target="_blank" rel="noopener">Zero Skateboards&lt;/a>&lt;/li>
&lt;li>Element&lt;/li>
&lt;li>&lt;a href="https://chocolateskateboards.com/erik" target="_blank" rel="noopener">chocolate&lt;/a>&lt;/li>
&lt;li>Boardhead&lt;/li>
&lt;li>&lt;a href="https://flipskateboards.com" target="_blank" rel="noopener">flipskateboards&lt;/a>&lt;/li>
&lt;li>Powell Peralta&lt;/li>
&lt;li>Anti Hero&lt;/li>
&lt;/ul>
&lt;p>进口板一般弹性可以维持数个月以上，国产板稍差一些。木材与结构和胶水是板弹性的决定性因素，木质滑板一由七层枫木用胶水粘合后压制而成，核心在于每一层薄片的选材和质量把关。&lt;/p>
&lt;p>关于压制工艺：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>热压&lt;/strong>为加温压制，热压板更适合批量标准化生产，目前热压技术更普及&lt;/li>
&lt;li>&lt;strong>冷压&lt;/strong>为常温压制&lt;/li>
&lt;/ul>
&lt;p>热压和冷压对板弹性维持时间的影响微乎其微，两个压制的区别仅仅是在压制板的时候加不加温度，个人目前自用 GIRL，弹性很好。&lt;/p>
&lt;h3 id="wheels">Wheels&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_2b6e4bb4ca820f9e4cb2d6a2a12e00fd.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_f332793aa9f0e57c1eebecb8179cdaba.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_2b6e4bb4ca820f9e4cb2d6a2a12e00fd.png"
width="300"
height="607"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>动作轮一般是硬轮，硬度在 99A - 105A 左右，直径一般在 52mm - 54mm 偏小，回弹更好做滑板动作。刚开始练习时，硬轮由于硬度关系很容易被小碎石卡住，如果没掌握正确的摔倒姿势的话就会很危险。反之公路轮为软轮，有时也会被叫做刷街轮，通常硬度在 78A 到 90A 左右，公路轮比较大和软一般会配高桥，直径一般在 55mm - 60mm，在公路上不震脚可以压过小石头，相对动作轮更安全舒服。所以建议同时有刷街和做动作需求的备两套轮子，并且由于取轴承是比较麻烦的事情，所以建议每套轮子都配上一套轴承。&lt;/p>
&lt;p>主流轮子品牌有：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bones.com" target="_blank" rel="noopener">BONES&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rictawheels.com" target="_blank" rel="noopener">RICTA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.spitfirewheels.com" target="_blank" rel="noopener">SPITFIRE WHEELS&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>对于公路轮由于体积较大，有卡板的风险，高速滑行时卡板会十分危险，通常 56mm 的即可。如果有需求要用更大的轮子比如 60mm，建议高桥再配合桥垫做增高，桥垫同样有避震的作用，可以防止桥把板体压坏。最后对于全能轮这个概念，个人觉得轮子只看硬度和大小，全能轮从硬度来看其实大多都是软轮。&lt;/p>
&lt;h3 id="bearings">Bearings&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_f4f7b5e1c2e26d0d4bf54cfbf2f0ff4e.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_85d0c364c9d2d8d3d9cf2cc35f43da27.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_f4f7b5e1c2e26d0d4bf54cfbf2f0ff4e.png"
width="300"
height="604"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>轴承的核心在于是否稳定，不容易爆轴，关于轴承的标准有 ABEC-5、ABEC-7、ABEC-9 等，比起数值来说更重要的还是稳定性。轴承比较推荐 Skate One 的 BONES，Skate One 还有另一个轴承品类 MINI LOGO，个人比较推荐 BONES Red，为国内代工。&lt;/p>
&lt;p>更高端的轴承有例如 BONES SWISS 陶瓷轴承，LUCKY 钛合金轴承，不过提升有限，边际效应较明显。&lt;/p>
&lt;h3 id="grip-tape-砂纸">Grip Tape 砂纸&lt;/h3>
&lt;p>没用过大牌的砂纸，砂纸个人认为是消耗极快的配件，&lt;/p>
&lt;h3 id="板钉">板钉&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_4acc4c757fdfd5ccdd00f02e7e72e8f0.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_07b44e926cfee555ddcb8308b530c238.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_4acc4c757fdfd5ccdd00f02e7e72e8f0.png"
width="300"
height="332"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>最普通的配件，没什么好说的，太贵的就是智商税。&lt;/p>
&lt;h3 id="护具">护具&lt;/h3>
&lt;p>护具该有的还是要有，尤其是刚接触滑板的新人，保护好自己是非常重要的。像滑板、滑雪之类的运动，首要就是要学会如何摔倒，掌握正确的摔倒姿势与方法才能更好的保护自己，护具能够很好的帮助度过这个学习期的，切忌嫌护具丑而不带护具，骨折了可就得不偿失了。&lt;/p>
&lt;h3 id="关于鞋子">关于鞋子&lt;/h3>
&lt;p>不考虑代步，如果是经常做动作的话，鞋底很容易被砂纸磨薄，做动作的建议配一双滑板鞋，比较专业的牌子如下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.dcshoes.com/?geopopup=false" target="_blank" rel="noopener">DC Shoes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.vanstaiwan.com" target="_blank" rel="noopener">Vans&lt;/a>，容易开胶，Pro 系列只推荐联名 &lt;a href="https://www.vans.com/team/skate/geoff-rowley.html" target="_blank" rel="noopener">Geoff Rowley&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.esskateboarding.com/us/" target="_blank" rel="noopener">éS Skateboarding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.emerica.com/us/" target="_blank" rel="noopener">Emerica&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.etnies.com/us/" target="_blank" rel="noopener">Etnies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.converse.com.tw" target="_blank" rel="noopener">CONVERSE&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fallenfootwear.us" target="_blank" rel="noopener">FALLEN FOOTWEAR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.lakai.com" target="_blank" rel="noopener">LAKAI&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.dekline.com" target="_blank" rel="noopener">DEKLINE FOOTWEAR&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="养护方法">养护方法&lt;/h2>
&lt;h3 id="桥">桥&lt;/h3>
&lt;p>桥作为最重要的核心大件，零件较多需要分开讲。&lt;/p>
&lt;h4 id="主体">主体&lt;/h4>
&lt;p>桥作为一个较为耐用的部件，建议进行一定程度的保养。一些桥比如 I 桥的桥轴部分是锻造铬钼钢，空心桥轴内部非常生锈，建议用防锈油进行保养。切忌不要用桥撬轴承，桥的螺纹是很错弱的。&lt;/p>
&lt;h4 id="pu">PU&lt;/h4>
&lt;p>PU 作为减震器，和人的膝盖一样很脆弱，切忌主桥钉螺母不能拧过紧以避免 PU 开裂或者被挤爆，部分选手喜欢拧紧主要是不熟悉过软的桥导致的左右晃动，正确方式是换一个更硬的 PU。&lt;/p>
&lt;h4 id="桥端螺母">桥端螺母&lt;/h4>
&lt;p>侧螺母具有保护桥端螺纹的作用，一旦发现螺母形变或者滑牙需要及时更换，防止支架被的螺纹被螺母损坏。一般建议多备一些侧螺母，经常更换以保护桥主体。&lt;/p>
&lt;h3 id="板面">板面&lt;/h3>
&lt;p>滑板的板面通常是木制，相对其他的金属件来说会更脆弱，动作板为了保持弹性要注意尽量保持干燥，使用上切忌爱惜板面而放不开，每换一块板意味着你的一次成长。雨雪天的情况下不要玩板，如果不防水的板沾水，木头就会受潮变得酥软，从而失去弹性。&lt;/p>
&lt;h3 id="轴承">轴承&lt;/h3>
&lt;p>轴承是主要的承重部位，轮子受到强烈的冲击后，非常容易被挤压导致爆轴承。同时由于轴承非常贴近地面，间隙之间极易容易进入小的颗粒物，高速旋转的状态下很快就会磨损，顺滑度也会降低，慢慢的就会损坏。此外如果是不防锈的轴承则需要注意进水生锈，如果不小心轮子过水，需要快速转动轮子甩水。&lt;/p>
&lt;p>轴承特别容易藏污纳垢，高端的轴承建议常清洗。轴承清洗时需要把防尘盖拆除，具体方法用曲别针从轴承的另一侧将防尘盖顶出，拆下的防尘盖用水清洗做一下防锈即可。轴承部分可以用 95% 酒精、汽油、煤油等油污易溶溶剂清洗，讲究一点可以配合 Bones 的清洗瓶。清洗轴承的主要目的是去除原本的润滑油脂或者防锈油以及滑行过程中残留的污垢，洗完后去除水分保持干燥然后上润滑油接着使用或者上防锈油储藏，润滑油大同小异，讲究的可以用 Bones 的润滑油。一般新轴承上油脂是用于防止轴承生锈，没有润滑作用，所以在洗完之后需要上润滑油。&lt;/p>
&lt;h3 id="轮子">轮子&lt;/h3>
&lt;p>不怎么容易坏的耗材，变形或者坏了换新即可。&lt;/p>
&lt;h3 id="砂纸">砂纸&lt;/h3>
&lt;p>由于砂纸被踩在脚下，所以极其容易脏。砂纸不能用水清洗，会脱沙水失去摩擦力，板就没法被脚带起来。如果觉得没有到要换的程度的话，可以用砂纸擦进行处理，砂纸太脏建议直接更换。&lt;/p>
&lt;h3 id="桥钉">桥钉&lt;/h3>
&lt;p>最廉价的部件，不用怎么保养坏了就换。&lt;/p>
&lt;p>总结来说不用过于爱惜板，板存在的价值是用来滑的，板越新越说明是板混。滑板一旦长久搁置就容易受潮生锈，板也会失去弹性，一个玩了很久的板还和新的一样的话，它就失去了灵魂。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Skateboard" target="_blank" rel="noopener">Skateboard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://independenttrucks.com/truck-guide" target="_blank" rel="noopener">TRUCK GUIDE&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://venturetrucks.net/sizes/" target="_blank" rel="noopener">RIDE THE RIGHT SIZE TRUCK&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.thundertrucks.com/sizing/" target="_blank" rel="noopener">CHOOSE THE RIGHT SIZE FOR YOU&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://destructotrucks.com" target="_blank" rel="noopener">DESTRUCTO&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.skateone.com" target="_blank" rel="noopener">Skate One&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.startskateboardingnow.com/skateboard-anatomy-101.html" target="_blank" rel="noopener">Skateboard Anatomy 101&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="glossary">Glossary&lt;/h2>
&lt;h4 id="部件">部件&lt;/h4>
&lt;ul>
&lt;li>Deck 板&lt;/li>
&lt;li>Truck 桥&lt;/li>
&lt;li>Wheel 轮子&lt;/li>
&lt;li>Bearing 轴承&lt;/li>
&lt;li>Baseplate 底座&lt;/li>
&lt;/ul>
&lt;h4 id="truck">Truck&lt;/h4>
&lt;ul>
&lt;li>Tall 高度&lt;/li>
&lt;li>Axle nut 桥轴端螺母&lt;/li>
&lt;li>Axle washers 桥轴端垫片x&lt;/li>
&lt;li>Axle 桥轴&lt;/li>
&lt;li>Hanger 悬轴&lt;/li>
&lt;li>Kingpin 转向立轴&lt;/li>
&lt;li>Kingpin nut 立轴螺母&lt;/li>
&lt;li>Top cup washer 顶部杯形垫圈&lt;/li>
&lt;li>Bushing PU 垫&lt;/li>
&lt;li>Cone bushing 锥型 PU 垫&lt;/li>
&lt;li>Cushing 软垫&lt;/li>
&lt;li>Lower cup washer 底部杯形垫圈&lt;/li>
&lt;/ul>
&lt;h4 id="材料">材料&lt;/h4>
&lt;ul>
&lt;li>Aluminum 铝合金&lt;/li>
&lt;li>Chromoly 铬钼钢&lt;/li>
&lt;li>Forged Aluminum 锻造铝合金&lt;/li>
&lt;li>Hollow Chromoly 中空铬钼钢&lt;/li>
&lt;li>Solid Titanium 纯钛&lt;/li>
&lt;li>Grade 8 美制 8 级标准&lt;/li>
&lt;li>Inverted 倒置&lt;/li>
&lt;/ul></description></item><item><title>Typefaces 索引</title><link>/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/</link><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><guid>/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/</guid><description>&lt;h2 id="adobe-fonts">Adobe Fonts&lt;/h2>
&lt;h4 id="source-serifhttpsadobe-fontsgithubiosource-serif">&lt;a href="https://adobe-fonts.github.io/source-serif/" target="_blank" rel="noopener">Source Serif&lt;/a>&lt;/h4>
&lt;h4 id="source-sanshttpsadobe-fontsgithubiosource-sans">&lt;a href="https://adobe-fonts.github.io/source-sans/" target="_blank" rel="noopener">Source Sans&lt;/a>&lt;/h4>
&lt;h4 id="source-code-prohttpsadobe-fontsgithubiosource-code-pro">&lt;a href="https://adobe-fonts.github.io/source-code-pro/" target="_blank" rel="noopener">Source Code Pro&lt;/a>&lt;/h4>
&lt;h2 id="microsoft-fonts">Microsoft Fonts&lt;/h2>
&lt;h4 id="cascadia-codehttpsgithubcommicrosoftcascadia-code">&lt;a href="https://github.com/microsoft/cascadia-code" target="_blank" rel="noopener">Cascadia Code&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/microsoft/cascadia-code/main/images/cascadia-code.png" alt="" loading="lazy" data-zoomable width="300px" />&lt;/div>
&lt;/div>&lt;/figure>
&lt;ul>
&lt;li>&lt;code>Cascadia Code&lt;/code>: standard version of Cascadia&lt;/li>
&lt;li>&lt;code>Cascadia Mono&lt;/code>: a version of Cascadia that doesn&amp;rsquo;t have ligatures&lt;/li>
&lt;li>&lt;code>Cascadia (Code|Mono) PL&lt;/code>: a version of Cascadia that has embedded Powerline symbols&lt;/li>
&lt;/ul>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/microsoft/cascadia-code/main/images/cascadia-code-characters.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="google-fontshttpsfontsgooglecom">&lt;a href="https://fonts.google.com" target="_blank" rel="noopener">Google Fonts&lt;/a>&lt;/h2>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./google-fonts.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h4 id="google-noto-fontshttpswwwgooglecomgetnoto">&lt;a href="https://www.google.com/get/noto/" target="_blank" rel="noopener">Google Noto Fonts&lt;/a>&lt;/h4>
&lt;h2 id="jetbrains-fonts">JetBrains Fonts&lt;/h2>
&lt;h4 id="jetbrains-monohttpswwwjetbrainscomlpmono">&lt;a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">JetBrains Mono&lt;/a>&lt;/h4>
&lt;h2 id="other-fonts">Other Fonts&lt;/h2>
&lt;h4 id="firacodehttpsgithubcomtonskyfiracode">&lt;a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">FiraCode&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/tonsky/FiraCode/master/extras/download.png" alt="" loading="lazy" data-zoomable width="300px" />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure id="figure-ligatures-cheatsheet">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/tonsky/FiraCode/master/extras/ligatures.png" alt="ligatures cheatsheet" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ligatures cheatsheet
&lt;/figcaption>&lt;/figure>
&lt;h4 id="geomanisthttpswwwatipofoundrycomfontsgeomanist">&lt;a href="https://www.atipofoundry.com/fonts/geomanist" target="_blank" rel="noopener">geomanist&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.atipofoundry.com/media/pages/fonts/geomanist/2024424344-1591511652/geomanist-01.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">tonsky/FiraCode&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>如何写出一篇好博文</title><link>/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>谈起这个博客，建立之初只是为了记录一些技术相关的话题，用来沉淀一些日常学习的技术知识点以及做备忘用。随着时间流逝已经 5 个年头了，写作也变成了一个习惯保持了下来，也不断的尝试从原来的计算机科学学术类逐渐扩大到 STEM 乃至其他的各类型的文章。&lt;/p>
&lt;ul class="cta-group">
&lt;li>
&lt;a href="/post/gossip/first-post" target="_blank" rel="noopener" class="btn btn-primary px-3 py-3">&lt;strong>创篇号&lt;/strong> (2014)&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>随着不断的学习与深入，就越发会觉得自身各类知识面的狭窄与片面，潜在的求知欲被这种外在的驱动力所激发，促使着你不断挖掘知识的深度与拓宽学术广度。在写作过程中，如何组织与管理跨学科文章，如何针对选题主旨拿捏文本表现形式成为了不小的问题。由于理工科和文科在学术侧重上的区别会导致行文风格和段落组织大相径庭，比如 STEM 更强调数理逻辑和科学证明，会以各类图表和数据来增加文本说服力；在文章的选题上存在强调客观事实的文档或者说明类，也存在发表个人观点的强主观意愿的内容，不同的文章会有不同的处理方式，后续有机会抽几个章节赘述。&lt;/p>
&lt;h2 id="为什么要写文章">为什么要写文章&lt;/h2>
&lt;p>就如美国物理学家&lt;a href="https://en.wikipedia.org/wiki/John_Archibald_Wheeler" target="_blank" rel="noopener">约翰·阿奇博尔德·惠勒&lt;/a>所说：&lt;/p>
&lt;blockquote>
&lt;p>“One can only learn by teaching.” — John Archibald Wheeler&lt;/p>
&lt;/blockquote>
&lt;p>以教为学是一个很好的学习方法，如果一个复杂深奥的问题能用直白浅显的语言讲清楚并传授给他人，那么说明这个知识点已经被学习者真正理解并运用。通常这么做可以促使你剖析知识要点，用你自己对领域知识的了解程度去做易懂的总结，这个过程会促使你回顾你学习过的内容，对知识盲区进行查漏补缺，直到最终能够用大白话、最简单的术语去描述并让人听懂。从个人角度来说，写文章的本质就是学习的沉淀，沉淀的目的是为了提炼再利用，这个过程就是一个知识的提炼总结以及教授传递。就好比字典、词典存在的意义：&lt;/p>
&lt;ul>
&lt;li>提供语言领域内的使用指南&lt;/li>
&lt;li>字、词汇、语言的知识点速查&lt;/li>
&lt;li>知识的传递&lt;/li>
&lt;/ul>
&lt;p>写文章简单，写出有深度的文章难，写出即易懂又有深度的文章是难中之难。只学不沉淀必然会遗忘，再次遇到同样的问题就需要花时间重新回忆或直接踩坑，这就是写作与沉淀的目的。同样，在提炼沉淀之余，分类与索引也是必不可少的，上文提到写作的重要目的之一是再利用，如果只是写了文章而从不去使用，那就好比把一篇很有营养的文章加入了你的收藏夹，心想下次一定能用到，渐渐的你就会发现收藏夹越来越臃肿难以管理，最终变成你成长过程中的过客，这样的场景是不是似曾相识。&lt;/p>
&lt;p>所以本博客的所有文章会以忽略选题的内容为前提，把文章内容涉及到的学科领域作为类别归属，在此基础上以 CIP 的策略作分类化管理，使得学科特定的知识点查找与索引会非常简便。&lt;/p>
&lt;h2 id="写作工具">写作工具&lt;/h2>
&lt;h3 id="博客系统">博客系统&lt;/h3>
&lt;h4 id="hugo">Hugo&lt;/h4>
&lt;p>开发者文档&lt;/p>
&lt;p>&lt;a href="https://gohugo.io/documentation/" target="_blank" rel="noopener">Docs&lt;/a>&lt;/p>
&lt;h4 id="hexo">Hexo&lt;/h4>
&lt;p>关于 Hexo 的搭建可以参考
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">用 Hexo 搭建个人博客&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/p>
&lt;h3 id="用富媒体润色文本">用富媒体润色文本&lt;/h3>
&lt;h4 id="图标">图标&lt;/h4>
&lt;p>&lt;a href="https://www.flaticon.com" target="_blank" rel="noopener">flaticon&lt;/a>&lt;/p>
&lt;h4 id="图床">图床&lt;/h4>
&lt;p>出于各种目的，比如减少服务器的压力、加快加载速度、减少发布包的体积等，图片资源会通常以 CDN 的形式来存储与部署，这里就要用到各种 CDN 服务。&lt;/p>
&lt;ul>
&lt;li>
&lt;h5 id="github-user-images">GitHub &lt;code>user-images&lt;/code>&lt;/h5>
&lt;p>在 GitHub 提 &lt;code>issue&lt;/code> 时添加图片，GitHub 会将图片资源会分发至 CDN，生成地址为 &lt;code>user-images.githubusercontent.com/{path}/{hash}&lt;/code> 的链接，从某种角度来看 GitHub 可以用来作图床。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="用更强说服力的图表代替语言">用更强说服力的图表代替语言&lt;/h3>
&lt;h4 id="mermaid">Mermaid&lt;/h4>
&lt;p>&lt;a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">Mermaid&lt;/a> 是一个集流程图、状态图、时序图、甘特图绘制库，使用 DSL 代码就可以绘制出漂亮清晰的图片，配合上 markdown 是 STEM 相关文章的利器，同时提供了&lt;a href="https://mermaid-js.github.io/mermaid-live-editor/" target="_blank" rel="noopener">在线编辑器&lt;/a>提供实时预览。&lt;/p>
&lt;h4 id="plotly">Plotly&lt;/h4>
&lt;p>&lt;a href="https://plotly.com" target="_blank" rel="noopener">Plotly&lt;/a> 是一个通过 &lt;code>JSON&lt;/code> 作为数据源的图标绘制工具，并且提供了可视化&lt;a href="http://plotly-json-editor.getforge.io" target="_blank" rel="noopener">在线编辑工具&lt;/a>。&lt;/p>
&lt;h2 id="文章的表现力">文章的表现力&lt;/h2>
&lt;p>表现力需要更具选题的内容来作具体调整。&lt;/p>
&lt;h3 id="stem">STEM&lt;/h3>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/">创篇号&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol></description></item><item><title>鼻炎与鼻窦炎全解析</title><link>/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate><guid>/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>&lt;h2 id="鼻炎">鼻炎&lt;/h2>
&lt;p>鼻炎和咽炎有着密切的联系，临床上治咽炎先治鼻炎的病例很多，因为人体的五官是相通的，咽炎主要是由于咽喉位于呼吸道与消化道的要冲。长期鼻塞、张开呼吸造成干冷空气直达喉部而产生干痛。而粘稠痰常附于咽喉壁克引起刺激性咳嗽，甚至引起恶心、干呕。长期鼻涕倒流刺激咽喉引起咽喉炎如异物感、咽痒、灼热、干燥、微疼等。&lt;/p>
&lt;p>鼻炎是特别让人不舒服的病，得了鼻炎，呼吸不顺畅，连睡觉都睡不好真是让人烦恼。在大城市中，每十个人里面，就有一个是鼻炎患者，久治不愈很容易变成致死性的鼻咽癌，鼻咽癌是我国高发恶性肿瘤之一，发病率为耳鼻咽喉恶性肿瘤之首。全世界 80% 的鼻咽恶性肿瘤是鼻炎久治不愈恶化所致。鼻咽癌的表现为病侧耳鸣且逐渐加重，并伴有听力下降。鼻炎的主要危害有儿童毁容、学生智商降低、女性对生育造成严重影响、男性增加患高血压的风险、老年人危害生命。鼻炎是一种常见病，同时也是一种危险的疾病，如不及时治疗就会导致多种并发症如慢性鼻炎、鼻窦炎等。&lt;/p>
&lt;p>2017 年 11 月 29 日星尚频道 X 诊所节，主题《鼻炎知多少》，嘉宾刘环海，第二军医大学附属长征医院耳鼻咽喉头颈外科科室主任，上海市耳鼻咽喉头颈外科学会常委兼秘书长。&lt;/p>
&lt;h2 id="鼻窦炎病理">鼻窦炎病理&lt;/h2>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/RywHs4kKxjA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="窦道堵塞">窦道堵塞&lt;/h2>
&lt;h3 id="症状缓解">症状缓解&lt;/h3>
&lt;p>通常来说，窦道堵塞是由于鼻窦黏膜水肿导致。在不借助手术、洗鼻等外部手段的情况下，缓解堵塞的方法通常是以加速鼻腔部位的血脉循环为主要手段，所以鼻窦炎患者在一些特定的场景下，可能会出现窦道短暂的通畅，包括但不限于：&lt;/p>
&lt;ul>
&lt;li>精神紧张或者突然收到惊吓，交感神经的兴奋会使得血管收缩&lt;/li>
&lt;li>就寝时单侧窦道堵塞，采用对侧卧位睡姿，堵住侧会变得通畅&lt;/li>
&lt;li>进行运动之后，运动会使得全身血液更加循环畅通，通常窦道缓解的时间会相对更长，运动对于鼻窦炎以及自身免疫会有很大帮助&lt;/li>
&lt;/ul>
&lt;p>日常对脸部的穴位按摩也能促进血液循环，包括迎香穴和两眉之间，额窦的部位就是在眉间偏上部位，其带来效果的通畅常常持续几分钟左右。血液循环畅通了，黏膜水肿自然会暂时缓解，更多可以参考下方视频。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/-vBGW43EjG4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h3 id="注意事项">注意事项&lt;/h3>
&lt;p>鼻窦炎患者要注意尽量避免接触突然的冷空气或者其他刺激性气味或者各类过敏源。&lt;/p></description></item><item><title>深入了解 Protocol Buffers</title><link>/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/</link><pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate><guid>/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protocolbuffers/protobuf: Protocol Buffers &lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Protocol Buffers | Google Developers&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 QUIC Transport Protocol</title><link>/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/</link><pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate><guid>/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/draft-ietf-quic-transport-34.pdf" target="_blank" rel="noopener">QUIC: A UDP-Based Multiplexed and Secure Transport&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.ietf.org/proceedings/98/slides/slides-98-edu-sessf-quic-tutorial-00.pdf" target="_blank" rel="noopener">QUIC Tutorial&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://blog.cloudflare.com/the-road-to-quic/" target="_blank" rel="noopener">The Road to QUIC&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC, a multiplexed stream transport over UDP&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 HTTPS</title><link>/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/</link><pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/</guid><description>&lt;p>Hypertext Transfer Protocol Secure，超文本传输安全协议，又称 HTTP over TLS。是经由 HTTP 进行通信，并利用 SSL/TLS 来加密。HTTPS 主要目的是为了提供对服务器的身份认证，与传输过程中的数据完整性不被篡改，最早由网景（Netscape）在 1994 年提出，应用在网景领航员浏览器中。&lt;/p>
&lt;p>HTTP 在作数据传输协议使用时，由于是明文传输无任何安全保证，会存在内容被窃听的问题；由于没有身份认证机制，通信过程中会面临中间人攻击，例如数据被篡改、服务器身份伪装等。正因为 HTTP 存在这些风险问题才诞生了 HTTPS。&lt;/p>
&lt;p>HTTPS 本质上是一个复合协议，由 HTTP、TSL/SSL、TCP 协同工作，因此会涉及到较多领域的内容比如密码学、公钥与私钥、加密与认证、数字证书、数字签名等。&lt;/p>
&lt;p>此外 HTTPS 可能会与 &lt;a href="https://tools.ietf.org/pdf/rfc2660.pdf" target="_blank" rel="noopener">RFC 2660&lt;/a> 中的安全超文本传输协议 S-HTTP 相混淆。两者都为 HTTP 安全传输的实现，S-HTTP 为应用层协议，主要对传输内容加密；HTTPS 的核心为 SSL/TSL，SSL/TSL 协议位于传输层与应用层之间，确保整个通信过程都是安全的。&lt;/p>
&lt;h2 id="https-通信流程">HTTPS 通信流程&lt;/h2>
&lt;p>如上文所述，HTTPS 是对 HTTP 的扩展，由三部分组成，通信流程可以简化为：&lt;/p>
&lt;ol>
&lt;li>通信双方通过三次握手建立 TCP 连接&lt;/li>
&lt;li>通信双方通过四次握手建立 TLS 连接&lt;/li>
&lt;li>HTTP Client 向 Server 发送请求，Server 响应返回 Response&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-mermaid">sequenceDiagram
autonumber
participant Client
participant Server
rect rgb(191, 223, 255)
Client -&amp;gt;&amp;gt; Server: Request https://www.google.com
note right of Server: Encrypt Algorithm&amp;lt;br/&amp;gt;Hash Algorithm
end
rect rgb(200, 150, 255)
Server-&amp;gt;&amp;gt;Client: Return Certificate
Client-&amp;gt;&amp;gt;Client: Is Certificate Valid?
Note over Client, Server: Invalid, show prompt.
Client-&amp;gt;&amp;gt;Client: Is Valid, Random Magic Number R.
Client-&amp;gt;&amp;gt;Client: Encrypt R with Public Key In Certificate
end
rect rgb(191, 223, 255)
Client-&amp;gt;&amp;gt;Server: Transfer Encrypted R to Server
Server-&amp;gt;&amp;gt;Server: Decrypted R with Private Key
Server-&amp;gt;&amp;gt;Server: Encrypt Content with R
end
rect rgb(200, 150, 255)
Server-&amp;gt;&amp;gt;Client: Return Encrypted Content
Client-&amp;gt;&amp;gt;Client: Decrypt Content with R
end
&lt;/code>&lt;/pre>
&lt;h3 id="建立-tcp-链接">建立 TCP 链接&lt;/h3>
&lt;p>更多关于 TCP 的内容从以下这篇文章进一步了解。&lt;/p>
&lt;div class="card-simple">
&lt;div class="article-metadata">
&lt;div>
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/div>
&lt;span class="article-date">
Wed, May 03, 2017
&lt;/span>
&lt;span class="middot-divider">&lt;/span>
&lt;span class="article-reading-time">
1 分钟阅读时长
&lt;/span>
&lt;br>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-feather-alt">&lt;/i>
&lt;strong class="mr-1">CIP&lt;/strong>
&lt;/font>&lt;a href="/cip/11.07-computer-science/">11.07) Computer Science&lt;/a>
,
&lt;a href="/cip/11.0701-computer-science/">11.0701) Computer Science&lt;/a>&lt;/span>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-hashtag mr-1">&lt;/i>
&lt;/font>
&lt;a href="/category/nc.-networking-and-communication/">NC. Networking and Communication&lt;/a>&lt;/span>
&lt;/div>
&lt;div class="section-subheading article-title mb-1 mt-3">
&lt;a href="/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/">深入了解 TCP&lt;/a>
&lt;/div>
&lt;a href="/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/" class="summary-link">
&lt;div class="article-style">
&lt;p>TCP 详解&lt;/p>
&lt;/div>
&lt;/a>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc793.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 793
&lt;/a>
&lt;/div>
&lt;/div>
&lt;h3 id="建立-tls-链接">建立 TLS 链接&lt;/h3>
&lt;p>建立 TCP 链接后需要进行 TLS 握手，以浏览器和服务器的通信为例，通常 HTTPS 做单向认证，用于鉴别服务端的真伪，简化流程的如下：&lt;/p>
&lt;ol>
&lt;li>浏览器向服务器的 TLS 端口（一般为 443）发起请求，此次请求携带了支持的加密算法和哈希算法。&lt;/li>
&lt;li>服务器收到请求，选择浏览器支持的加密算法和哈希算法。&lt;/li>
&lt;li>服务器将数字证书返回给浏览器，这里的数字证书可以是向权威机构比如 CA 申请的，也可以是自签名证书。&lt;/li>
&lt;li>浏览器进入数字证书认证环节，这一部分是浏览器内置的 TLS 模块完成的。
&lt;ul>
&lt;li>首先浏览器会从系统内置的证书列表中索引，找到服务器下发证书对应的机构。&lt;/li>
&lt;li>如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。&lt;/li>
&lt;li>如果查到了对应的机构，则取出该机构颁发的公钥。&lt;/li>
&lt;li>用机构的证书公钥解密得到证书的内容和证书数字签名，内容包括服务器的地址、服务器的公钥、证书的有效期等。&lt;/li>
&lt;li>浏览器首先验证数字签名的合法性，验证过程类似 Bob 和 Pat 的通信过程。&lt;/li>
&lt;li>签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。&lt;/li>
&lt;li>如果网址一致会检查证书有效期，证书过期了也会提示用户。&lt;/li>
&lt;li>以上都通过认证时，浏览器就可以安全使用证书中的服务器公钥了。&lt;/li>
&lt;li>浏览器生成一个随机数 R，并使用服务器的公钥对 R 进行加密。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>浏览器将加密之后的 R 传送给服务器。&lt;/li>
&lt;li>服务器用自己的私钥解密得到 R。&lt;/li>
&lt;li>服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。&lt;/li>
&lt;li>浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。&lt;/li>
&lt;/ol>
&lt;p>整个过程主要为了认证服务端证书以及的公钥的合法性，因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法，主要是用来保护传输客户端生成的 &lt;code>Premaster Secret&lt;/code> 用于对称加密的随机数私钥。后续内容传输都为对称加密。&lt;/p>
&lt;p>通常 TLS 会在系统内置的可信证书列表内索引匹配的证书链。这一过程也有例外，例如 macOS 上，Safari、Edge 和 Chrome 建立 TLS 连接时会从系统的 Keychain Access 根证书去索引；而 Firefox 安全度更高，会在浏览器内置的证书中索引，防止在系统被注入证书时 HTTPS 被窃听，常见的抓包软件就是通过把自签名证书注入到系统的证书链中以实现 HTTPS 的拦截。&lt;/p>
&lt;p>更多关于 SSL/TLS 的详细内容从以下这篇文章进一步了解。&lt;/p>
&lt;div class="card-simple">
&lt;div class="article-metadata">
&lt;div>
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/div>
&lt;span class="article-date">
Tue, May 09, 2017
&lt;/span>
&lt;br>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-feather-alt">&lt;/i>
&lt;strong class="mr-1">CIP&lt;/strong>
&lt;/font>&lt;a href="/cip/11.07-computer-science/">11.07) Computer Science&lt;/a>
,
&lt;a href="/cip/11.0701-computer-science/">11.0701) Computer Science&lt;/a>&lt;/span>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-hashtag mr-1">&lt;/i>
&lt;/font>
&lt;a href="/category/nc.-networking-and-communication/">NC. Networking and Communication&lt;/a>&lt;/span>
&lt;/div>
&lt;div class="section-subheading article-title mb-1 mt-3">
&lt;a href="/post/tech-for-good/deep-dive-into-ssl-tls/">深入了解 SSL/TLS Protocol&lt;/a>
&lt;/div>
&lt;a href="/post/tech-for-good/deep-dive-into-ssl-tls/" class="summary-link">
&lt;div class="article-style">
&lt;p>SSL/TLS 协议详解&lt;/p>
&lt;/div>
&lt;/a>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://toolietf.org/pdf/rfc6101.pdfs." target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 6101
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc2246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 2246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc4346.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 4346
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc5246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 5246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc8446.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 8446
&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2818.pdf" target="_blank" rel="noopener">HTTP Over TLS&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2660.pdf" target="_blank" rel="noopener">The Secure HyperText Transfer Protocol&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 HTTP</title><link>/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/</link><pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2616.pdf" target="_blank" rel="noopener">Hypertext Transfer Protocol &amp;ndash; HTTP/1.1&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc7231.pdf" target="_blank" rel="noopener">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener">An overview of HTTP&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 WebSocket Protocol</title><link>/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/</link><pubDate>Sat, 06 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/</guid><description>&lt;h2 id="websocket-握手">WebSocket 握手&lt;/h2>
&lt;p>WebSocket 为第 7 层应用层协议，建立连接的握手流程依赖于 4 层 TCP，由于 WebSocket 通过利用 HTTP 发起握手，所以这里的握手更类似于一次对 HTTP 协议切换的请求。&lt;/p>
&lt;h3 id="client-请求">Client 请求&lt;/h3>
&lt;p>WebSocket 的请求和 HTTP 的格式是一致的, 每行会以 &lt;code>\r\n&lt;/code> 字符结尾，请求头的结束处也需要另起一行空白行：&lt;/p>
&lt;pre>&lt;code class="language-http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
&lt;/code>&lt;/pre>
&lt;p>最大的区别在于 WebSoeckt 的请求头会在 HTTP 的基础上带上 WS 协议切换标志位，告诉服务端将 HTTP 升级为 WebSocket。&lt;/p>
&lt;pre>&lt;code class="language-http">Upgrade: websocket
Connection: Upgrade
&lt;/code>&lt;/pre>
&lt;h3 id="server-响应">Server 响应&lt;/h3>
&lt;pre>&lt;code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc6455.pdf" target="_blank" rel="noopener">The WebSocket Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener">The WebSocket API (WebSockets)&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 TCP</title><link>/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/</link><pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc793.pdf" target="_blank" rel="noopener">TRANSMISSION CONTROL PROTOCOL): Semantics and Content&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol - Wikipedia&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 UDP</title><link>/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc768.pdf" target="_blank" rel="noopener">User Datagram Protocol&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc8085.pdf" target="_blank" rel="noopener">UDP Usage Guidelines&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>再谈 Swift Performance</title><link>/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/</link><pubDate>Sat, 26 Nov 2016 18:00:05 +0000</pubDate><guid>/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/</guid><description>&lt;p>随着 WWDC 2016 的离去，WWDC 2017 也已悄然竟接近，明年苹果将重回加州圣何塞 &lt;code>McEnery&lt;/code> 举办开发者大会，这个时候那些该展望的、还没展望的，也基本被讨论的差不多了，虽然在这个时间点来讨论 Swift Performance 虽然有些老生常谈，但也不失为一个好的话题。&lt;/p>
&lt;h2 id="class-与-struct-的取舍">&lt;code>class&lt;/code> 与 &lt;code>struct&lt;/code> 的取舍&lt;/h2>
&lt;p>什么情况下该用哪种 &lt;code>first class type&lt;/code> 来建立我们的 &lt;code>Model&lt;/code>，虽然各路英才心里自有图谱，但还是很有必要拉出来讨论一下。到底是用 &lt;code>class&lt;/code> 还是 &lt;code>struct&lt;/code>、用 &lt;code>value&lt;/code> 还是 &lt;code>reference&lt;/code> ，关键的约束点在于性能开销与多态的实现方式。&lt;/p>
&lt;h3 id="内存分配">内存分配&lt;/h3>
&lt;p>人尽皆知 &lt;code>heap&lt;/code> 比 &lt;code>stack&lt;/code> 更昂贵，&lt;code>heap&lt;/code> 牺牲了性能以换取比 &lt;code>stack&lt;/code> 更自由的内存管理，&lt;code>stack&lt;/code> 牺牲了复杂的数据结构来获取和 &lt;code>Int&lt;/code> 赋值一样快的 allocation。&lt;/p>
&lt;p>&lt;code>heap&lt;/code> 之所以昂贵、性能开销大，是因为开辟内存时需要考虑到多线程申请同一块内存 &lt;code>block&lt;/code> 而产生的竞争问题，因此首先需要加锁来达到 Thread Safety，然后，需要去找到未被使用使用的内存并申请初始化，用完了之后还得还回去将其 deallocate，而我们能得到的好处则是更加动态的内存生命周期。并且不像 C++，Swift 只能在堆上初始化 &lt;code>class&lt;/code>，对于 &lt;code>class&lt;/code> 选型的取舍显得尤其重要。&lt;/p>
&lt;p>反观 &lt;code>stack&lt;/code>，之所以其性能好是因为其开辟内存仅仅依赖于 &lt;code>ESP&lt;/code> 的上下移动，以典型自底向上的栈结构为例，一次函数调用所需要的 stack allocate 仅仅需要上移 &lt;code>ESP&lt;/code>，而当函数体结束时再把 &lt;code>ESP&lt;/code> 指回入栈之前的位置，上段内存自然就 deallocate 了。每个线程有自己的 &lt;code>stack&lt;/code>，不要考虑多线程加锁，也不需要考虑下一块内存是否可用。但限制在于，当执行一次完整的 &lt;code>call stack&lt;/code>，&lt;code>EBP&lt;/code> 的位置是固定的，意味着可以使用内存就这点，所以在栈上能做的事就被大大的限制，否则就等着 Overflow。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var serial: Int
}
let car = Car(serial: 123456)
// Fake car, have a fake serial, which is equal to car.serial
let fakeCar = aCar
// do sth with car, fakeCar
&lt;/code>&lt;/pre>
&lt;p>这样一段代码在 &lt;code>stack&lt;/code> 上仅仅用了 2 个字的大小，用于存储两个 &lt;code>car&lt;/code> 的 &lt;code>serial&lt;/code>。就轻量级，开销低这些特点来说，在工程中用 &lt;code>struct&lt;/code> 来建模看上去是挺美滋滋的，但抛开多态单就性能来说，是否意味着 &lt;code>struct&lt;/code> 总是能成为 &lt;code>Modeling&lt;/code> 的首选？答案是否定的，当 &lt;code>struct&lt;/code> 遇见 &lt;code>ARC&lt;/code> 时，她就变得并不那么轻量级了。&lt;/p>
&lt;h3 id="arc">&lt;code>ARC&lt;/code>&lt;/h3>
&lt;p>Swift 对于 &lt;code>heap&lt;/code> 上实例的内存管理，采用的机制依旧是 &lt;code>ARC&lt;/code>。&lt;/p>
&lt;p>ARC 的在性能上的开销主要是在 &lt;code>swift_retain&lt;/code> &amp;amp; &lt;code>swift_release&lt;/code> 所产生的多次 &lt;code>indirection&lt;/code> 以及多线程的加锁保护。对于 &lt;code>trivial&lt;/code> 的 &lt;code>struct&lt;/code> 来说因为不涉及 &lt;code>ARC&lt;/code>，因此没有影响。但当 &lt;code>struct&lt;/code> 本身如果包含了需要 &lt;code>ARC&lt;/code> 的实例时，他就变得不那么高效了。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var name: String
var model: String
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
print(myCar.name)
&lt;/code>&lt;/pre>
&lt;p>就 &lt;code>Car&lt;/code> 来说，&lt;code>name&lt;/code> 和 &lt;code>model&lt;/code> 虽然是 &lt;code>String&lt;/code>， 是一个 &lt;code>struct&lt;/code>，但是 &lt;code>String&lt;/code> 的 &lt;code>underlying buffer storage&lt;/code> 是开辟在堆上的，需要和 &lt;code>Class&lt;/code> 一样的作 &lt;code>retain count&lt;/code>，所以会产生如下所示代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var name: String
var model: String
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
print(myCar.name)
swift_retain(myCar.name._storage)
swift_retain(myCar.model._storage)
swift_release(myCar.name._storage)
swift_release(myCar.model._storage)
swift_release(newCar.name._storage)
swift_release(newCar.model._storage)
&lt;/code>&lt;/pre>
&lt;p>过多的 &lt;code>retain&lt;/code> &amp;amp; &lt;code>release&lt;/code> 带来性能开销是我们不想看到的，而如果我们采用 &lt;code>class&lt;/code> 来实现则展开成如下形式。&lt;/p>
&lt;pre>&lt;code class="language-swift">class Car {
var name: String
var model: String
init(name: String, model: String) {
self.name = name
self.model = model
}
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
swift_retain(myCar)
print(myCar.name)
swift_retain(myCar)
// ... do sth
swift_release(myCar)
swift_release(newCar)
&lt;/code>&lt;/pre>
&lt;p>在实际的过程中，&lt;code>Model&lt;/code> 显然不会这么简单，一个对象上有 10 几 20 个需要的 &lt;code>ARC&lt;/code> 的 &lt;code>property&lt;/code> 也不是不可能的，这时候谨慎使用 &lt;code>struct&lt;/code> 是我们需要注意的雷区。&lt;/p>
&lt;p>一个好的实践是多用 &lt;code>built-in&lt;/code> 的 &lt;code>type&lt;/code> 和结构来构建模型，比如 &lt;code>Car.model&lt;/code>，作为一个 &lt;code>String&lt;/code>，它其实没有很好的约束 &lt;code>Car.model&lt;/code> 所想表达的内容，它可以是任何字符串例如 &lt;code>Car.model = &amp;quot;foo&amp;quot;&lt;/code>，这是一个非常差的设计。因此如下所示，在这里我们可以采用 &lt;code>enum&lt;/code> 来对 &lt;code>model&lt;/code> 做约束。&lt;/p>
&lt;pre>&lt;code class="language-swift">extension Car {
enum Model {
case s
case x
}
}
struct Car {
var name: String
var model: Car.Model
}
&lt;/code>&lt;/pre>
&lt;p>虽然是一个很小的优化点，但结果即提高了语义的清晰度，又减少了不必要的开销，可谓一石双鸟。&lt;/p>
&lt;h2 id="多态">多态&lt;/h2>
&lt;p>&lt;code>Dyanmic Dispatch&lt;/code> 作为类多态实现的基础之一，也是讨论了比较多的话题，对于 &lt;code>class&lt;/code> 来说，编译器会给其添加额外的 &lt;code>field&lt;/code> 来储存 &lt;code>Type&lt;/code> 的信息，&lt;code>runtime&lt;/code> 通过 &lt;code>Type&lt;/code> 的 &lt;code>v-table&lt;/code> 来找到对应的方法，具体关于 &lt;code>Dynamic Dispatch&lt;/code> 的讨论可见之前的 &lt;a href="../whole-module-optimizations/">Whole Module Optimization 分析&lt;/a>，这里就不再赘述。&lt;/p>
&lt;p>回到 &lt;code>struct&lt;/code>，如果我们需要在 &lt;code>struct&lt;/code> 上实现多态，那就得依靠 &lt;code>protocol&lt;/code> 来实现。&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Turboable {
func turbo()
}
func turbo(_ stuffs: [Turboable]) {
stuffs.forEach {
$0.turbo()
}
}
struct Car {
var name: String
}
extension Car: Turboable {
func turbo() {
print(&amp;quot;turbo Car&amp;quot;)
}
}
struct Jet {
var name: String
}
extension Jet: Turboable {
func turbo() {
print(&amp;quot;turbo Jet&amp;quot;)
}
}
struct Tractor {
var name: String
var serail: Int
}
extension Tractor: Turboable {
func turbo() {
print(&amp;quot;turbo Tractor&amp;quot;)
}
}
let myStuffs: [Turboable] = [
Jet(name: &amp;quot;MiG-25&amp;quot;),
Car(name: &amp;quot;Chevrolet&amp;quot;),
Tractor(name: &amp;quot;Mercedes-Benz&amp;quot;,serial: 1)
]
turbo(myStuffs)
&lt;/code>&lt;/pre>
&lt;p>这是一段很常见的 &lt;code>Protocol Oriented Programming&lt;/code>，实际上这并不是没有额外性能开销的。和 &lt;code>Class&lt;/code> 不一样，通过 &lt;code>protocol&lt;/code> 实现的多态是通过 &lt;code>Protocol Witness Table&lt;/code> 来做 &lt;code>Dispatch&lt;/code>，每一个实现了 &lt;code>Turboable&lt;/code> 的类型，编译器都会生成一份 &lt;code>PWT&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct JetPWT {
func turbo(_ jet: Jet) {
jet.turbo()
}
}
struct CarPWT {
func turbo(_ car: Car) {
car.turbo()
}
}
struct TractorPWT {
func turbo(_ tractor: Tractor) {
tractor.turbo()
}
}
&lt;/code>&lt;/pre>
&lt;p>同时对于 &lt;code>Array&lt;/code>，底层的 &lt;code>buffer&lt;/code> 显然更喜欢以固定的大小去连续的存储元素，而不同的 &lt;code>type&lt;/code> 却有着不同的内存布局，因此 Swift 使用了 &lt;code>Existential Containner&lt;/code> 去存储元素，这样一个容器提供了个三个字大小的 &lt;code>value Buffer&lt;/code> 用于存储元素。&lt;/p>
&lt;p>但如果元素的内存布局过大导致 &lt;code>value Buffer&lt;/code> 放不下，例如三个字对于 &lt;code>struct Jet&lt;/code> 足够大，但对于 &lt;code>struct Tractor&lt;/code>，因为 &lt;code>String&lt;/code>.&lt;code>size&lt;/code> + &lt;code>Int&lt;/code>.&lt;code>size&lt;/code> &amp;gt; 3 使得它无法存放在只有三个字大小的 &lt;code>buffer&lt;/code> 中。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 24 bytes, 3 word
let jetSize = MemoryLayout&amp;lt;Jet&amp;gt;.size
// 32 bytes, 4 words
let tractorSize = MemoryLayout&amp;lt;Tractor&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>因此 &lt;code>Existential Containner&lt;/code> 会在堆上开辟空间用来拷贝存储一份 &lt;code>Tractor&lt;/code>，同时将指针存放在 &lt;code>value Buffer&lt;/code> 中。&lt;/p>
&lt;p>所以调用 &lt;code>func turbo(_ stuffs: [Turboable])&lt;/code> 实际上绝大部分的性能开销都花费在对结构体进行内存分配上。&lt;/p>
&lt;p>同时，谈及了内存操作，不同的 &lt;code>type&lt;/code> 对应的内存布局是不同的，&lt;code>Existential Containner&lt;/code> 需要额外信息才能为这些 &lt;code>type&lt;/code> 做堆内存初始化、拷贝、释放，因此 Swift 引入了 &lt;code>Value Witness Table&lt;/code> 来管理 &lt;code>value type&lt;/code> 在堆上的生命周期。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct JetVWT {
// 在堆上初始化一块用于存放 Jet 的内存，并把地址赋给 Existential Containner
func allocate()
// 把 stack Jet 的内存 copy 到 heap 上
func copy()
// 用于 class type 引用计数递减
func destruct()
// 释放堆内存
func deallocate()
}
struct CarVWT {
...
}
struct TractorVWT {
...
}
&lt;/code>&lt;/pre>
&lt;p>因此 &lt;code>Existential Containner&lt;/code> 还需要额外的两个字的空间用来存放 &lt;code>PWT&lt;/code> 和 &lt;code>VWT&lt;/code> 的地址。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct ExistContTurboable {
var valueBuffer: (Int, Int, Int)
var vwt: ValueWitnessTable
var pwt: TurboableProtocolWitnessTable
}
&lt;/code>&lt;/pre>
&lt;p>通常来说 &lt;code>Existential Containner&lt;/code> 的大小是 5 个字。&lt;/p>
&lt;pre>&lt;code>// 40 bytes, 5 words
let turboableSize = MemoryLayout&amp;lt;Turboable&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>虽然官方没声明，但是多个 &lt;code>protocol&lt;/code> 的情况下一份 &lt;code>pwt&lt;/code> 应该是不够的。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 48 bytes, 6 words
let turboableSize = MemoryLayout&amp;lt;Turboable &amp;amp; CustomReflectable&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>所以多个 &lt;code>protocol&lt;/code> 的结构会是如下所示的布局。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct ExistContTurboableCustomReflectable {
var valueBuffer: (Int, Int, Int)
var vwt: ValueWitnessTable
var pwt: (TurboableProtocolWitnessTable, CustomReflectableWitnessTable)
}
&lt;/code>&lt;/pre>
&lt;p>以上整个流程实现了 &lt;code>protocol&lt;/code> 的 &lt;code>Dynamic Dispatch&lt;/code>，那么最终 &lt;code>func turbo(_ stuffs: [Turboable])&lt;/code> 会生成下文所示的伪代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">
func turbo(val: [ExistContTurboable]) {
val.forEach { element in
// on the heap
var local = ExistContTurboable()
let vwt = element.vwt
let pwt = element.pwt
local.vwt = vwt
local.pwt = pwt
// 拷贝 local var 至 valueBuffer 或者堆上的内存
vwt.allocateBufferAndCopyValue(&amp;amp;local, element)
// 获取到 valueBuffer 或者堆上的实例
pwt.turbo(vwt.projectBuffer(&amp;amp;local))
// 清理现场
vwt.destructAndDeallocateBuffer()
}
}
&lt;/code>&lt;/pre>
&lt;p>相比于 &lt;code>class&lt;/code>，通过 &lt;code>protocol&lt;/code> 实现的 &lt;code>Dynamic Dispatch&lt;/code> 所带来的性能下降根据数据大小的不同可能高达数倍，并且不仅仅是 &lt;code>protocol type&lt;/code>，也包括了 &lt;code>stdlib&lt;/code> 中的一些函数。&lt;/p>
&lt;pre>&lt;code class="language-swift">public func max&amp;lt;T&amp;gt;(_ x: T, _ y: T) -&amp;gt; T where T : Comparable
&lt;/code>&lt;/pre>
&lt;p>这是一个很典型的范型函数，编译器在优化 Scope 被限制的条件下，会保守的生成符合所有 case 的函数。&lt;/p>
&lt;pre>&lt;code class="language-swift">public func max&amp;lt;T&amp;gt;(_ x: T, _ y: T, _ pwt: TypePWT, _ vwt: TypeVWT) -&amp;gt; T where T : Comparable
&lt;/code>&lt;/pre>
&lt;p>同样用到了 &lt;code>PWT&lt;/code> 和 &lt;code>VWT&lt;/code>，函数体的内部也同样用 &lt;code>valueBuffer&lt;/code> 来存储数据，一样是 3 个字的大小（苹果估计和 G 胖有仇），唯一的区别是没用 &lt;code>Existential Container&lt;/code> 到，因为这个对于每次调用只有一种 &lt;code>type&lt;/code> 的参数是没有必要的。&lt;/p>
&lt;p>当然这种通过范型实现的 &lt;code>Static Polymorphism&lt;/code> 仍然是 &lt;code>Dynamic Dispathc&lt;/code> 虽然对性能开销有影响，但是通过 &lt;code>Generic Specialization&lt;/code> 可以使其达到 &lt;code>Static Dispathc&lt;/code>，同样之前的 &lt;a href="../whole-module-optimizations/">Whole Module Optimization 分析&lt;/a> 有提及，所以不再赘述。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
2017-07-14 Updated
&lt;/div>
&lt;/div>
&lt;p>在 WWDC 2017 上，苹果终于出手这个解决 &lt;code>valueBuffer&lt;/code> 的性能问题了，&lt;code>Unpredictable Performance Cliff&lt;/code>。苹果的方案是采用 &lt;code>COW Existential Buffers&lt;/code>，简单来说就是太大没法放进 &lt;code>valueBuffer&lt;/code> 的 value，苹果对其采用和类一样的 &lt;code>reference counting&lt;/code>，多个 &lt;code>Existential Container&lt;/code> 可以共享相同的 &lt;code>buffer&lt;/code> 直到这个 value 需要被修改才会被重新分配内存，以减少 &lt;code>heap allocation&lt;/code> 的次数，典型的 COW 机制。&lt;/p>
&lt;p>同样对于范型的 &lt;code>valueBuffer&lt;/code>，原来的 &lt;code>heap allocation&lt;/code> 被替换为 &lt;code>stack allocation&lt;/code>，规避了堆内存管理，这下可以更加肆无忌惮的使用范型和 &lt;code>protocol&lt;/code> 了。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>我们数据建模的方式小改动会对性能造成巨大的影响，所以在我们设计每一个代码环节时，我们都有这样思维，这段代码发生了什么、会产生怎么样的性能开销、内存是如何分配的。&lt;/p>
&lt;p>在工程中都应该根据实际场景仔细斟酌采取哪种机制来获取优雅的实现，并在此基础上对性能做优化，是需要 &lt;code>class&lt;/code> 的 OOP 特性，还是 &lt;code>struct&lt;/code> 的 value 特性，是需要 &lt;code>protocol&lt;/code> 的更加灵活的 &lt;code>Dynamic Polymorphism&lt;/code>，还是由范型带来的更加 &lt;code>static&lt;/code> 的 &lt;code>Static Polymorphism&lt;/code>。&lt;/p>
&lt;p>总之还是那句话，工欲善其事，必先利其器，了解你的编译器，这样才能让编译器更好的理解你。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2017/402/" target="_blank" rel="noopener">What&amp;rsquo;s New in Swift 4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://academy.realm.io/posts/goto-mike-ash-exploring-swift-memory-layout/" target="_blank" rel="noopener">Exploring Swift Memory Layout&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://academy.realm.io/posts/real-world-swift-performance/" target="_blank" rel="noopener">Real World Swift Performance&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Whole-Module Optimization 分析</title><link>/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/</link><pubDate>Thu, 14 Jul 2016 18:00:05 +0000</pubDate><guid>/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/</guid><description>&lt;p>Swift 自诞生以来，就标榜了 &lt;strong>Performance&lt;/strong>。WWDC 2015 上苹果为 Swift 2 引入的 Swift Compiler 特性 &lt;code>Whole-Module Optimization&lt;/code> 将其再一次拉上了 &lt;strong>Performance&lt;/strong> 的舞台，那么 &lt;code>WMO&lt;/code> 到底做了些什么？&lt;/p>
&lt;p>通常来说，Swift 文件是单独编译的，这样的编译模式不但可以充分发挥多核心的优势做到并行编译而且还能做到单文件维度的增量编译。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">stateDiagram-v2
File1.swift --&amp;gt; Compiler
Compiler --&amp;gt; File1.o
File2.swift --&amp;gt; Compiler
Compiler --&amp;gt; File2.o
File3.swift --&amp;gt; Compiler
Compiler --&amp;gt; File3.o
&lt;/code>&lt;/pre>
&lt;p>这很合情也和很合理，用 Apple 的话来说就是&lt;/p>
&lt;blockquote>
&lt;p>That&amp;rsquo;s &lt;strong>good&lt;/strong> 😀&lt;/p>
&lt;/blockquote>
&lt;p>然而这样会把 Optimizer 能获取到的上下文局限在单个文件内，那么显而易见的问题是，整个模块内的死函数、&lt;code>Dynamic Dispatch&lt;/code> 的 &lt;code>V-Table&lt;/code> 查询、泛型特例化等等都无法被很好的优化，所以精益求精的 Apple 认为，这还是不够 &lt;strong>good&lt;/strong>，因此引入了 &lt;code>Whole-Moudle Optimization&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">stateDiagram-v2
File1.swift --&amp;gt; Compiler
File2.swift --&amp;gt; Compiler
File3.swift --&amp;gt; Compiler
Compiler --&amp;gt; File.o
&lt;/code>&lt;/pre>
&lt;p>&lt;code>WMO&lt;/code> 将整个模块的内的 Swift 文件合并成一个，把颗粒度提升到整个模块，这样可以做到在 Build Source 阶段，Optimizer 只进行一次模块级别的优化，用 Apple 的话来说就是：&lt;/p>
&lt;blockquote>
&lt;p>Analyze everything at once, aggressive optimization, very &lt;strong>good&lt;/strong> 😀&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>WMO&lt;/code> 对于 Swift 所能带来的提升官方称有 2x ~ 5x，如此 &lt;strong>good&lt;/strong> 的性能提升使得从 Xcode 8 开始 WMO 就成为了默认标配，所以 &lt;code>WMO&lt;/code> 快在哪？&lt;/p>
&lt;h3 id="泛型特例化">泛型特例化&lt;/h3>
&lt;p>以 &lt;a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Algorithm.swift" target="_blank" rel="noopener">stdlib&lt;/a> 中的函数为例。&lt;/p>
&lt;pre>&lt;code>// File1.swift
@_inlineable
public func max&amp;lt;T : Comparable&amp;gt;(_ x: T, _ y: T) -&amp;gt; T {
// In case `x == y`, we pick `y`. See min(_:_:).
return y &amp;gt;= x ? y : x
}
&lt;/code>&lt;/pre>
&lt;p>由于是泛型，编译器无从知道 &lt;code>type T&lt;/code> 具体类型是 &lt;code>Int&lt;/code>、&lt;code>Double&lt;/code> 还是其它任何 &lt;code>Comparable&lt;/code> 的类型，所以编译器会去函数表里找类型匹配函数， 同时编译器也无从知道 &lt;code>type T&lt;/code> 是否需要为其 &lt;code>reference counting&lt;/code>(e.g &lt;code>class Foo: Comparable&lt;/code>)，所以为了应付所有可能的 &lt;code>type T&lt;/code> 情况下，编译器会保守的生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>// File1.swift
@_inlineable
func max&amp;lt;T : Comparable&amp;gt;(x: T, y: T, FTable: FunctionTable) -&amp;gt; T {
let xCopy = FTable.copy(x)
let yCopy = FTable.copy(y)
let ret = !FTable.lessThan(yCopy, xCopy) ? y : x
FTable.release(x)
FTable.release(y)
return ret
}
&lt;/code>&lt;/pre>
&lt;p>然而在 &lt;code>runtime&lt;/code> 时期，对于诸如 Int 这类的基本类型来说，编译器插入的 &lt;code>copy()&lt;/code>、&lt;code>release()&lt;/code> 是毫无意义却又是确实存在的，所以和 &lt;code>Template Specialization&lt;/code> 类似，Swift Compiler 引入了 &lt;code>Generic Specialization&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// File1.swift
func foo() {
let x: Int = ...
let y: Int = ...
let ret = max(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;p>在这样一个上下文内，&lt;code>Compiler&lt;/code> 能清楚的得知 &lt;code>type T = Int&lt;/code>，因此 &lt;code>max&amp;lt;T&amp;gt;&lt;/code> 会被拷贝并被特例化成 &lt;code>max&amp;lt;Int&amp;gt;&lt;/code>。&lt;/p>
&lt;pre>&lt;code>func max&amp;lt;Int&amp;gt;(x: Int, y: Int) -&amp;gt; Int {
return y &amp;lt; x ? x : y
}
&lt;/code>&lt;/pre>
&lt;p>然而问题是在如下的情况也是大部分工程中最常见的情况下，对于 File1.swift 来说 File2.Swift 在编译期是不可见的，&lt;code>Generic Specialization&lt;/code> 也因此失去了作用。&lt;/p>
&lt;pre>&lt;code>// Module Foo
// File1.swift
@_inlineable
public func max&amp;lt;T : Comparable&amp;gt;(_ x: T, _ y: T) -&amp;gt; T {
// In case `x == y`, we pick `y`. See min(_:_:).
return y &amp;gt;= x ? y : x
}
// File2.swift
func bar() {
let x: Int = ...
let y: Int = ...
let ret = max(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>It&amp;rsquo;s not &lt;strong>good&lt;/strong> 🙁.&lt;/p>
&lt;/blockquote>
&lt;p>就时候就能体现出 &lt;code>WMO&lt;/code> 的优势，颗粒度上升至模块之后，File1，File2 会被合并，所有 Source 处于同一上下文，因此编译器有足够的信息去优化生成成如下 high &lt;strong>perfromace&lt;/strong> 的代码。&lt;/p>
&lt;pre>&lt;code>// Module Foo
// Foo-Merged.swift
@_inlineable
public func max&amp;lt;Int&amp;gt;(_ x: Int, _ y: Int) -&amp;gt; Int {
return y &amp;gt;= x ? y : x
}
func bar() {
let x: Int = ...
let y: Int = ...
let ret = max&amp;lt;T&amp;gt;(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;h3 id="dynamic-dispatch">Dynamic Dispatch&lt;/h3>
&lt;p>假设有一个 &lt;code>class Car&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// Module A
// File1.Swift
class Car {
// should not override
var brand: String
func turboCharge()
// turboCharge implementation, called by turboCharge(), should not override
func turboChargeImpl()
}
// File1.swift
class Porsche: Car {
var model: String
override func turboCharge()
// 对于子类，任何继承于父类的非 private func、property 都是以 Dynamic Dispatch
// 的形式调用的，即使没有被 override
// assumed to be overridden by compiler
// func turboChargeImpl()
}
&lt;/code>&lt;/pre>
&lt;p>然后我们有个 &lt;code>class Driver&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// File2.swift
class Driver {
var name: String
func turbo(of car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
car.turboCharge()
}
}
&lt;/code>&lt;/pre>
&lt;p>那么对于 &lt;code>Driver.turbo&lt;/code> 编译器会生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a car: Car) {
let brandGetter = Car.brandGetter(car)
print(&amp;quot;Strat turbo of \(brandGetter(car))&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>由于局限于单文件 &lt;code>Scope&lt;/code>，编译器无从得知所给到类的层级信息，自然无法得知有哪些 &lt;code>property&lt;/code>，&lt;code>func&lt;/code> 是被 &lt;code>override&lt;/code>的，所以编译器必须插入间接运算以完成 &lt;code>Dynamic Dispatch&lt;/code>。对于不会被 &lt;code>override&lt;/code> 的 &lt;code>Car.brand&lt;/code>、&lt;code>Car.turboChargeImpl&lt;/code>，可以通过 &lt;code>final&lt;/code> 限制子类的 &lt;code>override&lt;/code> 或者通过 &lt;code>private&lt;/code> 限制子类的 &lt;code>Access Control&lt;/code> 来达到 &lt;code>Static Dispatch&lt;/code>。&lt;/p>
&lt;pre>&lt;code>class Car {
···
final var brand: String
private func turboChargeImpl()
}
&lt;/code>&lt;/pre>
&lt;p>于是编译器就会生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>回到 &lt;code>WMO&lt;/code>，在上文基础上，假设有这样一个情景。&lt;/p>
&lt;pre>&lt;code>// Module A
// File2.swift
class Driver {
···
func turbo(a porsche: Porsche) {
porsche.turbo()
}
···
}
&lt;/code>&lt;/pre>
&lt;p>这样一段代码会被改写成如下。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a porsche: Porsche) {
let turboCharge = Porsche.turboCharge(porsche)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>在 &lt;code>class Prosche&lt;/code> 没有任何 &lt;code>subclass&lt;/code> 的情况下，&lt;code>Dynamic Dispatch&lt;/code> 实际上是毫无意义的，因此 &lt;code>WMO&lt;/code> 又一次发挥了作用，把 Visibility 提升到整个模块之后 Compiler 能理解 &lt;code>Prosche&lt;/code> 的类层级、并且 &lt;code>Prosche&lt;/code> 没有子类，因此 &lt;code>func turbo(a porsche: Porsche)&lt;/code> 是完全 Static 的，所以代码最终会被改写成如下。&lt;/p>
&lt;pre>&lt;code>// Module A
// A-Merged.Swift
class Car {
final var brand: String
func turboCharge()
private func turboChargeImpl()
}
class Porsche: Car {
final var model: String
override func turboCharge()
}
class Driver {
func turbo(a car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
func turbo(a porsche: Porsche) {
porsche.turbo()
}
}
&lt;/code>&lt;/pre>
&lt;p>相比于 objc 的一切皆动态，Swift 在编译器能获得丰富的信息去避免 &lt;code>Dynamic Dispatch&lt;/code> 这也为什么 Swift 在 Object-Oriented Benchmark 上能秒杀 objc，可见一个设计优良的 &lt;code>class&lt;/code> 不仅在工程易维护性上带来许多方便，同时在性能上也能获得巨大的收益。&lt;/p>
&lt;h2 id="wmo-的适用范围">&lt;code>WMO&lt;/code> 的适用范围&lt;/h2>
&lt;p>但就如上文所说的，&lt;code>WMO&lt;/code> 下增量编译颗粒度上升至整个模块，意味着不管修改哪个文件，下一次 build 总是 Whole-Module build，大大增加了 build time，虽然 &lt;code>WMO&lt;/code> 带来的 clean build 时间缩短是可观的，但和 &lt;code>-Onone&lt;/code>、&lt;code>SFO&lt;/code> 下的增量编译相比并不在一个量级，所以这对于日常的开发是没有必要的，因此 &lt;code>WMO&lt;/code> 作为标配来说也仅仅是在 release build 的情况下，它并不是无敌的。&lt;/p>
&lt;p>&lt;img src="./wmo.png" alt="wmo">&lt;/p>
&lt;p>同时在开启了优化的情况下，&lt;code>LLDB&lt;/code> 也会表现的不正常&lt;/p>
&lt;pre>&lt;code>MyApp was compiled with optimization - stepping may behave oddly; variables may not be available.
&lt;/code>&lt;/pre>
&lt;p>所以，如果有无法避免的理由需要在 &lt;strong>Debug&lt;/strong> 情况下要用到 &lt;code>WMO&lt;/code>，那么&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Debug&lt;/strong> 下打开 &lt;code>WMO&lt;/code>，&lt;code>Other Swift Flags&lt;/code> 里添加 &lt;code>-Onone&lt;/code>&lt;/li>
&lt;li>&lt;strong>Debug&lt;/strong> 下关闭 &lt;code>WMO&lt;/code>，&lt;code>User-Defined&lt;/code> 里添加 &lt;code>SWIFT_WHOLE_MODULE_OPTIMIZATION&lt;/code> = &lt;code>YES&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>以上两种方式都可以把所有文件合并，且不做任何编译优化，减少了 Context 的分析，不但能够 Debug，而且相比于 &lt;code>Whole-Module Optimization&lt;/code> 还可以达到更快的编译速度。对于 CocoaPods 引入的 Swift framework，可以在 hook 里为每个 target 做配置。&lt;/p>
&lt;pre>&lt;code class="language-ruby">post_install do |installer|
installer.pods_project.targets.each do |target|
target.build_configurations.each do |config|
if config.name == 'Debug'
config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Owholemodule'
config.build_settings['OTHER_SWIFT_FLAGS'] = '-Onone $(inherited)'
end
end
end
end
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;code>WMO&lt;/code> 的情况下，配合良好的代码设计会给予整个工程带来不容忽视的收益，用 Apple 的话来说就是：&lt;/p>
&lt;blockquote>
&lt;p>All I need to do is to turn on Whole-Module Optimization. I don&amp;rsquo;t need to change code at all. By giving the compiler more information, by allowing the compiler to understand my class hierachy with more information, I was able to get this optimization for &lt;strong>free&lt;/strong> without any work on your part.&lt;/p>
&lt;/blockquote>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol start="0">
&lt;li>&lt;a href="https://swift.org/blog/whole-module-optimizations/" target="_blank" rel="noopener">Whole-Module Optimization in Swift 3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2015/409/" target="_blank" rel="noopener">Optimizing Swift Performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://developear.com/blog/2016/12/30/Speed-Swift-Compilation.html" target="_blank" rel="noopener">Speeding Up Compile Times of Swift Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.skilled.io/u/swiftsummit/swift-with-a-hundred-engineers" target="_blank" rel="noopener">Swift with a hundred engineers&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nondot.org/sabre/" target="_blank" rel="noopener">Chris Lattner&amp;rsquo;s Homepage&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Introduce Objective-C Evolution</title><link>/2016/06/25/introduce-objective-c-evolution/</link><pubDate>Sat, 25 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/25/introduce-objective-c-evolution/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>Swift 3.0 问世之际，随之而来的是 &lt;code>API&lt;/code> 的清晰语意、更加完备的泛型、更 Swift Style 的 C APIs 等等。这也意味着 Swift 未来霸主地位越来越难被撼动。回看 Objective-C，作为一门 1980s 诞生的语言，在 Swift 的持续迭代下，ObjC 越发失去生机，&lt;code>Type Inference&lt;/code> 的缺失、&lt;code>Dynamic Dispatch&lt;/code> 的性能开销、不安全的 &lt;code>runtime&lt;/code>，过度啰嗦的 API 设计，都使得其在各方面被 Swift 全面碾压，大概目前能谈得上优势的也只剩下强大的 &lt;code>runtime&lt;/code> 动态性和 C/C++ 混编了。&lt;/p>
&lt;p>今次回顾下 Objective-C，依稀能看出语言设计上的年代感，对于 Objective-C 来说，如果当初 Swift 没有出现的话，Objective-C 3.0 是否能如期问世？&lt;/p>
&lt;ul class="cta-group">
&lt;li>
&lt;a href="../objc-evolution-proposals" target="_blank" rel="noopener" class="btn btn-primary px-3 py-3">View &lt;strong>The Objective-C Programming Language Evolution&lt;/strong>&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h2 id="objective-c-evolution">Objective-C Evolution&lt;/h2>
&lt;h3 id="开端">开端&lt;/h3>
&lt;p>尽管 Swift 的语法与性能以其压倒性的优势凌驾于 ObjC 之上，但缺点和短板的也很明显：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从 Swift 1.0 到 2.3 再到目前的 3.0，Swift 的飞速发展有目共睹，但与此同时其不稳定的 ABI 也一直被诟病，开发者们戏称道 Swift 1.0/2.0/3.0 是三门语言，虽然并没有那么夸张，但其对于代码的冲击性是确确实实的，对于小型团队来说 Swift 的版本迁移可能就几天就解决了，然而对大型项目来说，这个变化是毁灭性的。同时 Swift 持续迭代中产生的 &lt;code>bug&lt;/code>、&lt;code>issue&lt;/code> 并不能被很快的解决，那么势必我们会偶然间为 Swift 的发展而踩坑。通常来说，这些迁移所带来的额外成本在快速迭代的开发环境下是不被允许的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Swift 表现和 C++ 在很多地方都十分相似，非常 static，这也意味着 Swift 在动态性上非常薄弱，stdlib 中的 &lt;code>Mirror&lt;/code> 相比于 ObjC 的 &lt;code>runtime&lt;/code>，简直就是小巫见大巫，再者 &lt;code>Foundation&lt;/code> 中的 &lt;code>KVC&lt;/code>、&lt;code>KVO&lt;/code> 在 Swift 中需要借助 &lt;code>NSObject&lt;/code> 和 &lt;code>dynamic&lt;/code> 来完成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于一些有历史包袱或者偏底层的框架来说，它们无法从 C/C++ 剥离，而对于 C++，Swift 则必须通过 C、ObjC 来作为桥梁，无形中增加了开发成本，同时 Swift 对于指针的支持特别是函数指针并不是那么的友好，虽然这也无可厚非，毕竟 Swift 强调 &lt;code>safe&lt;/code>，指针本身就是 &lt;code>unsafe&lt;/code> 的，但使用上总有那么些许的不流畅。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>虽然目前的 Swift 依然有不少缺点，但作为一个积极的 Swift 布道者来说，其仍然是我目前为止评价最高的一门语言，其强大而优雅的语法特性、涵盖了多种模式的编码环境、内存管理哲学、以及针对性能所做的优化是目前的 Objective-C 望成莫及的。&lt;/p>
&lt;div class="alert alert-info">
&lt;div>
了解更多
&lt;/div>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/">Swift 设计哲学&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;h3 id="共生">共生&lt;/h3>
&lt;p>事实上 Apple 为了让 Swift 和 Objective-C、Foundation 层面互相兼容，在 LLVM 上做了非常多的工作，同样在 Swift Native 层面也做了大量的 Cast 和 Bridge，以至于导致了好多 Bug，列举几个我遇到过的:&lt;/p>
&lt;ul>
&lt;li>NSError 的 &lt;code>overrelease&lt;/code>，出现在 NSError 和 Error 互相 Cast 的场景，主要挂在 &lt;code>tryDynamicCastNSErrorObjectToValue&lt;/code>，通过 Allocation 最终定位为 swift runtime 的 bug
&lt;ul>
&lt;li>&lt;a href="https://bugs.swift.org/browse/SR-9207" target="_blank" rel="noopener">SR-9207&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/62410980/crash-while-casting-object-in-swift" target="_blank" rel="noopener">Crash while casting object in swift&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>引入 Swift 的代价是巨大的，但带来的收益同样也很可观，客观来说 Objective-C 的地位已然被撼动，试问一句还能战多久？&lt;/p>
&lt;h3 id="理想">理想&lt;/h3>
&lt;p>Objective-C 最大优点在于非常动态，这同样也是其缺点。高度的动态性导致其类型的不安全，冗长的自描述语法导致编码时效率低下，和 C/C++ 高度兼容的多语言特性增加了编码方式的可能性，但也导致潜在要处理的编码场景变得更为复杂。&lt;/p>
&lt;p>汲取现代语言的特性，展望 Objective-C 3.0 可拓展的特性：&lt;/p>
&lt;ul>
&lt;li>类似 &lt;code>var&lt;/code> 和 &lt;code>let&lt;/code> 关键字，参考 Swift，既满足了类型推导，又满足了可变性控制&lt;/li>
&lt;li>&lt;code>guard&lt;/code> 和 &lt;code>defer&lt;/code> 关键字，参考 Go 和 Swift 构建优雅 Control Flow 的必要元素&lt;/li>
&lt;li>&lt;code>aysnc&lt;/code> 和 &lt;code>await&lt;/code> 关键字和协程，参考 .NET&lt;/li>
&lt;li>支持泛型和模版，目前的 Objective-C 仅支持轻量型泛型&lt;/li>
&lt;li>以 &lt;code>.&lt;/code> 语法代替 &lt;code>[]&lt;/code>，事实上 Foundation 中大量的 &lt;code>getter&lt;/code> 都在逐渐适配成 @property，&lt;code>.&lt;/code> 语法的可用范围正在逐渐变多&lt;/li>
&lt;li>参数的空指针自描述，参考 Swift，在 Swift 中由 Optional 完成，Objective-C 中有 &lt;code>nullability&lt;/code> 关键字，不过主要服务于 Objective-C 到 Swift 的 API naming&lt;/li>
&lt;li>Protocol 的默认实现，参考 Swift&lt;/li>
&lt;li>Access Control&lt;/li>
&lt;/ul>
&lt;h3 id="evolution">Evolution&lt;/h3>
&lt;p>得益于 LLVM 以及出色的 Clang 前端，使得 Swift 以及一些现代语言的语法特性在 ObjC 中出现具有了可能性。拟参考 &lt;a href="https://github.com/apple/swift-evolution" target="_blank" rel="noopener">apple/swift-evolution&lt;/a> 的形式，基于对 Objective-C 原生特性拓展研究以及衍生特性的挖掘目的，建立 The Objective-C Programming Language Evolution 作为 Objective-C 的 CodeLab。&lt;/p>
&lt;h3 id="结语">结语&lt;/h3>
&lt;p>虽然目前 Swift 在苹果的推动下气势越来越猛、野心也越来越大，未来越来越多的语言特性、更完备的 &lt;code>stdlib&lt;/code> 以及更加稳定的 ABI 成为了苹果当下的主要目标。但包括苹果自己的框架在内，以及仍然有许多应用、优秀的开源库无法从 Objective-C/C++ 剥离。个人认为一些优秀并且已经被开源社区实现的特性是可以作为语言的标准特性加入到 Objective-C 的，就看 Apple 有没有这个意愿发布 Objective-C 3.0，毕竟 Apple 和 &lt;strong>
&lt;i class="fab fa-steam pr-1 fa-fw">&lt;/i>G 胖&lt;/strong>还是不一样的。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/post/tech-for-good/objc-evolution-proposals/">The Objective-C Programming Language Evolution&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div></description></item><item><title>Swift 设计哲学</title><link>/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link><pubDate>Sat, 25 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/forums/thread/16363" target="_blank" rel="noopener">Design decisions / goals / philosophy of Swift&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://forums.swift.org/t/language-design-philosophy-swift-vs-other-recent-languages/1338" target="_blank" rel="noopener">Language design philosophy, Swift vs Other recent languages&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>什么是数字签名【译注】</title><link>/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/</link><pubDate>Wed, 25 May 2016 00:00:00 +0000</pubDate><guid>/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>故事的主人翁是 Bob，他有三个朋友 Pat、Doug 和 Susan。Bob 经常和他们网上冲浪，因为他的消息是明文传输的，在传递过程可能被人截获偷窥，也可能被人截获然后又篡改了，更有可能别人伪装成 Bob 本人跟他的好友通信，为了规避消息泄漏以及被篡改的风险，整个通信过程中会引入非对称加密算法以及数字签名。正文部分会添加个人的译注作为补充介绍一些背景与看法，接下来我们来看看 Bob 是怎么用非对称加密与好友通信的。&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>主人翁 Bob 得到了两把钥匙。其中一把称为&lt;strong>公钥&lt;/strong>，另一把称为&lt;strong>私钥&lt;/strong>。&lt;/p>
&lt;div align="center">
&lt;div align="center" style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-meh pr-1 fa-fw">&lt;/i> &lt;/font>
&lt;/div>
&lt;div align="center" style="display:inline-block">
&lt;font style="font-size:1rem;color:#005cc5;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Public Key&lt;/font>&lt;br>
&lt;font style="font-size:1rem;color:#c5005c;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Private Key&lt;/font>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>非对称加密算法（RSA）是内容加密的一类算法，它有两个密钥，公钥与私钥：&lt;/p>
&lt;ul>
&lt;li>公开的、可以被所有人都可以获取的称之为公钥。&lt;/li>
&lt;li>只有持有者知道，其他任何人获取不到的称之为私钥。&lt;/li>
&lt;/ul>
&lt;p>通过公钥加密的内容，只能通过私钥解密，同样通过私钥加密的内容也只能用公钥解密，公钥和私钥只有称谓上不同，本质上没有任何区别，是很典型的用途决定命名。通常私钥加密公钥解密，我们称之为身份认证；公钥加密私钥解密，我们称之为加密。非对称加密算法的安全性很高，但因为计算量庞大，比较消耗性能。&lt;/p>
&lt;/blockquote>
&lt;p>Bob 的公钥可供任何需要的人使用，而他的私钥由他自己保密保存。密钥用于加密信息。将信息加密意味着“干扰”，只有拥有正确密钥的人才能将其解密并恢复成可读内容。Bob 两个密钥中的任意一个密钥都可以用来加密数据，并且使用另一个密钥解密数据。&lt;/p>
&lt;div align="center">
&lt;div style="display:inline-block">
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-tie pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Pat
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-nurse pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Susan
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-secret pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Doug
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-users pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Others
&lt;/div>
&lt;p>&lt;b>Bob's Co-workers&lt;/b>&lt;/p>
&lt;/div>
&lt;div style="display:inline-block">&amp;nbsp&amp;nbsp&amp;nbsp&lt;/div>
&lt;div align="left" style="display:inline-block">
&lt;font style="font-size:1rem;color:#005cc5;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Public Key&lt;/font>&lt;br>
&lt;p>Anyone can get Bob's Public Key, &lt;br>but Bob keeps his Private Key &lt;br>to himself.&lt;/p>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>这里可以理解成 Bob 把公钥直接复制成三份传输给了 Pat、Susan 以及 Doug。&lt;/p>
&lt;/blockquote>
&lt;p>Susan 可以使用 Bob 的公钥加密消息，Bob 获取到加密消息之后可以用他的私钥去解密消息。Bob 的每个同事都可以获取到 Susan 的加密消息，但在没有 Bob 的私钥的情况下，这些数据毫无价值。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(&amp;quot;Hey Bob, how about lunch &amp;lt;br/&amp;gt; at Taco Bell. I hear they &amp;lt;br/&amp;gt;have free refills!&amp;quot;)
a2(HNFmsEm6Un&amp;lt;br/&amp;gt;BejhhyCGKOK&amp;lt;br/&amp;gt;JUxhiygSBCEiC&amp;lt;br/&amp;gt;0QYIh/Hn3xgiK&amp;lt;br/&amp;gt;BcyLK1UcYiY&amp;lt;br/&amp;gt;lxx2lCFHDC/A)
b1(HNFmsEm6Un&amp;lt;br/&amp;gt;BejhhyCGKOK&amp;lt;br/&amp;gt;JUxhiygSBCEiC&amp;lt;br/&amp;gt;0QYIh/Hn3xgiK&amp;lt;br/&amp;gt;BcyLK1UcYiY&amp;lt;br/&amp;gt;lxx2lCFHDC/A)
b2(&amp;quot;Hey Bob, how about lunch &amp;lt;br/&amp;gt; at Taco Bell. I hear they &amp;lt;br/&amp;gt;have free refills!&amp;quot;)
subgraph Susan
a1--&amp;gt; |Encrypt with &amp;lt;br/&amp;gt;Public Key| a2
end
a2--&amp;gt; |Transfer| b1
subgraph Bob
b1--&amp;gt;|Decrypt with &amp;lt;br/&amp;gt;Private Key| b2
end
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>比如 Susan 要和 Bob 讨论去哪吃午饭，Susan 就可以先把自己的明文内容用 Bob 给她的公钥做一次加密，然后把加密的内容传送给 Bob，Bob 收到消息后，用他的私钥解密消息的内容。&lt;/p>
&lt;p>通常公钥加密，私钥解密的过程我们称之为加密，完整的加密过程为：&lt;/p>
&lt;ol>
&lt;li>发送方（Susan）通过可逆算法对内容 Message 用公钥进行加密，得到加密后的内容并发送&lt;/li>
&lt;li>接收方（Bob）接收 Message，并用私钥解密得到 Message，这个消息只有 Bob 的私钥能够解密&lt;/li>
&lt;/ol>
&lt;p>密码学范畴内，加密的目的是为了不让别人看到传送的内容，加密的策略是在特定加密算法以及双方约定的密钥的基础上进行的，比如使用非对称加密算法和用公钥加密；而解密的策略则需要相关的解密算法及约定的密钥，比如非对称加密算法和用私钥解密，整个加密的过程是可逆的。&lt;/p>
&lt;p>更多可以参考分类 &lt;a href="">IAS. Information Assurance and Security&lt;/a>, &lt;a href="">Cryptography&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在有了私钥和对应的软件后，Bob 可以在文档和其他数据上进行数字签名。数字签名可以理解为 Bob 在数据上打上了印记，这个印记对于 Bob 来说是独一无二的，很难伪造。此外，针对已经进行过签名的数据，数字签名能够保障对数据所做的任何篡改都可以被探知。&lt;/p>
&lt;p>为了给一个文档签名，Bob 的软件通过“散列化”将数据压缩成几行，这几行的数据被称为消息摘要，并且没有任何方法能够将消息摘要还原成原始数据。Bob 的软件用私钥加密生成的消息摘要，这个结果就是数字签名。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Message)
a2(Message Digest)
a3(Digital Signature)
a1--&amp;gt; |Hash| a2
a2--&amp;gt; |Encrypt with &amp;lt;br/&amp;gt;Private Key| a3
&lt;/code>&lt;/pre>
&lt;p>最后，Bob 的软件将数字签名附加到文档中，此时所有被散列化的数据都已经被签名。Bob 现在把文件传给了 Pat。&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>假设 Bob 收到 Pat 的消息后，决定给 Pat 回复。为了防止内容被篡改或者别人伪装成他的身份跟 Pat 通信，他决定先对消息的内容用散列算法做一次处理，得到一个哈希值，Bob 又用自己的私钥对哈希值做了一次加密得到一个数字签名，然后把签名和消息一起发送给 Pat。&lt;/p>
&lt;p>Bob 的内容为明文传输，这个过程是可以被人拦截，但是 Bob 最担心的是内容被人篡改或者有人冒充自己跟 Pat 通信，而不是内容被窥探。这里其实涉及到了身份认证的概念，Bob 要向 Pat 证明通信的对方是 Bob 本人，同时也需要确保自己的内容是没被篡改的。&lt;/p>
&lt;/blockquote>
&lt;p>首先，Pat 的软件用 Bob 的公钥解密签名，将其还原为消息摘要。如果成功了，那么它证明了在文件上签名的人是 Bob，因为只有 Bob 才有他的私钥。随后，Pat 的软件将文档数据散列化成消息摘要，如果 Pat 生成的消息摘要与解密 Bob 的签名得到的消息摘要相同，则 Pat 知道被签名数据没有被更改。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Message &amp;lt;br/&amp;gt;+&amp;lt;br/&amp;gt;Digital Signature)
a2(Message Digest)
a3(Message Digest)
a1--&amp;gt; |Hash| a2
a1--&amp;gt; |Decrypt with Public Key| a3
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>Pat 接收到了 Bob 的消息，首先用 Bob 给的公钥对签名作了解密处理，得到了哈希值 A，然后 Pat 用了同样的哈希算法对消息内容作了一次散列化处理，得到另外一个哈希值 B，对比 A 和 B 如果相同，那么可以确认内容是由 Bob 本人撰写并没有被篡改。&lt;/p>
&lt;p>通常私钥加密，公钥解密的过程我们称之为身份认证，完整的认证过程为：&lt;/p>
&lt;ol>
&lt;li>发送方（Bob）通过不可逆算法对内容 Message 进行处理（散列化也就是哈希），得到的结果值 Hash Bob&lt;/li>
&lt;li>发送方（Bob）用私钥加密 Hash Bob 得到结果值作为数字签名 Digital Signature 与 Message 一起发送&lt;/li>
&lt;li>接收方（Pat）接收 Message 和 Digital Signature，用公钥解密数字签名，如果成功得到结果 Hash Bob 说明是由 Bob 的私钥进行的签名&lt;/li>
&lt;li>接收方（Pat）同样对 Message 哈希处理得到 Hash Pat&lt;/li>
&lt;li>如果 Hash Pat 和 Hash Bot 一致，则说明内容没被篡改&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>Doug 是我们的一个心怀不满的员工，他想欺骗 Pat。Doug 十分确定 Pat 收到一条被签名过消息以及一个属于 Bob 的公钥。在 Pat 不知情的情况下，Doug 用 Bob 的名字创建了一对密钥，带有欺骗性伪装成 Bob 并发送了这个生成的公钥。Pat 在没有亲自收到 Bob 的公钥的情况下，如何确定 Bob 的公钥是真实的？&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>假设 Bob 是通过网络把公钥发送给他人的，如果 Doug 或者其他任何人截获了 Bob 给 Pat 的公钥。Doug 就开始伪装成 Bob 跟 Pat 无法确认对方是否是 Bob，所以需要引入第三方机构来验证 Bob 的真伪。&lt;/p>
&lt;/blockquote>
&lt;p>碰巧 Susan 在公司内的证书颁发中心工作，Susan 只需将 Bob 的公钥以及一些关于 Bob 的身份息进行数字签名，就可以为 Bob 创建数字证书。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Basic Info: &amp;lt;br/&amp;gt;Name &amp;lt;br/&amp;gt;Department &amp;lt;br/&amp;gt;Cubical Number&amp;lt;br/&amp;gt;Certificate Info: &amp;lt;br/&amp;gt;Expiration Date &amp;lt;br/&amp;gt;Serial Number&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;Bob's Public Key)
a2(Digital Certificate)
subgraph Bob
a1
end
a1--&amp;gt; |Sign Data| a2
&lt;/code>&lt;/pre>
&lt;p>现在，Bob 的同事们可以检查 Bob 的受信证书，以确保这个获取到的公钥的确属于 Bob。事实上除了 Susan 生成的证书签名，Bob 的公司没有人会接受其他任何签名。这使得 Susan 有权在私钥被盗或不再需要时撤销签名，甚至还有更广为接受的证书颁发机构来认证 Susan 的身份。现在假设 Bob 给 Pat 发送了一份签名文件，为了验证文档上的签名，Pat 的软件首先使用 Susan（证书颁发机构）的公钥来检查 Bob 证书上的签名，证书解密成功证明这个签名是用 Susan 的私钥创建的，表示是 Susan 创建了这个证书。证书的签名解密后，Pat 的软件可以检查 Bob 在证书颁发机构中是否信誉良好，以及所有与 Bob 身份相关的证书信息是否有被修改。随后，Pat 的软件从证书中提取 Bob 的公钥，并用它来检查 Bob 的签名。&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>Bob 发现了自己的公钥被 Doug 获取之后，意识到公钥传输这个过程是有漏洞的，可以被拦截并伪装。所以文中的 Susan 作为第三方的权威认证就起到了关键作用，现实中我们会通过以权威机构“证书中心” (Certificate Authority, CA) 做认证。证书中心会用自己的私钥对 Bob 的公钥和 Bob 身份相关的信息一次加密。这样 Bob 通过网络将带有签名的数字证书传输给 Pat 后，Pat 可以用 CA 的公钥解密证书的签名，这样就可以安全获取 Bob 的公钥。&lt;/p>
&lt;/blockquote>
&lt;p>如果 Bob 的公钥成功解密了签名，那么 Pat 大可安心，签名是使用 Bob 的私钥创建的，这是因为 Susan 已经认证了匹配的公钥。当然如果签名有效，那么我们知道 Doug 没有试图更改签名内容。虽然这些步骤听起来可能很复杂，但它们都由 Pat 的软件在幕后处理。要验证一个签名，Pat 只需单击它。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">What is a Digital Signature?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>快速枚举与迭代器</title><link>/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate><guid>/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>&lt;h2 id="swift-中的快速枚举">Swift 中的快速枚举&lt;/h2>
&lt;h3 id="swift-中的-forin">Swift 中的 &lt;code>for...in&lt;/code>&lt;/h3>
&lt;p>在 Swift 中所有实现了 &lt;code>Sequence&lt;/code> 的类型都能用 &lt;code>for...in&lt;/code> 来进行快速枚举，究其根本是因为 &lt;code>Sequence&lt;/code> 都实现了一个迭代器 &lt;code>func makeIterator() -&amp;gt; Iterator: IteratorProtocol&lt;/code>，我们实现一个支持随机枚举的类型。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 首先定义一个随机迭代器
struct RandomIterator&amp;lt;T&amp;gt;: IteratorProtocol {
typealias Element = T
private var elements: [Element]
private var index: Int = 0
init(_ elements: [Element]) {
self.elements = elements
}
mutating func next() -&amp;gt; T? {
guard elements.count &amp;gt; 0 else {
return nil
}
index = Int(arc4random_uniform(UInt32(elements.count)));
let element = elements[index]
defer {
elements.remove(at: index)
}
return element;
}
}
// 定义一个随机序列
struct RandomSequence&amp;lt;T&amp;gt;: Sequence {
typealias Element = T
private var elements: [Element]
init(_ elements: [Element]) {
self.elements = elements
}
typealias Iterator = RandomIterator&amp;lt;Element&amp;gt;
func makeIterator() -&amp;gt; Iterator {
return RandomIterator(elements)
}
}
&lt;/code>&lt;/pre>
&lt;p>输出为如下所示。&lt;/p>
&lt;pre>&lt;code class="language-swift">let seq = RandomSequence([1, 2, 3, 4, 5, 6, 7, 8, 9])
let loopBegin = { print(&amp;quot;========= loop =========&amp;quot;) }
loopBegin()
for (i, e) in seq.enumerated() {
print(&amp;quot;Elemet \(i) is \(e)&amp;quot;)
}
loopBegin()
for (i, e) in seq.enumerated() {
print(&amp;quot;Elemet \(i) is \(e)&amp;quot;)
}
// terminal
========= loop =========
Elemet 0 is 7
Elemet 1 is 8
Elemet 2 is 2
Elemet 3 is 4
Elemet 4 is 5
Elemet 5 is 1
Elemet 6 is 3
Elemet 7 is 9
Elemet 8 is 6
========= loop =========
Elemet 0 is 3
Elemet 1 is 6
Elemet 2 is 7
Elemet 3 is 4
Elemet 4 is 5
Elemet 5 is 9
Elemet 6 is 2
Elemet 7 is 1
Elemet 8 is 8
&lt;/code>&lt;/pre>
&lt;h3 id="swift-下的-forin-展开">Swift 下的 &lt;code>for...in&lt;/code> 展开&lt;/h3>
&lt;p>Swift 下 &lt;code>for...in&lt;/code> 最终会被展开成如下代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">var iterator = seq.makeIterator()
while let element = iterator.next() {
print(element)
}
&lt;/code>&lt;/pre>
&lt;h2 id="cocoa-中的-nsfastenumeration">Cocoa 中的 &lt;code>NSFastEnumeration&lt;/code>&lt;/h2>
&lt;p>谈到 Cocoa 的 &lt;code>for...in&lt;/code>，自然会联系到 &lt;code>@protocol NSFastEnumeration&lt;/code>，其只一个方法需要实现。&lt;/p>
&lt;pre>&lt;code class="language-objc">typedef struct {
unsigned long state;
id __unsafe_unretained _Nullable * _Nullable itemsPtr;
unsigned long * _Nullable mutationsPtr;
unsigned long extra[5];
} NSFastEnumerationState;
@protocol NSFastEnumeration
- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;
@end
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>@param state&lt;/code> 它保存了整个快速枚举过程所需要的 &lt;code>Context&lt;/code>
&lt;ul>
&lt;li>&lt;code>itemsPtr&lt;/code> 迭代元素的数组&lt;/li>
&lt;li>&lt;code>mutationsPtr&lt;/code> 一个标识符用于保证在枚举过程中的集合不被修改，这也是为什么在 &lt;code>for...in&lt;/code> Loop 中修改 &lt;code>Mutable Collection&lt;/code> 会导致 Crash 的原因&lt;/li>
&lt;li>&lt;code>state&lt;/code> 和 &lt;code>extra&lt;/code> 保留字段，用于给 &lt;code>Iterator&lt;/code> 保存上下文的信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>@param buffer&lt;/code> 缓冲区，用于存放当前需要被迭代的元素&lt;/li>
&lt;li>&lt;code>@param len&lt;/code> 缓冲区的长度&lt;/li>
&lt;li>&lt;code>@return&lt;/code> 当前迭代缓冲区的元素个数，如果是 0 表示迭代完成&lt;/li>
&lt;/ul>
&lt;h3 id="protocol-nsfastenumeration-与-forin">&lt;code>@protocol NSFastEnumeration&lt;/code> 与 &lt;code>for...in&lt;/code>&lt;/h3>
&lt;p>一段 &lt;code>for...in&lt;/code> Loop。&lt;/p>
&lt;pre>&lt;code class="language-objc">id&amp;lt;NSFastEnumeration&amp;gt; enumatable;
for (id element in enumatable) {
NSLog(@&amp;quot;%@&amp;quot;, element);
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>$ clang -rewrite-objc main.m&lt;/code> 之后如下所示：&lt;/p>
&lt;pre>&lt;code class="language-cpp">id/*&amp;lt;NSFastEnumeration&amp;gt;*/ enumatable;
{
id element;
// 初始化 NSFastEnumerationState Context
struct __objcFastEnumerationState enumState = { 0 };
// 开辟一块 size = 16 的缓冲区，用于给 Iterator 填充每次被迭代的元素
id __rw_items[16];
// 被迭代的集合
id l_collection = (id) enumatable;
// 首次迭代，向实现了 NSFastEnumeration 的该集合对象对象发送消息 &amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;
_WIN_NSUInteger limit =
((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
((id)l_collection,
sel_registerName(&amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;),
&amp;amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16);
// 检查 ret == 0 ?，如果为 0 表示迭代结束
if (limit) {
// 获取 Mutations flag，用于集合修改校验
unsigned long startMutations = *enumState.mutationsPtr;
do {
unsigned long counter = 0;
do {
// 保证集合不被修改，否则抛出异常
if (startMutations != *enumState.mutationsPtr) objc_enumerationMutation(l_collection);
// 获取枚举的元素
element = (id)enumState.itemsPtr[counter++];
// for...in 的 body
NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders__7_td3r8r7j44s2gh39zqkkhlym0000gn_T_main_b0cf04_mi_0, element);
} while (counter &amp;lt; limit);
// 当前元素遍历完毕，开始下一次迭代
} while (
(limit = ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
((id)l_collection,
sel_registerName(&amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;),
&amp;amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16))
);
element = ((id)0)
} else {
element = ((id)0);
}
}
&lt;/code>&lt;/pre>
&lt;p>简而言之，在完整的迭代流程中，每次会给 Iterator 传入一个缓冲区 &lt;code>buffer&lt;/code>，用于填充需要被迭代的元素，同时会传入一个 &lt;code>NSFastEnumerationState&lt;/code> 用来提供当前迭代状态的上下文，当该方法返回值 &lt;code>ret != 0&lt;/code>，表示迭代并没有结束，反之亦然。相比于 &lt;code>IteratorProtocol&lt;/code> 的单个返回元素，&lt;code>NSFastEnumeration&lt;/code> 在调用过程中是批量返回元素的，在 &lt;code>Cocoa&lt;/code> 中和 &lt;code>IteratorProtocol&lt;/code> 的表现更加类似的则是 &lt;code>NSEnumerator&lt;/code> 这个抽象类。&lt;/p>
&lt;pre>&lt;code class="language-objc">@interface NSEnumerator&amp;lt;ObjectType&amp;gt; : NSObject &amp;lt;NSFastEnumeration&amp;gt;
- (nullable ObjectType)nextObject;
@end
&lt;/code>&lt;/pre>
&lt;h3 id="实现一个基于-nsfastenumeration-的随机迭代器">实现一个基于 &lt;code>NSFastEnumeration&lt;/code> 的随机迭代器&lt;/h3>
&lt;pre>&lt;code class="language-objc">// main.mm
@interface RandomIterator: NSObject &amp;lt;NSFastEnumeration&amp;gt;
@property (nonatomic, assign) std::vector&amp;lt;id&amp;gt; elements;
@property (nonatomic, assign) int capicity;
- (id)initWithElements:(NSArray&amp;lt;id&amp;gt; *)elements;
@end
@implementation RandomIterator
- (id)initWithElements:(NSArray&amp;lt;NSObject *&amp;gt; *)elements {
if ((self = super.init)) {
for (auto e in elements) {
_elements.push_back(e);
}
_capicity = (int)_elements.size();
}
return self;
}
- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id _Nullable __unsafe_unretained [])buffer count:(NSUInteger)len {
auto countOfItemsAlreadyEnumerated = state-&amp;gt;state;
// This is the initialization condition, so we'll do one-time setup here.
if (countOfItemsAlreadyEnumerated == 0) {
// state-&amp;gt;mutationsPtr MUST NOT be NULL and SHOULD NOT be set to self.
state-&amp;gt;mutationsPtr = &amp;amp;state-&amp;gt;extra[0];
}
auto count = 0;
if (countOfItemsAlreadyEnumerated &amp;lt; _elements.size()) {
state-&amp;gt;itemsPtr = buffer;
while(count &amp;lt; len) {
auto randomIndex = (int)arc4random() % MAX(1, (_capicity - 1 - countOfItemsAlreadyEnumerated));
buffer[countOfItemsAlreadyEnumerated++] = _elements[randomIndex];
count++;
if (_elements.size() == 1) {
break;
} else {
_elements.erase(_elements.begin() + randomIndex);
}
}
} else {
count = 0;
}
state-&amp;gt;state = countOfItemsAlreadyEnumerated;
return count;
}
@end
&lt;/code>&lt;/pre>
&lt;p>输出如下&lt;/p>
&lt;pre>&lt;code class="language-cpp">int main(int argc, const char * argv[]) {
auto elements = @[@1, @2, @3, @4, @5, @6, @7, @8, @9];
id&amp;lt;NSFastEnumeration&amp;gt; enumatable = [RandomIterator.alloc initWithElements: elements];
for (id element in enumatable) {
NSLog(@&amp;quot;%@&amp;quot;, element);
}
return 0;
}
// terminal
Iterator[30557:6346806] 3
Iterator[30557:6346806] 1
Iterator[30557:6346806] 7
Iterator[30557:6346806] 5
Iterator[30557:6346806] 6
Iterator[30557:6346806] 2
Iterator[30557:6346806] 8
Iterator[30557:6346806] 4
Iterator[30557:6346806] 9
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/library/content/samplecode/FastEnumerationSample/Introduction/Intro.html" target="_blank" rel="noopener">Enumeration Sample&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Clang Attributes 使用文档</title><link>/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</link><pubDate>Sat, 28 Nov 2015 15:44:16 +0000</pubDate><guid>/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</guid><description>&lt;div class="alert alert-note">
&lt;div>
Continually Updated
&lt;/div>
&lt;/div>
&lt;p>&lt;code>__attribute__&lt;/code> 最初作为 GNU C 的特性，为 C/C++、Objective-C/C++ 提供了编译器级别的标注，用来修饰一个变量、函数或类型，包括但不限于以下特性。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html" target="_blank" rel="noopener">Function Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html" target="_blank" rel="noopener">Variable Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html" target="_blank" rel="noopener">Type Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html" target="_blank" rel="noopener">Label Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html" target="_blank" rel="noopener">Enumerator Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Attributes.html" target="_blank" rel="noopener">Statement Attributes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>同样 Clang 也很好的兼容了 GGC 这一特性，并做了额外的扩展。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#calling-conventions" target="_blank" rel="noopener">Calling Conventions&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#nullability-attributes" target="_blank" rel="noopener">Nullability Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#amd-gpu-attributes" target="_blank" rel="noopener">AMD GPU Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#consumed-annotation-checking" target="_blank" rel="noopener">Consumed Annotation Checking&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#type-safety-checking" target="_blank" rel="noopener">Type Safety Checking&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#opencl-address-spaces" target="_blank" rel="noopener">OpenCL Address Spaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://clang.llvm.org/docs/AttributeReference.html#customizing-swift-import" target="_blank" rel="noopener">Customizing Swift Import&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>诸如优化、错误检查之类的机械化任务理应由编译器去完成，但常言道“工欲善其事，必先利其器”只有让编译器更加懂你，才能把编译器的性能、优化发挥到极致。&lt;/p>
&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">目录&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#variable-attributes">Variable Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#noescape">&lt;code>noescape&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#section-__declspecallocate">&lt;code>section, __declspec(allocate)&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#used">&lt;code>used&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#type-attributes">Type Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#objc_root_class">&lt;code>objc_root_class&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#function-attributes">Function Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#overloadable">&lt;code>overloadable&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#customizing-swift-import">Customizing Swift Import&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#swift_bridge">&lt;code>swift_bridge&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_bridged">&lt;code>swift_bridged&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_name">&lt;code>swift_name&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_newtype">&lt;code>swift_newtype&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#进一步了解">进一步了解&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="variable-attributes">Variable Attributes&lt;/h2>
&lt;h3 id="noescape">&lt;code>noescape&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>noescape&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::noescape&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::noescape&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="section-__declspecallocate">&lt;code>section, __declspec(allocate)&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>section&lt;/code>&lt;/td>
&lt;td>&lt;code>gnu::section&lt;/code>&lt;/td>
&lt;td>&lt;code>gnu::section&lt;/code>&lt;/td>
&lt;td>&lt;code>allocate&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>section&lt;/code> 特性使得我们能将指定的变量或者函数插入到指定 section 中，比如把一个字符串直接塞入数据段。&lt;/p>
&lt;pre>&lt;code class="language-c">char *string __attribute((section(&amp;quot;__DATA, Custom&amp;quot;))) = &amp;quot;I'm a pure string.&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="used">&lt;code>used&lt;/code>&lt;/h3>
&lt;p>&lt;code>__attribute((used))&lt;/code> 用来修饰变量或者函数。通常默认情况下，没有被引用的符号会被链接器优化去除。标注 &lt;code>used&lt;/code> 之后意味着即使符号没有被引用，也不会被连接器优化掉。&lt;/p>
&lt;h2 id="type-attributes">Type Attributes&lt;/h2>
&lt;h3 id="objc_root_class">&lt;code>objc_root_class&lt;/code>&lt;/h3>
&lt;p>在 &lt;code>Foundation&lt;/code> 中对应 &lt;code>OBJC_ROOT_CLASS&lt;/code>，&lt;code>__attribute__((objc_root_class))&lt;/code> 用于申明一个没有根类的 objc class，我们可以利用这个特性实现类似 &lt;code>name space&lt;/code> 的效果，使得 ObjC 变得更 Swift。&lt;/p>
&lt;pre>&lt;code class="language-objc">__attribute__((objc_root_class)) @interface NotificationName
@property (class, readonly) NSNotificationName NSApplicationDidFinishLaunching;
@end
@implementation NotificationName
+ (NSNotificationName)NSApplicationDidFinishLaunching {
return NSApplicationDidFinishLaunchingNotification;
}
@end
&lt;/code>&lt;/pre>
&lt;h2 id="function-attributes">Function Attributes&lt;/h2>
&lt;h3 id="overloadable">&lt;code>overloadable&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>overloadable&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::overloadable&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::overloadable&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Clang 为 C 引入了和 C++ 一样的 &lt;code>name mangling&lt;/code>，使用 &lt;code>overloadable&lt;/code> 对 C 函数进行 &lt;code>overload&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;math.h&amp;gt;
float __attribute__((overloadable)) tgsin(float x) {
return sinf(x);
}
double __attribute__((overloadable)) tgsin(double x) {
return sin(x);
}
long double __attribute__((overloadable)) tgsin(long double x) {
return sinl(x);
}
&lt;/code>&lt;/pre>
&lt;p>会得到类似于 &lt;code>_Z5tgsinf&lt;/code>、&lt;code>_Z5tgsind&lt;/code>、&lt;code>_Z5tgsine&lt;/code> 这三个符号，同样对于 ObjC Type。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
void __attribute__((overloadable)) detectTypeof(NSInteger i) {
fprintf(stdout, &amp;quot;%s\n&amp;quot;, @encode(typeof(i)));
}
void __attribute__((overloadable)) detectTypeof(CGFloat f) {
fprintf(stdout, &amp;quot;%s\n&amp;quot;, @encode(typeof(f)));
}
void __attribute__((overloadable)) detectTypeof(NSString *string) {
fprintf(stdout, &amp;quot;%s: NSString\n&amp;quot;, @encode(typeof(string)));
}
void __attribute__((overloadable)) detectTypeof(NSArray *array) {
fprintf(stdout, &amp;quot;%s: NSArray\n&amp;quot;, @encode(typeof(array)));
}
void __attribute__((overloadable)) detectTypeof(NSObject *object) {
fprintf(stdout, &amp;quot;%s: NSObject\n&amp;quot;, @encode(typeof(object)));
}
int main(int argc, const char * argv[]) {
detectTypeof((NSInteger)1);
detectTypeof(1.0);
detectTypeof(@&amp;quot;Hello&amp;quot;);
detectTypeof(@[@(1)]);
detectTypeof(NSObject.new);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>运行结果如下所示。&lt;/p>
&lt;pre>&lt;code class="language-bash">q
d
@: NSString
@: NSArray
@: NSObject
&lt;/code>&lt;/pre>
&lt;h2 id="customizing-swift-import">Customizing Swift Import&lt;/h2>
&lt;h3 id="swift_bridge">&lt;code>swift_bridge&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_bridge&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>swift_bridge&lt;/code> 用于将 ObjC 的声明和 Swift 类型进行 Bridge，为 Swift Interoperability 的体现，更多可以参考 &lt;a href="https://developer.apple.com/videos/play/wwdc2015/401/" target="_blank" rel="noopener">WWDC&lt;/a>。Swift 标准库中的相当一部分类型都有 Interoperability 特性，与 Cocoa 有一层隐式 bridge，比如 &lt;code>NSArray&lt;/code>、&lt;code>NSMutableArray&lt;/code> 和 &lt;code>Swift.Array&lt;/code>。&lt;/p>
&lt;p>下方例子中，ObjC 类 &lt;code>DerivatedObjCClass&lt;/code> 被 bridge 到 Swift 中的 &lt;code>DerivatedClass&lt;/code>。&lt;/p>
&lt;pre>&lt;code>__attribute__((objc_root_class))
@interface BaseClass
- (instancetype)init;
@end
__attribute__((__swift_bridge__(&amp;quot;DerivatedClass&amp;quot;)))
@interface DerivatedObjCClass: BaseClass
@end
&lt;/code>&lt;/pre>
&lt;p>更多相关内容可以参考 LLVM 的 Phab Review D87532 &lt;a href="https://reviews.llvm.org/D87532" target="_blank" rel="noopener">Sema: add support for &lt;code>__attribute__((__swift_bridge__))&lt;/code>&lt;/a> 以及 swift 的 &lt;a href="https://github.com/apple/swift/blob/41d5e57b5586fccd4ba3823e8ac4690b7b30ec59/lib/ClangImporter/ImportType.cpp#L944" target="_blank" rel="noopener">ClangImporter&lt;/a>。&lt;/p>
&lt;h3 id="swift_bridged">&lt;code>swift_bridged&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_bridged&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>CF_SWIFT_BRIDGED_TYPEDEF&lt;/code>，配合 &lt;code>swift_bridge&lt;/code> 使用，用于被 &lt;code>swift_bridge&lt;/code> 描述的类型的 &lt;code>typedef&lt;/code> 类型。以 &lt;code>NSString&lt;/code> -&amp;gt; &lt;code>Swift.String&lt;/code> 为例，在 ObjC 中有如下声明：&lt;/p>
&lt;pre>&lt;code class="language-objc">@interface NSString;
typedef NSString *AliasedString __attribute__((__swift_bridged_typedef__));
extern void foo(AliasedString _Nonnull str);
&lt;/code>&lt;/pre>
&lt;p>在 Swift 中会被 Bridge 为：&lt;/p>
&lt;pre>&lt;code class="language-swift">func foo(_ str: String) -&amp;gt; Void
&lt;/code>&lt;/pre>
&lt;p>这个操作同样会由 Swift Compiler 直接完成，无需开发者手动声明。&lt;/p>
&lt;h3 id="swift_name">&lt;code>swift_name&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_name&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>CF_SWIFT_NAME&lt;/code>，&lt;code>swift_name&lt;/code> 为 C/ObjC 的声明提供了在 Swift 中符号名，默认情况会根据 Swift Compiler 的算法规则自动生成。&lt;/p>
&lt;pre>&lt;code>@interface NSData
- (instancetype)initWithData:(NSData *)data __attribute__((__swift_name__(&amp;quot;Data.init(_:)&amp;quot;)));
@end
void __attribute__((__swift_name__(&amp;quot;squareRoot()&amp;quot;))) sqrtf(float f);
&lt;/code>&lt;/pre>
&lt;h3 id="swift_newtype">&lt;code>swift_newtype&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_newtype&lt;/code> &lt;code>swift_wrapper&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>_CF_TYPED_EXTENSIBLE_ENUM&lt;/code>。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html" target="_blank" rel="noopener">Attributes in Clang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html" target="_blank" rel="noopener">Attribute Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html" target="_blank" rel="noopener">Enumerator Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.keil.com/support/man/docs/armcc/armcc_chr1359124965789.htm" target="_blank" rel="noopener">Compiler-specific Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nshipster.com/__attribute__" target="_blank" rel="noopener">NSHipster __ attribute __&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Xcode 插件整理</title><link>/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</link><pubDate>Sat, 03 Jan 2015 00:00:01 +0000</pubDate><guid>/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Xocde Plug-in 在 Xcode 8 之后已被禁用
&lt;/div>
&lt;/div>
&lt;h2 id="xcode-插件备忘清单">Xcode 插件备忘清单&lt;/h2>
&lt;h3 id="alcatrazhttpsgithubcomalcatrazalcatraz">&lt;a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="noopener">Alcatraz&lt;/a>&lt;/h3>
&lt;p>用于搜索、安装、管理 Xcode 插件的插件，持项目模版和 Xcode 字体主题，省去了手动 Clone 再编译的过程。&lt;/p>
&lt;h3 id="bbudebuggertuckawayhttpsgithubcomneonichubbudebuggertuckaway">&lt;a href="https://github.com/neonichu/BBUDebuggerTuckAway" target="_blank" rel="noopener">BBUDebuggerTuckAway&lt;/a>&lt;/h3>
&lt;p>当编辑代码的时候，能自动隐藏 &lt;code>Debugger&lt;/code>，尤其适用于边调试边修改的情况。&lt;/p>
&lt;h3 id="clangformat-xcodehttpsgithubcomtravisjefferyclangformat-xcode">&lt;a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="noopener">ClangFormat-Xcode&lt;/a>&lt;/h3>
&lt;p>使用 &lt;code>ClangFormat&lt;/code> 来格式化代码风格，支持 LLVM，Google，Chromium，Mozilla，WebKit，或者自定义设置，代码洁癖必备之一。使用自定义格式时 &lt;code>ClangFormat&lt;/code> 会从当前正在输入的文件的最近一级的父目录依次向上查找，直到找到用于确定代码风格的 &lt;code>.clang-format&lt;/code> 文件，因此通常放在工程文件根目录即可，文件内容使用 YAML 格式，具体风格配置可以参考 &lt;a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options&lt;/a> ，或者 &lt;a href="http://clangformat.com" target="_blank" rel="noopener">clangformat.com&lt;/a>。&lt;/p>
&lt;h3 id="cocoapods-xcode-pluginhttpsgithubcomkattralicocoapods-xcode-plugin">&lt;a href="https://github.com/kattrali/cocoapods-xcode-plugin" target="_blank" rel="noopener">cocoapods-xcode-plugin&lt;/a>&lt;/h3>
&lt;p>CocoaPods 的 Xcode 插件，省去命令行的步骤，直接在 Xcode 中对 CocoaPods 进行管理。&lt;/p>
&lt;h3 id="colorsense-for-xcodehttpsgithubcomomzcolorsense-for-xcode">&lt;a href="https://github.com/omz/ColorSense-for-Xcode" target="_blank" rel="noopener">ColorSense-for-Xcode&lt;/a>&lt;/h3>
&lt;p>高效插件，可视化的 &lt;code>UIColor/NSColor&lt;/code>。&lt;/p>
&lt;h3 id="fuzzyautocompletepluginhttpsgithubcomfuzzyautocompletefuzzyautocompleteplugin">&lt;a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="noopener">FuzzyAutocompletePlugin&lt;/a>&lt;/h3>
&lt;p>模糊匹配输入，比 Xcode 的前缀匹配要方便许多，主要通过 &lt;code>hook&lt;/code> 了 Xcode 自带的 &lt;code>IDEOpenQuicklyPattern&lt;/code> 实现。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
Xcode 8 自带了模糊匹配
&lt;/div>
&lt;/div>
&lt;h3 id="hostringsense-for-xcodehttpsgithubcomholtwickhostringsense-for-xcode">&lt;a href="https://github.com/holtwick/HOStringSense-for-Xcode" target="_blank" rel="noopener">HOStringSense-for-Xcode&lt;/a>&lt;/h3>
&lt;p>在 &lt;code>ColorSense-for-Xcode&lt;/code> 基础上进行的修改，可视化编辑多种文本，正则表达式、多行文本、内联 &lt;code>HTML&lt;/code> 等等。&lt;/p>
&lt;h3 id="ksimagenamed-xcodehttpsgithubcomksutherksimagenamed-xcode">&lt;a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="noopener">KSImageNamed-Xcode&lt;/a>&lt;/h3>
&lt;p>使用 &lt;code>[NSImage/UIImage imageNamed:]&lt;/code> 方法时，会给出所有工程文件中可选图片，并提图片预览。&lt;/p>
&lt;h3 id="scxcodeminimaphttpsgithubcomstefanceriuscxcodeminimap">&lt;a href="https://github.com/stefanceriu/SCXcodeMiniMap" target="_blank" rel="noopener">SCXcodeMiniMap&lt;/a>&lt;/h3>
&lt;p>为 Xcode 编辑器增加了一个 MiniMap，不过会挡住报错提示以及较长的的代码的末端，同时支持各种语法高亮。&lt;/p>
&lt;h3 id="scxcodeswitchexpanderhttpsgithubcomstefanceriuscxcodeswitchexpander">&lt;a href="https://github.com/stefanceriu/SCXcodeSwitchExpander" target="_blank" rel="noopener">SCXcodeSwitchExpander&lt;/a>&lt;/h3>
&lt;p>与 SCXcodeMiniMap 为同一作者，为 swith 语句自动补全所有的 case，只能适用于枚举类型。&lt;/p>
&lt;h3 id="vvdocumenter-xcodehttpsgithubcomonevcatvvdocumenter-xcode">&lt;a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">VVDocumenter-Xcode&lt;/a>&lt;/h3>
&lt;p>输入 &lt;code>///&lt;/code> 即可生成一个简易文档模版。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
在 Xcode 8 已被苹果集成
&lt;/div>
&lt;/div>
&lt;h3 id="xalignhttpsgithubcomqfishxalign">&lt;a href="https://github.com/qfish/XAlign" target="_blank" rel="noopener">XAlign&lt;/a>&lt;/h3>
&lt;p>用于对齐代码，可以根据 =、Marco、Property 进行对齐，强迫症和代码洁癖必备&lt;/p>
&lt;h3 id="xcodecolorshttpsgithubcomrobbiehansonxcodecolors">&lt;a href="https://github.com/robbiehanson/XcodeColors" target="_blank" rel="noopener">XcodeColors&lt;/a>&lt;/h3>
&lt;p>更改 NSLog 在 console 中输出的颜色，CocoaLumberjack 的依赖项&lt;/p>
&lt;h3 id="xtodohttpsgithubcomtraworxtodo">&lt;a href="https://github.com/trawor/XToDo" target="_blank" rel="noopener">XToDo&lt;/a>&lt;/h3>
&lt;p>允许使用 &lt;code>TODO&lt;/code>，&lt;code>FIXME&lt;/code>，&lt;code>???&lt;/code>，&lt;code>!!!&lt;/code> 这些符号来标记需要完成的工作，汇总显示。&lt;/p>
&lt;h3 id="xvimhttpsgithubcomxvimprojectxvim">&lt;a href="https://github.com/XVimProject/XVim" target="_blank" rel="noopener">XVim&lt;/a>&lt;/h3>
&lt;p>让熟悉使用 &lt;code>vim&lt;/code> 的开发者在 Xcode 中也能够有完整的 Vim 体验。&lt;/p></description></item><item><title>关于 NSURL +URLWithString: 返回 nil</title><link>/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/</link><pubDate>Wed, 03 Dec 2014 20:44:39 +0000</pubDate><guid>/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/</guid><description>&lt;p>当 url 字符串中含有特殊字符时，例如空格、汉字等，则必须对 url 字符串进行转义编码，否则 &lt;code>[NSURL URLWithString: urlString]&lt;/code> 将返回 &lt;code>nil&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat: @&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString:urlString];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>输出的 url 结果为。&lt;/p>
&lt;pre>&lt;code>21:07:11.784 test[8883:320995] (null)
&lt;/code>&lt;/pre>
&lt;p>对 &lt;code>urlString&lt;/code> 进行编码以及输出的 &lt;code>url&lt;/code> 结果。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat: @&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014
&lt;/code>&lt;/pre>
&lt;p>空格被转义为 &lt;code>UTF-8&lt;/code> 编码，例如汉字&amp;quot;的&amp;quot;的 &lt;code>UTF-8&lt;/code> 编码为 &lt;code>0xE7 0x9A 0x84&lt;/code>，percent encode 之后就是 &lt;code>%E7%9A%84&lt;/code>。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
2015-07-20 Updated
&lt;/div>
&lt;/div>
&lt;p>在 iOS 9.0 / OSX 10.11 之后 &lt;code>- stringByReplacingPercentEscapesUsingEncoding:&lt;/code> 就被废弃了，我们可以用 &lt;code>- stringByAddingPercentEncodingWithAllowedCharacters:&lt;/code> 代替，参数类型为 &lt;code>NSCharacterSet&lt;/code>。这个方法会把所有 Character Set 以外的字符进行 &lt;code>UTF-8 Percent Encoding&lt;/code>，支持 url 编码的 Character Set 有如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">+ URLFragmentAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%&amp;lt;&amp;gt;[\]^`{|}
+ URLHostAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/&amp;lt;&amp;gt;?@\^`{|}
+ URLPasswordAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/:&amp;lt;&amp;gt;?@[\]^`{|}
+ URLPathAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%;&amp;lt;&amp;gt;?[\]^`{|}
+ URLQueryAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%&amp;lt;&amp;gt;[\]^`{|}
+ URLUserAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/:&amp;lt;&amp;gt;?@[\]^`
&lt;/code>&lt;/pre>
&lt;p>自定义的 &lt;code>NSCharacterSet&lt;/code> 如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">[[NSCharacterSet characterSetWithCharactersInString:@&amp;quot; \&amp;quot;#%/:&amp;lt;&amp;gt;?@[\\]^`{|}&amp;quot;] invertedSet]
&lt;/code>&lt;/pre>
&lt;p>所以最终的编码以及控制台输出就如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat:@&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEncodingWithAllowedCharacters: NSCharacterSet.URLQueryAllowedCharacterSet]];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014
&lt;/code>&lt;/pre></description></item><item><title>git submodule 使用过程中遇到的问题</title><link>/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 04 Oct 2014 21:01:15 +0000</pubDate><guid>/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="添加-submodule">添加 submodule&lt;/h2>
&lt;p>为仓库添加 &lt;code>submodule&lt;/code> ⬇&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule add {repo-url} /local/repo/path
&lt;/code>&lt;/pre>
&lt;h2 id="git-clone-带有-submodule-的工程">git clone 带有 submodule 的工程&lt;/h2>
&lt;pre>&lt;code class="language-bash">$ git clone {repo-url}
&lt;/code>&lt;/pre>
&lt;p>完成之后，submodule 的代码并没有一起 clone 到本地，查看工作区可以发现 &lt;code>submodule&lt;/code> 的上下文内容。&lt;/p>
&lt;ul>
&lt;li>&lt;code>.gitmodules&lt;/code> 存在，里面包含了 submodule 的 url 和 &lt;code>{path/to/submodule-name}&lt;/code>&lt;/li>
&lt;li>&lt;code>{path/to/submodule-name}&lt;/code> 存在，但是文件夹是空的&lt;/li>
&lt;li>&lt;code>.git/config&lt;/code> 里没有submodule库的信息&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">$ git status
&lt;/code>&lt;/pre>
&lt;p>没有发现有更改的地方。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule status
&lt;/code>&lt;/pre>
&lt;p>可以看到 submodule &lt;code>hash&lt;/code>，前面带有 &lt;code>-&lt;/code> 表示 submodule 还没有 &lt;code>checkout&lt;/code>。&lt;/p>
&lt;h2 id="拉取-submodule">拉取 submodule&lt;/h2>
&lt;p>&lt;code>git submodule init&lt;/code> 利用工作区 &lt;code>.gitmodules&lt;/code> 的信息，在 &lt;code>.git/config&lt;/code> 里建立了 &lt;code>submodule&lt;/code> 索引 &lt;code>submodule.$name.url&lt;/code>，通过如下命令可以看到 &lt;code>submodule&lt;/code> 的索引。&lt;/p>
&lt;pre>&lt;code class="language-bash">cat .git/config
&lt;/code>&lt;/pre>
&lt;p>&lt;code>git submodule update&lt;/code> 默认走的是 &lt;code>git submodule update --checkout&lt;/code>，利用 &lt;code>superproject&lt;/code> 里记录的 &lt;code>hash&lt;/code> 来 &lt;code>checkout&lt;/code> submodule，这里就有个坑了。&lt;/p>
&lt;p>文档中是这么描述的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>checkout&lt;/strong>
the commit recorded in the superproject will be checked out in the submodule on a detached HEAD.
If &amp;ndash;force is specified, the submodule will be checked out (using git checkout &amp;ndash;force if appropriate), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>detached HEAD&lt;/code> 不属于任何一条 &lt;code>tree&lt;/code>，如果之后忘记 &lt;code>checkout&lt;/code> 到某条分支上的话，那之后所有 submodule 的 commit 都基于这个 &lt;code>detached HEAD&lt;/code>，那么我们就不得不使用 &lt;code>cherry-pick&lt;/code>，把基于 &lt;code>detached HEAD&lt;/code> 提交的 commit 提交 pick 到已有的分支上。&lt;/p>
&lt;p>并且当 &lt;code>submodule&lt;/code> 的嵌套层级太深的话，一层层的去 submodule 进行 &lt;code>init&lt;/code> 以及 &lt;code>update&lt;/code> 显然是不可取的，所以可以通过递归的方式去执行命令，这样能够做到 clone 主库以及递归拉取所有 submodule。&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone {path/to/repo-name} --recurse
&lt;/code>&lt;/pre>
&lt;h2 id="修改-submodule">修改 submodule&lt;/h2>
&lt;p>通常在实际项目中执行 &lt;code>submodule update&lt;/code> 的流程如下所示。&lt;/p>
&lt;ol>
&lt;li>当 repo-A 目录下的 repo-B 为 submodule，在对其进行修改之后，查看此时的工作区状态。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
(commit or discard the untracked or modified content in submodules)
modified: repo-B (modified content, untracked content)
$ git diff
diff --git a/submodules/repo-B b/submodules/repo-B
--- a/submodules/repo-B
+++ b/submodules/repo-B
@@ -1 +1 @@
-Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e
+Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e-dirty
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>发现 submodule 是 modified 并且工作目录 dirty，执行 submodule 提交修改。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ cd submodules/repo-B
$ git stage *
$ git commit -am 'Update content'
$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
(use &amp;quot;git push&amp;quot; to publish your local commits)
nothing to commit, working directory clean
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>回到主项目，查看状态输出，显示 submodule 的 &lt;code>hash&lt;/code> 已更新。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
modified: repo-B (new commits)
$ git diff
diff --git a/submodules/repo-B b/submodules/repo-B
--- a/submodules/repo-B
+++ b/submodules/repo-B
@@ -1 +1 @@
-Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e
+Subproject commit db560723ded8d1a0839dc08fb1e4324b30545c05
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>主工程提交修改。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git stage *
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
modified: repo-B
$ git commit -am 'Update submodule'
&lt;/code>&lt;/pre>
&lt;h2 id="从远程库更新-submodule">从远程库更新 submodule&lt;/h2>
&lt;p>当远程库的提交里记录的 submodule hash 有更新时，拉取远程库后，我们需要 update 本地的 submodule。git submodule update 会比较主项目记录的 submodule hash 和 submodule 自身当前的 HEAD hash，git 会强制把 submodule 的 HEAD checkout 到 git 记录的 hash，因为是 checkout 所以 detached HEAD 的问题会再一次出现。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule update
Submodule path 'submodules/repo-B': checked out 'db560723ded8d1a0839dc08fb1e4324b30545c05'
$ cd submodules/repo-B
$ git log --decorate --all
commit 3b754aca54077269aedb328c6e738ab8a7ab3077 (master) # current submodule HEAD hash
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Sat Dec 5 22:26:21 2015 +0800
Modify _config.yml
commit db560723ded8d1a0839dc08fb1e4324b30545c05 (HEAD) # main project submodule hash
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Sat Dec 5 21:46:40 2015 +0800
Modify _config.yml, Add two image
commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e (origin/master, origin/HEAD)
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Tue Dec 1 20:06:31 2015 +0800
Modify _config.yml
$ git status
HEAD detached at db56072
$ git branch
* (HEAD detached at db56072)
master
&lt;/code>&lt;/pre>
&lt;p>要从根本上摆脱 &lt;code>detached HEAD&lt;/code> 的问题，使用 &lt;code>rebase&lt;/code>、&lt;code>merge&lt;/code> 是正确的方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git submodule update --rebase&lt;/code>
the current branch of the submodule will be rebased onto the commit recorded in the superproject.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git submodule update --merge&lt;/code>
the commit recorded in the superproject will be merged into the current branch in the submodule.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://git-scm.com/doc" target="_blank" rel="noopener">git Documentation&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>用 Hexo 搭建个人博客</title><link>/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Thu, 12 Jun 2014 00:00:00 +0000</pubDate><guid>/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>&lt;p>今次通过 Hexo 生成静态博客网站，所以配置服务器的流程可以省去，直接托管在 Github Pages 上即可，这也目前轻量级博客的趋势。&lt;/p>
&lt;h2 id="环境安装">环境安装&lt;/h2>
&lt;h3 id="node-环境安装">Node 环境安装&lt;/h3>
&lt;h4 id="安装-nvmhttpsgithubcomcreationixnvm">安装 &lt;a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM&lt;/a>&lt;/h4>
&lt;p>在终端中运行如下命令。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
&lt;/code>&lt;/pre>
&lt;h4 id="安装-nodejshttpsnodejsorgen">安装 &lt;a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js&lt;/a>&lt;/h4>
&lt;p>使用如下命令查找远程库版本。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ nvm ls-remote
&lt;/code>&lt;/pre>
&lt;p>找到合适的版本并安装。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ nvm install 5.1.0
&lt;/code>&lt;/pre>
&lt;h3 id="安装-hexohttpshexoio">安装 &lt;a href="https://hexo.io" target="_blank" rel="noopener">Hexo&lt;/a>&lt;/h3>
&lt;p>Hexo 有丰富的&lt;a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件&lt;/a>和&lt;a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题&lt;/a>，如果不能满足需求的话还可以&lt;a href="https://hexo.io/api/" target="_blank" rel="noopener">自己动手&lt;/a>，使用如下命令全局安装 &lt;code>hexo-cli&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm install hexo-cli -g
&lt;/code>&lt;/pre>
&lt;p>安装 Hexo 所需的依赖包。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm install hexo-renderer-ejs --save
$ npm install hexo-renderer-stylus --save
$ npm install hexo-renderer-marked --save
&lt;/code>&lt;/pre>
&lt;p>或者直接通过 &lt;code>package.json&lt;/code> 一步到位。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm intall
&lt;/code>&lt;/pre>
&lt;h2 id="添加文章-posts">添加文章 Posts&lt;/h2>
&lt;p>找个文件夹初始化 Blog 的工作目录。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd &amp;quot;/path/to/blog&amp;quot;
$ hexo init
&lt;/code>&lt;/pre>
&lt;p>生成一篇文章。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo new &amp;quot;用 Hexo 搭建个人博客&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>使用 &lt;code>vim&lt;/code> 或者其他 &lt;code>Markdown Editor&lt;/code> 编辑文章。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd source/_posts
$ vim 用-Hexo-搭建个人博客.md
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>附上 &lt;code>Markdown&lt;/code> &lt;a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">语法&lt;/a>&lt;/strong>。写完博文之后生成 &lt;code>html&lt;/code>、&lt;code>css&lt;/code>、&lt;code>.js&lt;/code> 等静态网页文件，生成之后的内容在博客根目录 &lt;code>public&lt;/code> 文件夹下，里面就是博客需要部署的内容。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo generate
&lt;/code>&lt;/pre>
&lt;p>启动本地 Hexo 服务器。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo server
INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
&lt;/code>&lt;/pre>
&lt;p>在浏览器内输入&lt;a href="http:localhost:4000/" target="_blank" rel="noopener">本地服务器地址&lt;/a>预览博客。&lt;/p>
&lt;h2 id="部署至-github">部署至 Github&lt;/h2>
&lt;p>部署到 Github 上用于 Github Pages 的 repo 有两种形式：&lt;/p>
&lt;ol>
&lt;li>主页级 repo，页面部署到 &lt;code>master&lt;/code> 分支下，访问 Github Pages 时使用 &lt;code>username.github.io&lt;/code>，常用于个人主页。&lt;/li>
&lt;li>项目级 repo，页面部署到 &lt;code>gh-pages&lt;/code> 分支，访问 Github Pages 时使用 &lt;code>username.github.io/repo-name&lt;/code>，常用于项目主页。&lt;/li>
&lt;/ol>
&lt;p>在 _config.yml 内配置完部署信息后 (&lt;code>deploy&lt;/code> 字段) 执行如下命令。&lt;/p>
&lt;pre>&lt;code>$ hexo clean
$ hexo generate
$ hexo deploy
&lt;/code>&lt;/pre>
&lt;p>或者使用如下命令。&lt;/p>
&lt;pre>&lt;code>$ hexo g
$ hexo d
&lt;/code>&lt;/pre>
&lt;p>完成部署至 Github，过个几分钟等 Github 更新完缓存再打开 &lt;code>{username}.github.io/{blog-repo}&lt;/code> 或者 &lt;code>{username}.github.io&lt;/code> 就能看到 Github Pages。&lt;/p>
&lt;h2 id="绑定域名">绑定域名&lt;/h2>
&lt;p>Github 使用一系列 &lt;strong>name-based&lt;/strong> 虚拟 &lt;code>WWW&lt;/code> server 部署所有静态博客的 wwwroot 目录。虚拟服务器的地址就是上文提及的 &lt;code>{username}.github.io&lt;/code> 和 &lt;code>{username}.github.io/{repo-name}&lt;/code>，因此将需要绑定的域名指向 Github 的服务器 &lt;a href="https://github.io">https://github.io&lt;/a>，把域名解析权下放到 Github。&lt;/p>
&lt;p>同时 Github 服务器需要知道如何解析域名，所以 Github Pages 用户需要将绑定的域名通过 wwwroot 目录下的 CNAME 文件告知 WWW server 域名 =&amp;gt; &lt;code>repo/branch&lt;/code> 的映射关系，所以在根目录 source 文件夹下建立一个 CNAME 文本文件，内容为绑定的域名。&lt;/p>
&lt;p>完成之后，输入命令查询下 dns 解析结果。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ dig blog.alchemistxxd.com
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.3-P1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.alchemistxxd.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 45658
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0
;; QUESTION SECTION:
;blog.alchemistxxd.com. IN A
;; ANSWER SECTION:
blog.alchemistxxd.com. 600 IN CNAME alchemistxxd.github.io.
alchemistxxd.github.io. 2816 IN CNAME github.map.fastly.net.
github.map.fastly.net. 142 IN A 103.245.222.133
;; Query time: 299 msec
;; SERVER: 222.44.10.48#53(222.44.10.48)
;; WHEN: Wed Dec 2 23:41:45 2015
;; MSG SIZE rcvd: 126
&lt;/code>&lt;/pre>
&lt;p>终わり&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hexo.io/" target="_blank" rel="noopener">Hexo.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm Docs&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>创篇号</title><link>/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/</link><pubDate>Wed, 11 Jun 2014 00:00:00 +0000</pubDate><guid>/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/</guid><description>&lt;p>在浮躁快餐文化的催化下，人逐渐变的懒散与缺乏耐性，在这样的环境下要想压抑住浮躁的内心、放平心态好好学习也成了一件非常不容易的事情。&lt;/p>
&lt;p>走马观花是很多人在学习过程中遇到的问题，在从外部获取各种信息时我们总想着尽可能多的去汲取知识，却忽略了对于知识的复习与运用，渐渐的就会丧失了自我思考的能力，并且根据 &lt;a href="https://en.wikipedia.org/wiki/Forgetting_curve" target="_blank" rel="noopener">Forgetting curve&lt;/a>，学过的东西如果不用也不整理那要不了多久就会忘的一干二净，所以知识点的沉淀与复习运用是很重要的。于是乎觉着学习的东西要有个地方来沉淀复盘下，一直想趁着有时间搭个博客来纪录下以后学习的历程，沉淀下有关技术学习以及生活的点滴。所以，从今天开始写博文，在学习之路上留下点技术印记。&lt;/p></description></item></channel></rss>