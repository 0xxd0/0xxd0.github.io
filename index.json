[{"authors":null,"categories":null,"content":"大家好！ 我目前在腾讯担任客户端工程师一职。目前主攻的领域有苹果平台开发、游戏引擎二次开发，在移动应用架构、Swift、Objective-C、移动应用性能优化等方面有较多的经验，同时我也是 Swift 编程语言的积极布道者。\n","date":1613989889,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1613989889,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"大家好！ 我目前在腾讯担任客户端工程师一职。目前主攻的领域有苹果平台开发、游戏引擎二次开发，在移动应用架构、Swift、Objective-C、移动应用性能优化等方面有较多的经验，同时我也是 Swift 编程语言的积极布道者。","tags":null,"title":"徐旭栋","type":"authors"},{"authors":["徐旭栋"],"categories":null,"content":"","date":1599609600,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1599609600,"objectID":"13b47ae38d4ad3f1176f2c88229ad9f6","permalink":"/post/investor/options-as-a-strategic-investment/","publishdate":"2020-09-09T00:00:00Z","relpermalink":"/post/investor/options-as-a-strategic-investment/","section":"post","summary":"Options as a Strategic Investment","tags":["Options","Implied Volatility"],"title":"期权投资策略","type":"book"},{"authors":["徐旭栋"],"categories":["Economics","Economics, Other"],"content":"   Game Theory  Course Number ECON 159\nAbout the Course This course is an introduction to game theory and strategic thinking. Ideas such as dominance, backward induction, Nash equilibrium, evolutionary stability, commitment, credibility, asymmetric information, adverse selection, and signaling are discussed and applied to games played in class and to examples drawn from economics, politics, the movies, and elsewhere. Course Structure This Yale College course, taught on campus twice per week for 75 minutes, was recorded for Open Yale Courses in Fall 2007.\nCourse Materials Download all course pages [zip - 10MB]\nLearn More  Game Theory.  ","date":1546338689,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1546338689,"objectID":"03322ea4822ff6e4426b7cef5a69c826","permalink":"/post/economics/game-theory/econ-159-game-theory/","publishdate":"2019-01-01T10:31:29Z","relpermalink":"/post/economics/game-theory/econ-159-game-theory/","section":"post","summary":"This course is an introduction to game theory and strategic thinking.","tags":["Game Theory"],"title":"ECON 159 Game Theory","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems"],"content":"关于 ","date":1510741889,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1510741889,"objectID":"469b08f5e694a2545217945c57e78aa3","permalink":"/post/tech-for-good/tsinghua-oscourse/","publishdate":"2017-11-15T10:31:29Z","relpermalink":"/post/tech-for-good/tsinghua-oscourse/","section":"post","summary":"关于 ","tags":["OS"],"title":"清华大学计算机系操作系统","type":"book"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"前言 传输层安全协议 Transport Layer Security Protocol 是一种通过数字签名确保数据完整性以及实现互相身份认证、使用加密确保私密性来实现客户端和服务器之间的安全通讯，其位于面向连接的网络层协议和应用层协议之间，是一种协议层。\n  TLS 的发展历史   Image Source: HOSTINGER  TLS 的前身为安全套接字层 Secure Socket Layer。SSL 由网景 Netscape 在 1994 年设计并与同期提出的 HTTPS 一起应用在网景浏览器上，当时主要为 HTTPS 提供 SSL 层的加密服务，目的是为保护整条 Web 通信传输的链路安全，提供了 Client 以及 Server 的身份认证防止中间人伪装；提供加密数据防止被窃取；保证传输过程中数据完整性不被中间人篡改。\n随后 SSL 被 ISOC 组织成员 IETF 标准化，于 1999 年公布 TLS 1.0 标准文件 RFC 2246，完整的时间线如下：\n Netscape 首席科学家 Taher Elgamal 设计开发了 SSL 1.0，但由于有安全问题从未发布。 1995 年，Netscape 设计并发布 SSL 2.0，由于有安全问题很快一年后被 SSL 3.0 替代，于 2011 年被弃用 RFC6176。 1996 年，Netscape 设计发布 SSL 3.0，其草案之后作为历史文献由 IETF 在 2011 年通过 RFC 6101 发表，于 2015 年被弃用 RFC 7568。 1999 年 IETF 将 SSL 进行标准化，发布 TLS 1.0 标准 RFC 2246。 2006 年 IETF 发布 TLS 1.1 标准 RFC 4346。 2008 年 IETF 发布 TLS 1.2 标准 RFC 5246。 2018 年 IETF 发布 TLS 1.3 标准 RFC 8446。  下文会统一使用 TLS 进行描述。\nTLS 的构成 TLS 具体由两层构成：\n TLS 记录协议 The TLS Record Protocol，建立在可靠的传输协议如 TCP 之上，为高层协议提供数据封装、压缩、加密等基本功能的支持，保证数据传输过程中的完整性和私密性，属于较低层的协议。 TLS 握手协议 The TLS Handshake Protocol，建立在 TLS 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。  TLS 协议的一大优势是与高层的应用层协议如 HTTP、SSH、Telnet 等无耦合，应用层协议能透明地运行在 TLS 之上，由 TLS 进行建立加密通道需要的协商和认证。应用层协议传送的数据在通过 TLS 协议层时都会被加密，从而保证通信的私密性。\n从上层的 TLS 握手流程作为切入点，先从数字签名的概念讲起。\n数字签名是什么 TLS 握手过程中会涉及到加密、解密与认证的概念，所以首先需要了解什么是数字签名。Bob 的故事可以很好的帮助理解数字签名，从以下这篇文章进一步了解。\n 徐旭栋  Wed, May 25, 2016   3 分钟阅读时长   CIP 11.07) Computer Science , 11.0701) Computer Science   IAS. Information Assurance and Security , Cryptography  什么是数字签名【译注】  用 Bob 的故事简单介绍数字签名\n   Original Post    TLS Handshaking Protocols 通过上文的 Bob 的故事，在对数字签名有了个基本的概念之后，进一步了解 TLS 握手的设计逻辑。TLS 握手是一个集加密、解密、认证等概念的建立连接过程。\nTLS 1.0 握手流程 sequenceDiagram autonumber participant Client participant Server rect rgb(191, 223, 255) Client-\u0026gt;\u0026gt;Server: ClientHello end rect rgb(200, 150, 255) note left of Server: Certificate*\u0026lt;br/\u0026gt;ServerKeyExchange*\u0026lt;br/\u0026gt;CertificateRequest*\u0026lt;br/\u0026gt; Server-\u0026gt;\u0026gt;Client: ServerHello end rect rgb(191, 223, 255) note right of Client: Certificate*\u0026lt;br/\u0026gt;ClientKeyExchange\u0026lt;br/\u0026gt;CertificateVerify*\u0026lt;br/\u0026gt;ChangeCipherSpec* Client-\u0026gt;\u0026gt;Server: Finished end rect rgb(200, 150, 255) note left of Server: ChangeCipherSpec Server-\u0026gt;\u0026gt;Client: Finished end  1. Client Hello 客户端向服务端发送 ClientHello 消息，客户端提供：\n 支持的协议版本 客户端生成的随机数 ClientHello.random 支持的压缩算法以及 支持加密算法  2. Server Hello 服务端收到客户端支持的协议版本、加密算法等信息后，向客户端发出回应：\n 发送 ServerHello，包含了指定的协议版本、加密方法、会话 ID，以及服务端生成的随机数 ServerHello.random。 向客户端发送 Certificate，服务端的证书链，其中包含证书支持 的域名、发行方和有效期等信息。 向客户端发送 ServerKeyExchange 消息，传递服务器公钥以及数字签名等信息。 向客户端发送 CertificateRequest 请求，可选步骤，用于验证客户端的证书。 发送 ServerHelloDone，通知客户端服务端所有的响应已完成。  3. Client Response 客户端收到服务端的信息后，首先会对服务器证书进行验证，检查服务器证书是否是可信机构颁布。随后对证书中的域名与实际域进行一致性校验、检验证书是否过期等，如果验证失败就会发出警告，询问是否还要继续通信。整个验证过程与《什么是签名》一文中 Bob 和 Pat 通信的验证原理是一致的，验证完成之后，客户端对服务端发出响应：\n 向服务端发送 ClientKeyExchange 消息，包含使用服务端公钥 RSA 加密的 Premaster Secret 消息。 向服务端发送 ChangeCipherSpec 消息，告知服务端后续数据启用约定的算法加密。 向服务端发送 Finished，其中包含加密后的之前所有的握手信息。  4. Server Response 服务端收到 ChangeCipherSpec 和 Finished 后：\n 向客户端发送 ChangeCipherSpec 消息，通知客户端后续数据启用约定的算法加密。 验证客户端的 Finished，向客户端发送 Finished 消息并完成 TLS 握手，其中包含加密后的所有握手的信息。  TLS 握手核心在于 Hello Message 阶段生成的两个随机值 ClientHello.random、ServerHello.random 以及 Premaster Secret 共三个随机信息。通常非对称加密的计算量是比较庞大的，所以对称加密才有了必要性。Premaster Secret 本身即随机数，配合 Hello Message 中的两个随机数，双方用经过协商后的加密算法通过 PRF（伪随机数函数）将三个随机信息生成一个对称密钥 Master Secret，之后就可以使用这个密钥对称加密消息防止中间人攻击和信息窃取。\nmaster_secret = PRF(pre_master_secret, \u0026quot;master secret\u0026quot;, ClientHello.random + ServerHello.random)  TLS 的证书是静态的，引入一种额外随机因素来保证协商出来的密钥随机性是很有必要的。使用 Premaster Secret 作为单纯的对称加密密钥是存在风险的，由于计算机的随机数是伪随机，TSL 协议不认为存在完全随机的随机数，为了让 Master Secret 不可被破解，不选择单纯使用 Premaster Secret 而须引入新的随机因子，三个伪随机数配合 PRF 导出的随机数就会十分接近真随机。\nTLS Record Protocol 进一步了解  Internet Engineering Task Force. The TLS Protocol Version 1.0. The Transport Layer Security (TLS) Protocol Version 1.3. Datatracker The Transport Layer Security (TLS) Protocol Version 1.3. Transport Layer Security - Wikipedia. 那些關於SSL/TLS的二三事(九) — SSL (HTTPS)Communication | Medium.  ","date":1494288e3,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1494288e3,"objectID":"bc78590396e69ea7000a100ba6d8d4e7","permalink":"/post/tech-for-good/deep-dive-into-ssl-tls/","publishdate":"2017-05-09T00:00:00Z","relpermalink":"/post/tech-for-good/deep-dive-into-ssl-tls/","section":"post","summary":"SSL/TLS 协议详解","tags":["TLS"],"title":"深入了解 SSL/TLS Protocol","type":"book"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Swift Programming Language"],"content":"关于 ","date":1481797889,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1481797889,"objectID":"1f4d4a0eab3e8dcb2c8ebf9f9b316475","permalink":"/post/tech-for-good/apple-swift/","publishdate":"2016-12-15T10:31:29Z","relpermalink":"/post/tech-for-good/apple-swift/","section":"post","summary":"关于 ","tags":["Swift"],"title":"深入了解 Swift 源码","type":"book"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Objective-C Programming Language","The Swift Programming Language"],"content":" That day, if swift had never been released\u0026hellip;, would Objective-C be different?\n The objc-evolutions repository maintains personal major proposals for exploration and enhancements to the The Objective-C Programming Language.\n OE-0001 Introduce Swift var, let keyword   OE-0002 Introduce Swift defer keyword   OE-0003 Protocol Default Implementation   Conditional Binding 在 Swift 中我们可以用 if let、guard let、where let 等来做到 Conditional Binding。\nif let parent = NSViewController().parent { // ... }  在 C++ 中我们也可以做到。\nif (let cgImage = UIImage.alloc.init.CGImage) { // ... } else { // ... } if (let image = UIImage.alloc.init; let cgImage = image.CGImage) { // ... }  Lightweight Generics Swift 中的 Generic Type\npublic struct Array\u0026lt;Element\u0026gt; : RandomAccessCollection, MutableCollection { // ... }  虽然 C++ 有 template，但它无法约束于 Cocoa Class，好在 Clang 为 ObjC 引入了 Lightweight Generics 使得我们可以获取到容器类的元素类型，使得我们可以做到如下代码所示的效果。\n// typeof(array) = NSArray\u0026lt;NSString *\u0026gt; *const let array = [NSArray\u0026lt;NSString *\u0026gt; new];  此外 Built-in 容器的方法诸如 NSArray.copy、NSArray.mutableCopy 对泛型不够友好，于是我们可以自己声明一个带有范型的版本。\n@interface NSArray\u0026lt;T\u0026gt;() - (NSArray\u0026lt;T\u0026gt; *)copy __attribute__((objc_requires_super)); - (NSArray\u0026lt;T\u0026gt; *)mutableCopy __attribute__((objc_requires_super)); @end  typealias 在 Swift 中有这样一段很常见的声明：\n#if os(macOS) import AppKit typealias View = NSView #elseif os(iOS) import UIKit typealias View = UIView #endif  那么在 ObjC，通过 @compatibility_alias 中我们同样能做到这样的声明，而不是采用 C Marco 的形式。\n#if TARGET_OS_IPHONE #import \u0026lt;UIKit/UIView.h\u0026gt; @compatibility_alias View UIView; #elif TARGET_OS_MAC #import \u0026lt;AppKit/NSView.h\u0026gt; @compatibility_alias View NSView; #endif  Operator overload 借助 C++，我们同样能在 ObjC 中实现操作符重载。\nCGSize operator*=(const CGSize \u0026amp;lhs, CGFloat multi) { return (CGSize){lhs.width * multi, lhs.height * multi}; } let size = CGSizeMake(10, 10) *= 10;  Function polymorphism 一个典型的 Swift 泛型函数。\npublic func max\u0026lt;T\u0026gt;(_ x: T, _ y: T) -\u0026gt; T where T : Comparable  借助 template，我们同样可以在 ObjC++ 达到同样的效果。\ntemplate \u0026lt;typename T\u0026gt; T max(T x, T y) { return x \u0026lt; y ? y : x; } let maxInt = max(1, 2); let maxDouble = max(1.0, 2.0);  进一步了解  __auto_type does not inherit nullability to inferred type if statement Adopting Modern Objective-C ObjCCompatibleAliasDecl 8.6 compatibility_alias auto-type.c Referring to a Type with typeof  ","date":1466850689,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1466854289,"objectID":"5ecfdcb354fcc85f6a1a88774f85f523","permalink":"/post/tech-for-good/objc-evolution-proposals/","publishdate":"2016-06-25T10:31:29Z","relpermalink":"/post/tech-for-good/objc-evolution-proposals/","section":"post","summary":"That day, if swift had never been released..., would Objective-C be different?","tags":["Objective-C","Swift"],"title":"The Objective-C Programming Language Evolution","type":"book"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Objective-C Programming Language"],"content":"关于 ","date":1450175489,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1450175489,"objectID":"04a5c2aa366626ce5a99b757b22c38ae","permalink":"/post/tech-for-good/objc-runtime-101/","publishdate":"2015-12-15T10:31:29Z","relpermalink":"/post/tech-for-good/objc-runtime-101/","section":"post","summary":"关于 ","tags":["Objective-C"],"title":"深入了解 Objective Runtime","type":"book"},{"authors":["徐旭栋"],"categories":null,"content":"索引  Apple Inc.   Tencent Holding Ltd.   TESLA, Inc.   NIO Inc.   BERKSHIRE HATHAWAY INC.   Netflix   Bilibili   Lukkin Coffee   ","date":1434659790,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1434659790,"objectID":"52bc13ecb9b0a901271afcc42993cb59","permalink":"/post/investor/investor-relations/","publishdate":"2015-06-18T20:36:30Z","relpermalink":"/post/investor/investor-relations/","section":"post","summary":"财报分析与披露","tags":["Financial Data","Earnings Reports"],"title":"投资者关系 Investor Relations","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operation System","macOS"],"content":"索引  HT0002 如何在 macOS 上显示隐藏文件和文件夹   HT0003 如何在 VMware Fusion 上进行端口映射   HT0007 如何使用 SSL 证书签名 iOS .mobileconfig 文件   HT0013 如何向 iOS 系统中添加自定义字体   HT0022 如何创建可引导的 macOS 安装镜像   HT0025 如何在 macOS 上检视 PCI 设备   HT0026 未越狱如何降级 iOS 应用版本   HT0030 如何在 iCloud 中屏蔽不需要同步的文件   进一步了解  IFIXIT  ","date":1434659790,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1434659790,"objectID":"312d2bbb96a12df2b0c1a148b0e29e9c","permalink":"/post/tech-for-good/enhancing-productivity-with-mac/","publishdate":"2015-06-18T20:36:30Z","relpermalink":"/post/tech-for-good/enhancing-productivity-with-mac/","section":"post","summary":"Enhancing Productivity with Mac","tags":["macOS"],"title":"使用 Mac 提高生产力","type":"book"},{"authors":["徐旭栋"],"categories":["The Classification of Instructional Programs"],"content":"关于 此页面为全站 CIP 分类索引入口\n2 位数 CIP 代码 ","date":1418639489,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1418639489,"objectID":"6981c531e26e66c0eb17b956d60833d3","permalink":"/cipcode/","publishdate":"2014-12-15T10:31:29Z","relpermalink":"/cipcode/","section":"cipcode","summary":"关于 此页面为全站 CIP 分类索引入口\n2 位数 CIP 代码 ","tags":["CIP"],"title":"The Classification of Instructional Programs","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"5adf812e70f16e0e62ad872ccd37f104","permalink":"/2019/12/12/apple-inc./","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/apple-inc./","section":"post","summary":"","tags":["Financial Data","Earnings Reports"],"title":"Apple Inc.","type":"book"},{"authors":["徐旭栋"],"categories":["Economics","Economics, Other"],"content":"Overview  We introduce Game Theory by playing a game. We organize the game into players, their strategies, and their goals or payoffs; and we learn that we should decide what our goals are before we make choices. With some plausible payoffs, our game is a prisoners’ dilemma. We learn that we should never choose a dominated strategy; but that rational play by rational players can lead to bad outcomes. We discuss some prisoners’ dilemmas in the real world and some possible real-world remedies. With other plausible payoffs, our game is a coordination problem and has very different outcomes: so different payoffs matter. We often need to think, not only about our own payoffs, but also others’ payoffs. We should put ourselves in others’ shoes and try to predict what they will do. This is the essence of strategic thinking.\nLecture Chapters   What Is Strategy? [00:00:00] Strategy: Where Does It Apply? [00:02:16] (Administrative Issues) [00:02:54] Elements of a Game: Strategies, Actions, Outcomes and Payoffs [00:09:40] Strictly Dominant versus Strictly Dominated Strategies [00:21:38] Contracts and Collusion [00:29:33] The Failure of Collusion and Inefficient Outcomes: Prisoner\u0026rsquo;s Dilemma [00:33:35] Coordination Problems [00:41:40] Lesson Recap [01:07:53]     TRANSCRIPT AUDIO LOW BANDWIDTH VIDEO HIGH BANDWIDTH VIDEO     html mp3 mov [100MB] mov [500MB]    Learn More  Lecture 1 - Introduction: Five First Lessons.  ","date":1546338689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546338689,"objectID":"5e1b8ca0c2c9ad06a0dc77c12bca02c5","permalink":"/2019/01/01/lecture-1-introduction-five-first-lessons/","publishdate":"2019-01-01T10:31:29Z","relpermalink":"/2019/01/01/lecture-1-introduction-five-first-lessons/","section":"post","summary":"Overview  We introduce Game Theory by playing a game. We organize the game into players, their strategies, and their goals or payoffs; and we learn that we should decide what our goals are before we make choices.","tags":["Game Theory"],"title":"Lecture 1 - Introduction Five First Lessons","type":"book"},{"authors":null,"categories":null,"content":" Proposal: OE-0001 Authors: Xudong Xu Status: Implemented  Introduction var 和 let 是 Swift 定义变量的重要关键字，描述了变量是否可以被修改，将这些关键字引入 Objective-C，以更好地表达变量的可变性。\nMotivation 在 Objective-C 中变量声明的 Type Inference 一直没有很好的解决方案，下方的显示类型声明代码是我们经常需要面对的：\nNSMutableArray\u0026lt;NSString *\u0026gt;* array = [[NSMutableArray\u0026lt;NSString *\u0026gt; array];  在 Swift 中会由类型推导自动完成：\nvar elements = [String]();  Proposed solution 在 ObjC 中引入 let 和 var 关键字：\nlet elements = [NSMutableArray\u0026lt;NSString *\u0026gt; array];  影响范围为所有变量声明，并且同时兼容 C/C++。\nDetailed design 得益于 Clang 将类型推导特性带入了 pure C，使得我们能在 C 代码中使用 __auto_type 来做类型推导：\n// File.c __auto_type str = \u0026quot;string\u0026quot;;  以 const 修饰达到 let 的效果，通过宏实现定义关键字：\n#ifdef __cplusplus #define var auto #define let const auto #else #define var __auto_type #define let const __auto_type #endif  使 C/ObjC 能像 Swift 一样使用 var 和 let。\nvar vector = std::vector\u0026lt;NSInteger\u0026gt;{1, 2, 3}; let array = NSArray.alloc.init; let block = ^void (id self, SEL _cmd) { return; };  Source compatibility 此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的语法，不会有任何更改格式正确的代码的行为。\nAlternatives considered 在 C++ 的环境下，可以通过 auto 完成类型推导：\nauto array = [[NSMutableArray\u0026lt;NSString *\u0026gt; array];  但是这样会引入 C++，对于很多场景下这是没必要的。\n","date":1466937089,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466937089,"objectID":"e408493c1bd1d175ebc3e166e36af7a8","permalink":"/2016/06/26/oe-0001-introduce-swift-var-let-keyword/","publishdate":"2016-06-26T10:31:29Z","relpermalink":"/2016/06/26/oe-0001-introduce-swift-var-let-keyword/","section":"post","summary":"Proposal: OE-0001 Authors: Xudong Xu Status: Implemented  Introduction var 和 let 是 Swift 定义变量的重要关键字，描述了变量是否可以被修改，将这些关键字引入 Objective-C，以更好地表达变量的可变性。\nMotivation 在 Objective-C 中变量声明的 Type Inference 一直没有很好的解决方案，下方的显示类型声明代码是我们经常需要面对的：\nNSMutableArray\u0026lt;NSString *\u0026gt;* array = [[NSMutableArray\u0026lt;NSString *\u0026gt; array];  在 Swift 中会由类型推导自动完成：","tags":null,"title":"OE-0001 Introduce Swift var, let keyword","type":"book"},{"authors":["徐旭栋"],"categories":null,"content":"隐含波动率（或称引申波幅，IV ）是了解何时买卖期权的最重要指标之一。IV 由特定股票或期货的期权合约的当前价格反推得出，用百分比表示，表示基于当前的期权价格，底层标的年化波动预期的标准差。例如，对于 200 美元的股票，IV 的 25％ 表示未来一年的标准差范围为 50 美元，更多关于 IV 的概念可以参考之前的文章。\n由于波动率对期权价格有很大影响，所以通常我们会在波动率较高的环境下作为期权卖方，而在波动率较低的环境时作为期权买方。因此如何衡量波动率的相对高低成为了一个问题，通常不同标的波动率的横向对比并没有太多实际意义，本文就同一标的的情况下，侧重讨论几种衡量 IV 高低的方法。\nImplied Volatility Percentile 隐含波动率百分位（Implied Volatility Percentile）为交易者提供了一个额外的度量标准来衡量期权价格的相对高低，下文统一用 IVP 描述。52 周 IVP 从当前日期前推一整年，通过观察历史波动率的高低，与当前的 IV 进行对比，计算出过去的一整年中低于当前 IV 值的天数占总天数的百分比。简单来说 IVP 主要统计在历史区间上有多少交易日的 IV 值是低于当前水准的，其公式为：\n$$ IVP = \\sum_{i=1}^n [ \\frac{ IV_i }{ IV_{ current } } ] \\div n $$\n$$ n = Period $$\n通常在各种 Screener 或者 Broker 平台上能找到这个指标。图中的粉色标注的即为 IVP 趋势线，以 AAPL 为例目前的 IVP 为 62.7%，当日的全天平均波动率为 37.04%。\n52 周 IVP 通过将 AAPL IV 低于其当前水平的交易日天数除以 252（一年中的交易日数 n = 252）得出的。例如当前的 IVP 为 62.7%，可以理解为 AAPL 的波动率在过去一年的 62.7％（或一年的三分之二）内低于当前的隐含波动率，这表明 AAPL 的波动率在一年内大约三分之二时间内一直低于 37.04％，剩余的三分之一时间内 IV 都高于当前的 37.04%。这个数据意味着相比于过去一年内的 AAPL IV，当前波动率处于较高的三分之一区域，因此当前 IVP 状态下的期权，相对于更低 IVP 周期的期权来说，会更昂贵。\nImplied Volatility Rank 隐含波动率等级（Implied Volatility Rank）这个译文总觉得不怎么顺口，下文依旧还是统一用 IVR 描述。IVR 同样是很多交易员在做期权策略时会考虑的一个衡量指标。基于过去一年的 IV 水平，IVR 可以衡量出当前隐含波动率处于波动率区间的高低位置。同一标的 IVR 越高意味着当前期权的价格越昂贵，通常我们使用过去 52 周的最高 IV 值和最低 IV 作为波动率区间，如果需要计算短期波动率可以使用其他时间段，比如一些交易平台会支持 30 天、90 天、6 个月等等，简单来说 IVR 的主要是和统计区间的历史最高值和最低值去做比较，\n以 AAPL 为例，计算以一年为区间，当前的 IV 值对应的 IVR，首先参考 AAPL 的历史波动率曲线。\n AAPL Chart by TradingView  new TradingView.widget({ \"autosize\": true, \"symbol\": \"NASDAQ:AAPL\", \"interval\": \"D\", \"timezone\": \"Asia/Hong_Kong\", \"theme\": \"light\", \"style\": \"2\", \"locale\": \"uk\", \"toolbar_bg\": \"#f1f3f6\", \"enable_publishing\": false, \"hide_top_toolbar\": true, \"hide_legend\": true, \"save_image\": false, \"studies\": [ \"HV@tv-basicstudies\" ], \"container_id\": \"tradingview_b0716\" });   52 周 IV 最高出现在 2020 年 03 月的熔断，146.69% 左右，52 周最低出现在 2019 年 11 月，为 9.4%，以当前为基准，前推一年期的 IVR 计算公式为：\n$$ IVR = \\frac { IV_{ Current } − IV_{ 52LowestLow } }{ IV_{ 52HighestHigh } − IV_{ 52LowestLow} } \\times 100 % $$\n2020 年 07 月 28 日，全天隐含波动率的平均值为 37.04%，代入公式计算：\n$$ IV_{ Current } (0.3704) − IV_{ 52LowestLow } (.094) = 0.2764 $$\n$$ IV_{ 52HighestHigh }(1.4669) − IV_{ 52LowestLow } (.094) = 1.3729 $$\n$$ IV Rank = 0.2764/1.3729 = 0.2013 $$\n计算得出的 20.13% 的 IV Rank 意味着当前的 IV 处于过去一整年波动率区间低位 20.13% 处，说明当前的 IV 非常接近 52 周历史低点。在极端的情况下，比如当前 IV 在 1 年内的历史最低点或历史最高点处时，此时的 IVR 会呈现为 0% 或 100%。\n很显然 IVR 和 IVP 的值都在 0 到 1 之间，IVR 通常小于 IVP。两者的值越大，意味着此时 IV 相对历史水平来说更高，所以此时的期权价格也会更贵。由于数据统计复杂度的区别，部分刚接触这些指标的交易者会更青睐只需要统计最大最小值的 IVR，由于 IVR 没有统计意义上的算数平均和加权平均，所以当出现类似 3 月份 Volatility Spikes 的情况下，IV Rank 会出现一定的失真，事实上以 AAPL 为例，接近 40% 的 IV 值从主观角度很难说这是个非常低的 IV，所以在做决策时，IVR 和 IVP 应该作为同向指标一起参考，切忌将这两个指标分开分析，一切指标基于数学，切勿盲目遵循指标。\n进一步了解  IV Rank vs. IV Percentile IVR and IVP: The Numbers  ","date":1595951056,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1595951056,"objectID":"4edfccead2a3bb6d025725d598437721","permalink":"/2020/07/28/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87/","publishdate":"2020-07-28T15:44:16Z","relpermalink":"/2020/07/28/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87/","section":"post","summary":"隐含波动率衡量方法 Implied Volatility Measurement","tags":["Options","Implied Volatility","IV","IVP","IVR"],"title":"如何衡量隐含波动率","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"   腾讯科技股份有限公司\n进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"d4e94238f69da9f4daec5f7438829683","permalink":"/2019/12/12/tencent-holding-ltd./","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/tencent-holding-ltd./","section":"post","summary":"   腾讯科技股份有限公司\n进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"Tencent Holding Ltd.","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"您可以通过命令行来显示被 Mac 操作系统隐藏的文件和文件夹。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\nOS X Mavericks 及之后的 Mac 操作系统  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”，在“终端”中键入或粘贴以下命令。  defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder  完成之后，你将会在 Finder 中看到被隐藏的文件和文件夹。 如果希望再次一次这些被隐藏的文件和文件夹时，在“终端”中键入或粘贴以下命令。  defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder  【提示】 该命令适用于 OS X Mavericks 和 OS X Yosemite 系统。对于还在使用 OS X Mountain Lion 或是更早版本的系统的 Mac 用户来说，请使用如下的命令。\nOS X Mountain Lion 及之前的 Mac 操作系统  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”，在“终端”中键入或粘贴以下命令。  defaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder  完成之后，你将会在 Finder 中看到被隐藏的文件和文件夹。 如果希望再次一次这些被隐藏的文件和文件夹时，在“终端”中键入或粘贴以下命令。  进一步了解  在 Mac 上显示或隐藏文件扩展名 - Apple 支持  ","date":1511692289,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1511692289,"objectID":"fdac491620a808a378d5bc590543077d","permalink":"/2017/11/26/ht0002-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/","publishdate":"2017-11-26T10:31:29Z","relpermalink":"/2017/11/26/ht0002-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/","section":"post","summary":"您可以通过命令行来显示被 Mac 操作系统隐藏的文件和文件夹。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\nOS X Mavericks 及之后的 Mac 操作系统  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”，在“终端”中键入或粘贴以下命令。  defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder  完成之后，你将会在 Finder 中看到被隐藏的文件和文件夹。 如果希望再次一次这些被隐藏的文件和文件夹时，在“终端”中键入或粘贴以下命令。  defaults write com.","tags":["macOS"],"title":"HT0002 如何在 macOS 上显示隐藏文件和文件夹","type":"book"},{"authors":null,"categories":null,"content":" Proposal: OE-0002 Authors: Xudong Xu Status: Implemented  Introduction defer 是 Swift 定义变量的重要关键字，用于 Control Flow 在当前作用域退出之后的收尾操作，将 defer 关键字引入 Objective-C，使 Control Flow 更优雅。\nMotivation defer 极大的改变了资源的获取与释放的代码编写流程，没有 defer 的情况下，我们需要在所有的退出语句都加上收尾处理。\nfunc foo() { guard let list = class_copyMethodList(value, \u0026amp;outCount) else { return } if (condition) { // ... free(list) return } // ... free(list) }  用了 defer 之后可以把精力放在 Control Flow 上，而不是在何处处理收尾，Swift 是一门提倡尽早 return 的语言：\n// with defer func foo() { guard let list = class_copyMethodList(value, \u0026amp;outCount) else { return } defer { free(list) } if (condition) { // ... return } // ... return }  Proposed solution 得益于 Clang 的 __attribute((cleanup())) 特性，将 C Block 标记为一个从当前作用域退出之后执行的收尾用匿名函数。\nDetailed design 实现参考\n runtime/swift.h#L29  通过宏定义的 defer，可以做到如下的 Control Flow：\nstatic pthread_mutex_t lock_key; void foo() { pthread_mutex_lock(\u0026amp;lock_key); defer { pthread_mutex_unlock(\u0026amp;lock_key); }; var cls_count = (unsigned)0; let cls_list = objc_copyClassList(\u0026amp;cls_count); defer { free(cls_list); }; // do sth }  Source compatibility 此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的 Control Flow，不会有任何更改格式正确的代码的行为。\nAlternatives considered 无\n","date":1466937089,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466937089,"objectID":"13dcfec2e917148fd62093fd3bdd3c9b","permalink":"/2016/06/26/oe-0002-introduce-swift-defer-keyword/","publishdate":"2016-06-26T10:31:29Z","relpermalink":"/2016/06/26/oe-0002-introduce-swift-defer-keyword/","section":"post","summary":"Proposal: OE-0002 Authors: Xudong Xu Status: Implemented  Introduction defer 是 Swift 定义变量的重要关键字，用于 Control Flow 在当前作用域退出之后的收尾操作，将 defer 关键字引入 Objective-C，使 Control Flow 更优雅。\nMotivation defer 极大的改变了资源的获取与释放的代码编写流程，没有 defer 的情况下，我们需要在所有的退出语句都加上收尾处理。\nfunc foo() { guard let list = class_copyMethodList(value, \u0026amp;outCount) else { return } if (condition) { // .","tags":null,"title":"OE-0002 Introduce Swift defer keyword","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"您可以通过编辑 VMware Fusion 的 NAT 配置文件来对端口进行映射。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n修改配置文件  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在获取管理员权限之后，通过 vim 或者手动编辑位于 /Library/Preferences/VMware Fusion.app/vmnet8/nat.conf 的 NAT 配置文件，在“终端”中键入或粘贴以下命令。  sudo vim /Library/Preferences/VMware\\ Fusion.app/vmnet8/nat.conf  自定义 incomingtcp 下的端口号（左侧）与虚拟机的端口号（右侧）进行流量转发。  [incomingtcp] # Use these with care - anyone can enter into your VM through these... # The format and example are as follows: # \u0026lt;external port number\u0026gt; = \u0026lt;VM's IP address\u0026gt;:\u0026lt;VM's port number\u0026gt; # 8080 = 172.16.3.128:80  重启 VMware Network  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在获取管理员权限之后，在“终端”中键入或粘贴以下命令。  sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --stop sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --start  进一步了解  如果需要进一步了解 Fusion 的 NAT 配置，您可以参考 Advanced NAT Configuration。  ","date":1542796289,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542796289,"objectID":"7df4223f43744f0b6f07326958a6cbea","permalink":"/2018/11/21/ht0003-%E5%A6%82%E4%BD%95%E5%9C%A8-vmware-fusion-%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/","publishdate":"2018-11-21T10:31:29Z","relpermalink":"/2018/11/21/ht0003-%E5%A6%82%E4%BD%95%E5%9C%A8-vmware-fusion-%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/","section":"post","summary":"您可以通过编辑 VMware Fusion 的 NAT 配置文件来对端口进行映射。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n修改配置文件  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在获取管理员权限之后，通过 vim 或者手动编辑位于 /Library/Preferences/VMware Fusion.app/vmnet8/nat.conf 的 NAT 配置文件，在“终端”中键入或粘贴以下命令。  sudo vim /Library/Preferences/VMware\\ Fusion.app/vmnet8/nat.conf  自定义 incomingtcp 下的端口号（左侧）与虚拟机的端口号（右侧）进行流量转发。  [incomingtcp] # Use these with care - anyone can enter into your VM through these.","tags":["macOS"],"title":"HT0003 如何在 VMware Fusion 上进行端口映射","type":"book"},{"authors":null,"categories":null,"content":" Proposal: OE-0003 Authors: Xudong Xu Status: Implemented  Introduction Swift 中，定义 Protocol 时，可以使用 extension 给某些方法提供默认实现，希望把此特性引入 Objective-C\nMotivation 在 Swift 中 Protocol 的默认实现一般为如下形式：\nprotocol Foo { associatedtype Element func method(_ arg: Element) } extension Foo where Element: Equatable { func method(_ arg: Element) { } static func isEqual(_ lhs: Element, _ rhs: Element) -\u0026gt; Bool { return lhs == rhs } }  对 Objective-C 来说还做不到这么强的泛型约束，但是希望能够做到基本的 Protocol 默认实现，比如给 UICollectionViewDelegate 加上不能选择的默认实现：\n@extension(UICollectionViewDelegate) - (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath { return false } @end  Proposed solution 通过 ObjC runtime 配合 C Marco，在 dyld load 之后 Clang Module Init 之前向 Dummy Class 注入 Protocol 的默认实现。在 Class +load 时候把默认实现的 Method 添加到具体的 Class 里。\nDetailed design 实现参考\n runtime/Extension.h#L20 runtime/Extension.cpp#L17  Source compatibility 此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的语法，不会有任何更改格式正确的代码的行为。\nAlternatives considered 在 C++ 的环境下，可以通过 auto 完成类型推导：\nauto array = [[NSMutableArray\u0026lt;NSString *\u0026gt; array];  但是这样会引入 C++，对于很多场景下这是没必要的。\n","date":1466937089,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466937089,"objectID":"3e0410e65eddbbb7cbf69bb7ba7b665c","permalink":"/2016/06/26/oe-0003-protocol-default-implementation/","publishdate":"2016-06-26T10:31:29Z","relpermalink":"/2016/06/26/oe-0003-protocol-default-implementation/","section":"post","summary":"Proposal: OE-0003 Authors: Xudong Xu Status: Implemented  Introduction Swift 中，定义 Protocol 时，可以使用 extension 给某些方法提供默认实现，希望把此特性引入 Objective-C\nMotivation 在 Swift 中 Protocol 的默认实现一般为如下形式：\nprotocol Foo { associatedtype Element func method(_ arg: Element) } extension Foo where Element: Equatable { func method(_ arg: Element) { } static func isEqual(_ lhs: Element, _ rhs: Element) -\u0026gt; Bool { return lhs == rhs } }  对 Objective-C 来说还做不到这么强的泛型约束，但是希望能够做到基本的 Protocol 默认实现，比如给 UICollectionViewDelegate 加上不能选择的默认实现：","tags":null,"title":"OE-0003 Protocol Default Implementation","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 04.02) 建筑.  04.0200) 建筑学预科.  04.0201) 建筑学.  04.0202) 建筑设计.  04.0299) 建筑学, 其他. 进一步了解  Detail for CIP Code 04.    --","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"be1a0a39d60d6748aa700d36ec099c77","permalink":"/cipcode/04/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/04/","section":"cipcode","summary":"4 位数 CIP 代码 04.02) 建筑.  04.0200) 建筑学预科.  04.0201) 建筑学.  04.0202) 建筑设计.  04.0299) 建筑学, 其他. 进一步了解  Detail for CIP Code 04.    --","tags":["CIP"],"title":"建筑及相关服务","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"   进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"4ff4d1eeea99bc4c88424846dd60ef12","permalink":"/2019/12/12/tesla-inc./","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/tesla-inc./","section":"post","summary":"   进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"TESLA, Inc.","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"   进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"fe3cdfe38eb32cc758b243b25753c06e","permalink":"/2019/12/12/nio-inc./","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/nio-inc./","section":"post","summary":"   进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"NIO Inc.","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","iOS"],"content":"您可以使用证书与 OpenSSL 签名 iOS 平台 .mobileconfig 文件。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。iPhoneOS / iPadOS 设备上的配置描述文件（.mobileconfig）是以 .plist 为载体，包含了设备安全策略、VPN 配置信息、Wi-Fi 设置、APN 设置、Exchange 帐户设置、Google 帐户设置、邮件设置以及允许 iPhone, iPod touch, iPad 与企业系统配合使用的证书。本文描述了开发者如何使用 SSL Certification 对 . mobileconfig 文件进行签名，以确保 iPhoneOS / iPadOS 系统上的安全性。\n准备工作 理解证书的状态    状态 说明     Unsigned The mobileconfig is not signed by anyone. Therefore the source is unknown.   Unverified The mobileconfig is signed, but the source is not recognized as trusted.   Verified The mobileconfig is signed and is recognized as a trusted source.    当使用 Apple Configurator 2 为 iPhoneOS / iPadOS 添加 Profile 文件时，未签名的 .mobileconfig 文件会被标记为 \u0026ldquo;Unsigned\u0026rdquo; 状态，修复此问题我们需要对 Profile 进行签名。\n准备所需要的文件  未签名的 .mobileconfig 文件，UnsignedProfile.mobileconfig 证书对应 Private Key，PrivateKey.pem 与 SSL 证书对应的证书链（中级证书），CertChain.pem 受信任的 SSL 证书，自签名证书、TrustAsia, Let’s Encrypt 等签发的免费 SSL 证书，商业 SSL 证书，Certificate.pem  签名方式 openssl smime -sign \\ -in UnsignedProfile.mobileconfig \\ -out SignedProfile.mobileconfig \\ -signer Certificate.pem \\ -inkey PrivateKey.pem \\ -certfile CertChain.pem \\ -outform der -nodetach  使用自签名证书签名 创建可引导安装器后，请按照以下步骤进行使用：\n从 Keychain Access 导出自签名证书 Keychain Access -\u0026gt; Certificate Assistance -\u0026gt; Create a Certificate，根据提示创建证书，创建完成之后对证书私钥进行导出，右键证书点击 Export 导出 Certificate.per，右键私钥点击 Export 导出 PrivateKey.p12，通过命令行将 .p12 转换为 .pem，将 Certificate.per 转换为 Certificate.pem。\nopenssl pkcs12 -in PrivateKey.p12 -out PrivateKey.pem -nodes openssl x509 -trustout -inform DER -outform PEM -in Certificate.cer -out Certificate.pem  下载根证书和中间证书 本文使用 AppleIncRootCertificate.cer 根证书和 AppleApplicationIntegrationCA5G1.cer 中间证书，更多证书可以访问 Apple PKI。下载完成后通过命令行从 Root Certificate 和 Intermediate Certificate 提取 Certificates 和 Keys，参考 INFO.SSL。\nopenssl x509 -trustout -inform DER -outform PEM -in AppleIncRootCertificate.cer -out Root.pem openssl x509 -trustout -inform DER -outform PEM -in AppleApplicationIntegrationCA5G1.cer -out Intermediate.pem  将 Intermediate.pem 和 Root.pem 中的文本内容合并为一份文件 AppleIncCertificateChain.pem，此时 AppleIncCertificateChain.pem 将会包含两份证书。\n签名  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在获取管理员权限之后，在“终端”中键入或粘贴以下命令。  openssl smime \\ -sign \\ -in UnsignedProfile.mobileconfig \\ -out SignedProfile.mobileconfig \\ -signer Certificate.pem \\ -inkey PrivateKey.pem \\ -certfile AppleIncCertificateChain.pem \\ -outform der -nodetach  进一步了解  Free SSL/TLS Certificates possible status of a mobileconfig? - Apple Community Apple PKI 在 macOS 服务器中创建自签名证书 - Apple 支持  ","date":1544351489,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544351489,"objectID":"0c27cf08af19ab3ec1edb7c235942ad6","permalink":"/2018/12/09/ht0007-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D-ios-.mobileconfig-%E6%96%87%E4%BB%B6/","publishdate":"2018-12-09T10:31:29Z","relpermalink":"/2018/12/09/ht0007-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D-ios-.mobileconfig-%E6%96%87%E4%BB%B6/","section":"post","summary":"您可以使用证书与 OpenSSL 签名 iOS 平台 .mobileconfig 文件。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。iPhoneOS / iPadOS 设备上的配置描述文件（.mobileconfig）是以 .plist 为载体，包含了设备安全策略、VPN 配置信息、Wi-Fi 设置、APN 设置、Exchange 帐户设置、Google 帐户设置、邮件设置以及允许 iPhone, iPod touch, iPad 与企业系统配合使用的证书。本文描述了开发者如何使用 SSL Certification 对 . mobileconfig 文件进行签名，以确保 iPhoneOS / iPadOS 系统上的安全性。","tags":["iOS"],"title":"HT0007 如何使用 SSL 证书签名 iOS .mobileconfig 文件","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"BERKSHIRE HATHAWAY ANNUAL \u0026amp; INTERIM REPORTS\n   Year 1st 2nd 3rd Annual*      Quarter Quarter Quarter    2020  1stqtr20  2ndqtr20  3rdqtr20     进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"fd4fc1693b1218db3ccc985e87c7c7f2","permalink":"/2019/12/12/berkshire-hathaway-inc./","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/berkshire-hathaway-inc./","section":"post","summary":"BERKSHIRE HATHAWAY ANNUAL \u0026amp; INTERIM REPORTS\n   Year 1st 2nd 3rd Annual*      Quarter Quarter Quarter    2020  1stqtr20  2ndqtr20  3rdqtr20     进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"BERKSHIRE HATHAWAY INC.","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"   进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"1777fe41b7cae6bc4ccf172a6d57534f","permalink":"/2019/12/12/netflix/","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/netflix/","section":"post","summary":"   进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"Netflix","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":" C\u0008omputer Science Curricula 2013   4 位数 CIP 代码 11.02) 计算机编程.  11.0201) 计算机编程/程序设计师, 常规.  11.0204) 计算机游戏编程.  11.0299) 计算机编程, 其他. 11.07) 计算机科学.  11.0701) 计算机科学.   徐旭栋  (2018). 深入了解 Protocol Buffers.   protobuf    徐旭栋  (2017). 深入了解 QUIC Transport Protocol.   draft-ietf-quic-transport-34    徐旭栋  (2017). 深入了解 HTTPS.   RFC 2818    徐旭栋  (2017). 深入了解 HTTP.   HTTP/1.1 - RFC 2616    徐旭栋  (2017). 深入了解 WebSocket Protocol.   RFC 6455    徐旭栋  (2017). 深入了解 TCP.   RFC 793    徐旭栋  (2017). 深入了解 UDP.   RFC 768   RFC 8085    徐旭栋  (2016). 再谈 Swift Performance.    徐旭栋  (2016). Whole-Module Optimization 分析.    徐旭栋  (2016). Swift 设计哲学.    徐旭栋  (2016). Introduce Objective-C Evolution.  项目    徐旭栋  (2016). 什么是数字签名【译注】.   Original Post    徐旭栋  (2016). 快速枚举与迭代器.    徐旭栋  (2015). Clang Attributes 使用文档.    徐旭栋  (2015). Xcode 插件整理.    徐旭栋  (2014). 关于 NSURL \u0026#43;URLWithString: 返回 nil.    徐旭栋  (2014). git submodule 使用过程中遇到的问题.    徐旭栋  (2014). 用 Hexo 搭建个人博客.     徐旭栋  (2021). 操作系统 2021 春.   GitHub   OS2021 spring    徐旭栋  (2018). HT0025 如何在 macOS 上检视 PCI 设备.    徐旭栋  (2018). HT0013 如何向 iOS 系统中添加自定义字体.    徐旭栋  (2018). HT0007 如何使用 SSL 证书签名 iOS .mobileconfig 文件.    徐旭栋  (2018). HT0003 如何在 VMware Fusion 上进行端口映射.    徐旭栋  (2018). HT0022 如何创建可引导的 macOS 安装镜像.    徐旭栋  (2018). HT0026 未越狱如何降级 iOS 应用版本.    徐旭栋  (2017). HT0002 如何在 macOS 上显示隐藏文件和文件夹.    徐旭栋  (2017). 清华大学计算机系操作系统.   the Learning Hub of OS Course   oscourse    徐旭栋  (2017). 深入了解 SSL/TLS Protocol.   RFC 6101   RFC 2246   RFC 4346   RFC 5246   RFC 8446    徐旭栋  (2017). TLS Record Protocol.    徐旭栋  (2017). TLS Handshaking Protocols.    徐旭栋  (2017). HT0030 如何在 iCloud 中屏蔽不需要同步的文件.    徐旭栋  (2016). 深入了解 Swift 源码.     (2016). OE-0001 Introduce Swift var, let keyword.     (2016). OE-0003 Protocol Default Implementation.     (2016). OE-0002 Introduce Swift defer keyword.    徐旭栋  (2016). The Objective-C Programming Language Evolution.    徐旭栋  (2015). 深入了解 Objective Runtime.  项目    徐旭栋  (2015). 使用 Mac 提高生产力.   \n归档方案 苹果文档的执行方式 目前苹果知识库主要以 HT 和 Apple Developer Documentation 为主，任何产品相关的问题都在 Apple Support 以 HT 形式进行发布，Apple Developer Documentation 则服务于开发者。苹果在早期通过命名前缀的方式来对各种类型的文档进行分类、组织以及归档：\n  HT 前缀的文章为 How to，用于解答产品使用问题等，目前仍服务于官网 Apple Support，例如 If you forgot the answers to your Apple ID security questions - Apple Support。\n  TN 前缀的文章为 Technical Note，服务于开发者，例如 Technical Note TN2431: App Testing Guide，目前苹果已经对 TN 系列文章进行归档并停止维护，并迁移至 Featured | Apple Developer Documentation。\n  TS 前缀的文章通常表示为 Troubleshoot，用于排查各类产品的软硬件问题，例如 Mac doesn\u0026rsquo;t start up from disc - Apple Support，目前苹果也对 TS 系列文章归档并停止维护，并迁移至 HT 系列。\n  TA 前缀的文章表示为 Technical Article，用于发布一些软硬件相关的技术信息与文档等，例如 Apple 500MB \u0026amp; 1GB Hard Drives: SCSI Pin Configuration、NeXTSTEP 3.3 Driver: 3Com EtherLink III，目前苹果已对 TA 系列文章归档并停止维护。\n  计算机科学知识库 知识库的索引和技术文档的实施方案，针对本博客如何建立个人计算机科学知识库的执行的方案。\n参考苹果的组织方式，将知识库模版分为 HT 模版和 Developer Documentation 模版：\n HT 文章命名采取 HT\u0026lt;版号递增\u0026gt; \u0026lt;标题\u0026gt;，主要承载各类软硬件的使用、配置、问题排查。 Developer Documentation 文章命名采取 TN\u0026lt;版号递增\u0026gt; \u0026lt;标题\u0026gt;，主要承载开发者相关的技术沉淀。  进一步了解  Detail for CIP Code 11.  苹果文档相\n Documentation Archive. A List of the latest posted kbase articles - Apple Community. the meaning of Apple articles prefixes li… - Apple Community. What\u0026rsquo;s up with HT#### and TS####? - Apple Community. Knowledgebase links of the info.apple.com… - Apple Community. Apple Knowledge base (kb) articles - Apple Community.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"6614a5f2fd7ec5fb77665c4f09ecbe96","permalink":"/cipcode/11/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/11/","section":"cipcode","summary":"C\u0008omputer Science Curricula 2013   4 位数 CIP 代码 11.02) 计算机编程.  11.0201) 计算机编程/程序设计师, 常规.  11.0204) 计算机游戏编程.  11.0299) 计算机编程, 其他. 11.07) 计算机科学.  11.0701) 计算机科学.   徐旭栋  (2018).","tags":["CIP"],"title":"计算机与信息科学及支持服务","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operation System","iOS"],"content":"为 iPhoneOS / iPadOS 设备添加自定义字体。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n概览 iOS 并不限制第三方添加字体到系统之中，当你有自定义字体想在你的 app 或者其他系统内建应用（e.g. Notes.app, Pages.app）中使用时，通过 iOS 提供的多种方法你可以实现不同的结果。\n为应用添加自定义字体 为一个 app 添加字体，字体的使用范围限制于当前 app 之中，如图所示，将字体拖入至工程，并勾选对应的 Target Membership。\n  Adding a Custom Font to Your App  通过 Info.plist UIAppFonts (Fonts provided by application) 字段向 Xcode 工程注册字体，完成之后就可以像其他 iOS 内建字体一样使用你的自定义字体。\n更多请参考 Apple 文档 Adding a Custom Font to Your App | Apple Developer Documentation。\n向 iOS 系统注册自定义字体 为系统内建的应用提供自定字体需要用到 iOS 13 新提供的 CoreText 的 API，同时需要在 App.entitlements 中添加 Fonts Capability 并勾选 Install Fonts，使用字体时需要勾选 Use Installed Fonts。\n  WWDC19 Session 227    Adding a Custom Font to Your App  如果其他 app 需要使用通过 CTFontManagerRegisterFontURLS 进行注册的字体，需要通过 CTFontManagerRequestFonts 进行 request 才能获得字体。\n  WWDC19 Session 227  更多请参考 Font Management and Text Scaling - WWDC 2019 - Videos - Apple Developer。\n通过 .mobileconfig 向 iOS 系统添加自定义字体 通过 CoreText 提供的 API 有需要使用 CTFontManagerRequestFonts 的限制，所以无法适用于部分没有使用此 API 的 app (e.g. Notes.app)，因此可以通过 Apple Configurator 2 生成字体 Profile 来配置字体，打开 Apple Configurator 2 并切换到 Fonts 页面，点击右侧的 Configure，就会弹出对话框要求选择字体。 单个描述文件的容量上限约为 20 megabytes，所以对于较小西文字体文件，可以将整个 Font Family 配置到同一个描述文件中，对于较大的非西文字体，则应该逐个单独添加。\n  进一步了解  Adding a Custom Font to Your App | Apple Developer Documentation Font Management and Text Scaling - WWDC 2019 - Videos - Apple Developer iOS 13 Custom Fonts download and installation Browse Fonts - Google Fonts Google Noto Fonts  ","date":1544437889,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544437889,"objectID":"a8f175002372b999e74a8ababcf1369d","permalink":"/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/","publishdate":"2018-12-10T10:31:29Z","relpermalink":"/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/","section":"post","summary":"为 iPhoneOS / iPadOS 设备添加自定义字体。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n概览 iOS 并不限制第三方添加字体到系统之中，当你有自定义字体想在你的 app 或者其他系统内建应用（e.g. Notes.app, Pages.app）中使用时，通过 iOS 提供的多种方法你可以实现不同的结果。\n为应用添加自定义字体 为一个 app 添加字体，字体的使用范围限制于当前 app 之中，如图所示，将字体拖入至工程，并勾选对应的 Target Membership。\n  Adding a Custom Font to Your App  通过 Info.","tags":["iOS"],"title":"HT0013 如何向 iOS 系统中添加自定义字体","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 14.01) 工程学, 常规 Engineering, General.  14.0101) 工程学, 常规 Engineering, General. 14.10) 电气, 电子, 与通信工程 Electrical, Electronics, and Communications Engineering.  14.1001) 电气与电子工程 Electrical and Electronics Engineering. Central Processing Unit (CPU) Intel Chipset Products\nSecurity Issue\nProject Zero: Reading privileged memory with a side-channel\nLKML: Linus Torvalds: Re: Avoid speculative indirect calls in kernel\n Intel Responds to Security Research Findings Intel Security Issue Update: Addressing Reboot Issues  Pipeline\nMIPS\nARM Chipset\nWave Computing\n进一步了解  Detail for CIP Code 14. Electronic engineering - Wikipedia. International Electrotechnical Commission - Wikipedia. International Telecommunication Union - Wikipedia.  Organization\n IEEE. IEC. ITU.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"e597757cf2881ffc4123e069e164c410","permalink":"/cipcode/14/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/14/","section":"cipcode","summary":"14) [ENGINEERING](https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56\u0026cip=14).","tags":["CIP"],"title":"工程学","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 16.01) Linguistic, Comparative, and Related Language Studies and Services. 16.03) 东亚语言, 文学, 和语言学.  16.0302) 日本语和文学. 进一步了解  Detail for CIP Code 16  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"8e74e2170e57e1d7c535766e57c367e2","permalink":"/cipcode/16/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/16/","section":"cipcode","summary":"16) FOREIGN LANGUAGES, LITERATURES, AND LINGUISTICS.","tags":["CIP"],"title":"外语, 文学, 和语言学","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 19.05) 食物, 营养, 与相关服务.  19.0504) 人类营养学 Human Nutrition. Protein\n雞蛋\n   蛋白质 单位蛋白质热量 (Kcal/g) 单位蛋白质脂肪 (g/g)     全蛋 12.3 1.18   蛋白 5.15 0.008   蛋白粉 5 0.05       营养成分 单位 每 100 克含量 每只 (60g) 含量 每 100 克鸡蛋白含量 每只鸡蛋白 (30g) 含量     水 克 74.6      能量 千卡 155 93 60 18   蛋白质 克 12.6 7.5 11.6 3.5   脂肪 克\t10.6 6.4 0.1 0.03    碳水化合物 克 1.1  3.1 0.9    进一步了解  Detail for CIP Code 19. ATHLEAN-X GUIDE TO PROTEINS.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"e867fd65d58cb3ce5d9a7570a150089c","permalink":"/cipcode/19/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/19/","section":"cipcode","summary":"19) FAMILY AND CONSUMER SCIENCES/HUMAN SCIENCES.","tags":["CIP"],"title":"家庭与消费者科学/人文科学","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"您可以将磁盘镜像用作安装 Mac 操作系统的启动磁盘。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。升级 macOS 或重新安装 macOS 不需要安装器，但如果您在多台电脑上安装 macOS 时，可引导安装器就会很有用。\n创建可引导安装器需要满足的条件  备用宗卷（格式化为 Mac OS 扩展格式），至少有 13 GB 可用储存空间 已下载 macOS Big Sur、Catalina、Mojave、High Sierra 或 El Capitan 的安装器  下载 macOS   下载：macOS Big Sur、macOS Catalina、macOS Mojave 或 macOS High Sierra 这些内容将作为名为“安装 macOS [版本名称]”的 App 下载到您的“应用程序”文件夹。如果安装器在下载后打开，请退出而不要继续安装。要获取正确的安装器，请从运行 macOS Sierra 10.12.5 或更高版本或者 El Capitan 10.11.6 的 Mac 中进行下载。如果您是企业管理员，请通过 Apple 下载，而不要通过本地托管的软件更新服务器进行下载。   下载：OS X El Capitan 这个内容将作为名为“InstallMacOSX.dmg”的磁盘映像下载。在与 El Capitan 兼容的 Mac 上，打开下载的磁盘映像，并运行其中名为 InstallMacOSX.pkg 的安装器。它会在您的“应用程序”文件夹中安装一个名为“安装 OS X El Capitan”的 App。您将通过这个 App（而不是磁盘映像或 .pkg 安装器）创建可引导安装器。\n  在“终端”中使用 “hdiutil” 命令  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在“终端”中键入或粘贴以下命令，按下 Return 键以输入命令，创建安装镜像。  hdiutil create -o ~/Desktop/MyVolume -size 8g -layout SPUD -fs HFS+J \u0026amp;\u0026amp; \\ hdiutil attach ~/Desktop/MyVolume.dmg -noverify -mountpoint /Volumes/Install\\ macOS\\ Beta  在“终端”中使用 “createinstallmedia” 命令  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在“终端”中键入或粘贴以下命令。  sudo /Applications/Install\\ macOS\\ Beta.app/Contents/Resources/createinstallmedia —volume /Volumes/MyVolume.dmg --nointeraction  键入命令后：\n 按下 Return 键以输入这个命令。 出现提示时，请键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不会显示任何字符。 出现提示时，请键入 Y 以确认您要抹掉宗卷，然后按下 Return 键。创建可引导安装器过程中，“终端”将显示进度。  当“终端”提示操作已完成时，宗卷的名称将与您下载的安装器名称相同，例如“Install macOS Catalina”。您现在可以退出“终端”并弹出宗卷。    创建 .iso 镜像文件  打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。 在“终端”中键入或粘贴以下命令。  hdiutil convert ~/Desktop/MyVolume.dmg -format UDTO -o ~/Desktop/MyVolume.cdr mv ~/Desktop/MyVolume.cdr ~/Desktop/MyVolume.iso  使用可引导安装镜像 创建可引导安装镜像后，在支持从磁盘镜像启动的操作系统上，请按照以下步骤进行使用：\n 将可引导安装器作为硬件系统的虚拟磁盘。 将系统开机或重新启动后，进入磁盘引导。 根据提示选取您的语言。 从“实用工具”窗口中选择“安装 macOS”（或“安装 OS X”），然后点按“继续”，并按照屏幕上的说明进行操作。  进一步了解  参考 如何创建可引导的 macOS 安装器 - Apple 支持 制作 USB 启动安装器 参考 如何升级至 macOS Big Sur - Apple 支持 获取 Big Sur 安装镜像。  ","date":1541759489,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1541759489,"objectID":"53dbf0b0bd819fc258e0a9a2565b626f","permalink":"/2018/11/09/ht0022-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84-macos-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/","publishdate":"2018-11-09T10:31:29Z","relpermalink":"/2018/11/09/ht0022-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84-macos-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/","section":"post","summary":"您可以将磁盘镜像用作安装 Mac 操作系统的启动磁盘。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。升级 macOS 或重新安装 macOS 不需要安装器，但如果您在多台电脑上安装 macOS 时，可引导安装器就会很有用。\n创建可引导安装器需要满足的条件  备用宗卷（格式化为 Mac OS 扩展格式），至少有 13 GB 可用储存空间 已下载 macOS Big Sur、Catalina、Mojave、High Sierra 或 El Capitan 的安装器  下载 macOS   下载：macOS Big Sur、macOS Catalina、macOS Mojave 或 macOS High Sierra 这些内容将作为名为“安装 macOS [版本名称]”的 App 下载到您的“应用程序”文件夹。如果安装器在下载后打开，请退出而不要继续安装。要获取正确的安装器，请从运行 macOS Sierra 10.","tags":["macOS"],"title":"HT0022 如何创建可引导的 macOS 安装镜像","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"通过 PCI Utilities 可以获取到 Mac 操作系统下所有 PCI 设备信息。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n在“终端中”使用 lspci 命令 lspci 需要用到 AppleACPIPlatformExpert，需要在内核调试模式下才可运行\n 安装 PCI Utilities。 进入 macOS 恢复模式，进入“实用工具”菜单中的“终端”。如果当前 macOS 开启了 SIP (e.g. El Capitan, Sierra)，请在终端中键入或粘贴以下命令以关闭 SIP。  csrutil disable  在“终端“键入或粘贴以下命令。通过 nvram 命令以 Verbose Mode 启动操作系统，同时打开内核调试特性。  nvram boot-args=\u0026quot;-v debug=0x144”  完成后，请退出“终端”，并重启系统。 重启完进入系统后，此时 lspci 即可使用。  使用 lspci 获取 PCI 设备信息  在“终端”键入或粘贴以下命令。  sudo /usr/local/sbin/lspci -tv  根据提示键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不显示任何字符。 以 MacBookPro12,1 为例，可以看到所有 PCI 设备列表。  -[0000:00]-+-00.0 Intel Corporation Broadwell-U Host Bridge -OPI +-02.0 Intel Corporation Iris Graphics 6100 +-03.0 Intel Corporation Broadwell-U Audio Controller +-14.0 Intel Corporation Wildcat Point-LP USB xHCI Controller +-15.0 Intel Corporation Wildcat Point-LP Serial IO DMA Controller +-15.4 Intel Corporation Wildcat Point-LP Serial IO GSPI Controller #1 +-16.0 Intel Corporation Wildcat Point-LP MEI Controller #1 +-1b.0 Intel Corporation Wildcat Point-LP High Definition Audio Controller +-1c.0-[01]-- +-1c.1-[02]-- +-1c.2-[03]----00.0 Broadcom Limited BCM43602 802.11ac Wireless LAN SoC +-1c.4-[05-ff]-- +-1c.5-[04]----00.0 Samsung Electronics Co Ltd Device a801 +-1f.0 Intel Corporation Wildcat Point-LP LPC Controller +-1f.3 Intel Corporation Wildcat Point-LP SMBus Controller \\-1f.6 Intel Corporation Wildcat Point-LP Thermal Management Controller  在“终端”键入或粘贴以下命令，可以获取到网卡信息。  sudo /usr/local/sbin/lspci | grep Network 03:00.0 Network controller: Broadcom Limited BCM43602 802.11ac Wireless LAN SoC (rev 01)  对于关闭了 SIP 的情况下，出于安全考虑，有必要在完成以上必要步骤后再次开启 SIP，进入恢复模式，在“终端”键入以下命令。  csrutil enable  进一步了解 要进一步了解 lspci 命令，在终端中输入 sudo /usr/local/sbin/lspci -h 或者查阅 PCI Utilities 项目主页。\n","date":1545906689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1545906689,"objectID":"df67adbd277206ae911cbc7eab947cde","permalink":"/2018/12/27/ht0025-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%A3%80%E8%A7%86-pci-%E8%AE%BE%E5%A4%87/","publishdate":"2018-12-27T10:31:29Z","relpermalink":"/2018/12/27/ht0025-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%A3%80%E8%A7%86-pci-%E8%AE%BE%E5%A4%87/","section":"post","summary":"通过 PCI Utilities 可以获取到 Mac 操作系统下所有 PCI 设备信息。\n以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。\n在“终端中”使用 lspci 命令 lspci 需要用到 AppleACPIPlatformExpert，需要在内核调试模式下才可运行\n 安装 PCI Utilities。 进入 macOS 恢复模式，进入“实用工具”菜单中的“终端”。如果当前 macOS 开启了 SIP (e.g. El Capitan, Sierra)，请在终端中键入或粘贴以下命令以关闭 SIP。  csrutil disable  在“终端“键入或粘贴以下命令。通过 nvram 命令以 Verbose Mode 启动操作系统，同时打开内核调试特性。  nvram boot-args=\u0026quot;-v debug=0x144”  完成后，请退出“终端”，并重启系统。 重启完进入系统后，此时 lspci 即可使用。  使用 lspci 获取 PCI 设备信息  在“终端”键入或粘贴以下命令。  sudo /usr/local/sbin/lspci -tv  根据提示键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不显示任何字符。 以 MacBookPro12,1 为例，可以看到所有 PCI 设备列表。  -[0000:00]-+-00.","tags":["macOS"],"title":"HT0025 如何在 macOS 上检视 PCI 设备","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"如何获取 ipa 要获取应用下载链接，在未越狱的情况下，由于每一个 ipa 都和 Apple ID 绑定，并且有 Apple 的签名，所以必须要通过官方途径配合 Apple 账号下载。在 Windows 上可以直接通过 iTunes 方式获取 ipa，而在 macOS 上目前有两种获取 ipa 方式：\n iTunes Apple Configurator  ipa 的下载流程 iTunes 的 ipa 下载流程 在 iTunes 下，一次购买下载 ipa 的流程由一个发往服务器为 buy.itunes.apple.com、Path 为 WebObjects/MZBuy.woa/wa/buyProduct 的请求作为开始。构造请求时会向 appExtVrsId 字段注入 Build 号，来指定获取具体某个版本的 ipa（默认为最新上架的一个 Build Number），再利用 GUID 和 DSID 生成 kbsync 请求鉴权信息，完成 Request 构造。收到 Response 之后，分析 Response Body 中的 XML 文件，可以找到包含签名后的下载链接，iTunes 利用这个链接完成 ipa 的下载，链接的形式如下所示。\nhttps://iosapps.itunes.apple.com/itunes-assets/Purple114/v4/bf/36/04/bf360426-5231-2db4-ff0b-430c788ec5c6/pre-thinned13659119744838198600.lc.7948000812590706.EOTME2CVXCUZU.signed.dpkg.ipa?accessKey=${accessKey}  可以看到请求的 ipa 为 pre-thinned13......ipa；Path 为 itunes-assets/Purple114/v4/bf/36/04/bf360426-5231-2db4-ff0b-430c788ec5c6，由于同一个应用，不同设备的 ipa 包都是不同的，所以文件服务器上必然有大量包含了 pre-thinned 的 ipa，所以 hash 过的 Path 可用于文件索引加速，但会使得反向推算特定版本特定设备的 ipa 变得几乎不可能；accessKey 为 public key 且具有时效性，用于文件访问鉴权。\n综上可以得知 ipa 文件路径难以推测，并且请求具有实效性，因此在 Response 处没有太多的可挖掘的点。而将 appExtVrsId 这个字段作为切入点是比较合理的。\nApple Configurator 的 ipa 下载流程 在 Apple Configurator 2 中，苹果针对请求做了修改 Path 变为 WebObjects/MZFinance.woa/wa/volumeStoreDownloadProduct，请求的 Plist 如下所示。\n\u0026lt;key\u0026gt;guid\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${guid}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;kbsync\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${kbsync}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;salableAdamId\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;414478124\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;serialNumber\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${serialNumber}\u0026lt;/string\u0026gt;  可以发现并没有字段可以来指定版本信息，一筹莫展。\n通过 iTunes 获取 ipa  2020 年 03 月 18 日 后，从 iTunes 12.6.5 的 App Store 下载应用会直接 SSL 握手失败，iTunes 的方式失效。   自 macOS Mojave 之后，iTunes 的 App Store 的功能就逐渐淡出舞台了，iTunes 12.6.5.3 是最后一个可以浏览 App Store 的 iTunes 版本。\n安装 iTunes 12.6.5.3 在 Mojave 之后安装 iTunes 会受到限制，需要绕过校验系统版本的 iTunes Installer，直接提取安装包内部的 iTunes.app 移至 /Applications 使用。在 macOS Mojave 10.14.4 之后，苹果直接对 iTunes 版本做了限制，打开 iTunes 会提示你当前系统不支持 12.6.5，这时候需要提高 info.plist 里的版本号绕过 macOS 的校验，可以使用 Apple Script 来完成上述步骤。\n 针对历史版本的 iTunes，以及其残留物无法删除干净的情况下，可以使用如下 shell 脚本。\n 完成安装后，如果启动 iTunes 时提示 \u0026ldquo;iTunes Library.itl\u0026rdquo; 错误，则需要移除 Music 目录下 iTunes 文件夹内 iTunes Library.itl 文件。此外也可以通过 Retroactive 安装 iTunes，同样也包括其他被苹果删除的内建应用。\n从 iTunes 抓取下载数据 以 Charles 为例，按照以下步骤进行下载地址抓取\n 打开 Charles，配置证书打开，SSL Proxying 加入 *.apple.com。 开 iTunes，选择一个应用下载，以 WeChat 为例。 在 Charles 中过滤 path 为 WebObjects/MZBuy.woa/wa/buyProduct 的请求，添加 breakpoints。 查看 Response Body 中 XML 字段 softwareVersionExternalIdentifiers，该数组包含了所有可下载的 Build 号。  \u0026lt;key\u0026gt;softwareVersionExternalIdentifiers\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; ... \u0026lt;integer\u0026gt;717062721\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;719842773\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;726302660\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;746082682\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;811222902\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;811530944\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;811669817\u0026lt;/integer\u0026gt; \u0026lt;integer\u0026gt;811953630\u0026lt;/integer\u0026gt; ... \u0026lt;/array\u0026gt;  根据 MIXRANK 查询版本对应的 Build 号。    Build Number  取消之前的下载，并再次下载触发断点，编辑 Request，将请求的 appExtVrsId 字段的值替换成对应的版本号，并 Excute。  \u0026lt;key\u0026gt;appExtVrsId\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;830005675\u0026lt;/string\u0026gt;  完成下载之后可得到指定版本的 ipa。  使用 Apple Configurator  暂时还未找到通过 Apple Configurator 2 降级的方法   安装 Apple Configurator 2 点击链接 从 Mac App Store 直接安装 Apple Configurator 2\n如何从 Apple Configurator 2 抓取下载数据 首先从 Apple Configurator 2 发起下载请求，以 WeChat 为例，选择 WeChat 点击 Add。\n  WeChat  从 Apple Configurator 2 抓取下载数和 iTunes 的唯一区别点在于断点的位置，如下图所示。\n  Break Point  其余流程在理论上没有任何区别，但如“Apple Configurator 的 ipa 下载流程”中所述，核心在于如何修改版本，暂时还没找到方法，目前苹果应该是把 Build Number 查询与修改这一步放到了服务端。\n安装 ipa 使用 Apple Configurator 2，添加一个 App，点击 Choose from my Mac 选择上一步骤中抓取到的 ipa。\n  Install IPA  按步骤安装完成 ipa 的部署即可。\n进一步了解  iTunes 12.6.5.3 on MacOS Catalina 10.15 DSID 使用 iTunes 在业务环境中部署应用 Updating apps using iTunes 12.6.5.3 iTunes 12.6.5 Apps don’t download since 18/03/2020 Public-key cryptography  ","date":1528991056,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1528991056,"objectID":"3d80901841b3b847b2466e41ea07b31f","permalink":"/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/","publishdate":"2018-06-14T15:44:16Z","relpermalink":"/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/","section":"post","summary":"移动端应用在不断迭代过程中，和最初的样子渐行渐远，有变得更好的，也有变得愈来愈糟糕的，所以降级 iOS 应用版本就变成了一个潜在的需求。","tags":["iTunes","Apple Configurator 2","macOS","iOS"],"title":"HT0026 未越狱如何降级 iOS 应用版本","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 26.01) 生物学, 常规. 26.05) 微生物学和免疫学.  26.0503) 医学微生物学和细菌学. 进一步了解  Detail for CIP Code 26. Yale University / Yale Combined Program in the Biological and Biomedical Sciences (BBS).  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"7321576aef79dbbc9d6da45128890f9c","permalink":"/cipcode/26/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/26/","section":"cipcode","summary":"4 位数 CIP 代码 26.01) 生物学, 常规. 26.05) 微生物学和免疫学.  26.0503) 医学微生物学和细菌学. 进一步了解  Detail for CIP Code 26. Yale University / Yale Combined Program in the Biological and Biomedical Sciences (BBS).","tags":["CIP"],"title":"生物及生物医学科学","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"进一步了解  Detail for CIP Code 27.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"32cde9b703b3285b21dcfe6b4ba87615","permalink":"/cipcode/27/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/27/","section":"cipcode","summary":"进一步了解  Detail for CIP Code 27.  ","tags":["CIP"],"title":"数学和统计学","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"进一步了解 ","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"bfd7f9fd1a97cc3ff11fd2b675569eef","permalink":"/2019/12/12/bilibili/","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/bilibili/","section":"post","summary":"进一步了解 ","tags":["Financial Data","Earnings Reports"],"title":"Bilibili","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems","macOS"],"content":"文件名  是 .DS_Store 以 (A Document Being Saved 开头 包含 .nosync（大小写不敏感） 是 .ubd 包含 .weakpkg 是 tmp（大小写不敏感） 是 .tmp（大小写不敏感） 是 desktop.ini（大小写不敏感） 以 ~$ 开头 是 Microsoft User Data（大小写不敏感） 是 $RECYCLE.BIN（大小写不敏感） 是 iPhoto Library（大小写不敏感） 是 Dropbox（大小写不敏感） 是 OneDrive（大小写不敏感） 是 IDrive-Sync（大小写不敏感） 是 .dropbox（大小写不敏感） 是 .dropbox.attr（大小写不敏感）  文件的扩展名  是 .tmp 是 .photoslibrary 是 .photolibrary 是 .aplibrary 是 .migratedaplibrary 是 .migratedphotolibrary  进一步了解  How to exclude a sub folder from iCloud drive in macOS Sierra?  ","date":1484092800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1484092800,"objectID":"082bb12c27db93ca4b3d3d2d45612499","permalink":"/2017/01/11/ht0030-%E5%A6%82%E4%BD%95%E5%9C%A8-icloud-%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%87%E4%BB%B6/","publishdate":"2017-01-11T00:00:00Z","relpermalink":"/2017/01/11/ht0030-%E5%A6%82%E4%BD%95%E5%9C%A8-icloud-%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%87%E4%BB%B6/","section":"post","summary":"文件名  是 .DS_Store 以 (A Document Being Saved 开头 包含 .nosync（大小写不敏感） 是 .ubd 包含 .weakpkg 是 tmp（大小写不敏感） 是 .tmp（大小写不敏感） 是 desktop.ini（大小写不敏感） 以 ~$ 开头 是 Microsoft User Data（大小写不敏感） 是 $RECYCLE.","tags":["macOS"],"title":"HT0030 如何在 iCloud 中屏蔽不需要同步的文件","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 31.99) 公园, 娱乐, 休闲, 健身和人体运动学, 其他.  31.9999) 公园, 娱乐, 休闲, 健身和人体运动学, 其他.     进一步了解  Detail for CIP Code 31.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"0a0ee9dd033d712aa35c9b1487784d79","permalink":"/cipcode/31/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/31/","section":"cipcode","summary":"31) [PARKS, RECREATION, LEISURE, AND FITNESS STUDIES.](https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56\u0026cip=31)","tags":["CIP"],"title":"公园, 娱乐, 休闲, 健身和人体运动学","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 36.01) 休闲以及娱乐活动 Leisure and Recreational Activities.  36.0102) 手工艺品与模型制作 Handicrafts and Model-Making.   BANDAI®\n GUNPLA® GUNDAM BASE    AUTOART®\n MC12 FIA GT1 2010    TAMIYA®\n MP4/4    Porsche®\n 保时捷 911 水平 6 缸对置发动机    LEGO®\n LEGO® Super Mario™ 71360 Adventures with Mario Starter Course  Coming Soon on August 1, 2020   71360 Adventures with Mario Starter Course Adventures with Mario Starter Course 71360 | LEGO® Super Mario™ | Buy online at the Official LEGO® Shop US Harley-Davidson® Fat Boy® 10269 | Creator Expert | Buy online at the Official LEGO® Shop US LEGO Technic 42009 Mobile Crane MK II(Discontinued by manufacturer) Rough Terrain Crane 42082 | Technic™ | Buy online at the Official LEGO® Shop US     36.0109) 旅行和探索 Travel and Exploration.   Visual Travels AirPano - Lake Hibara   36.0115) 音乐 Music. Apple Music - Musish: Apple Music\u0026hellip;ish\n进一步了解  Detail for CIP Code 36.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"944f28f1a2ff1d2403d3bd0d479f5c04","permalink":"/cipcode/36/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/36/","section":"cipcode","summary":"36) [LEISURE AND RECREATIONAL ACTIVITIES.](https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56\u0026cip=36).","tags":["CIP"],"title":"休闲以及娱乐活动 LEISURE AND RECREATIONAL ACTIVITIES","type":"book"},{"authors":["徐旭栋"],"categories":["Finance and Financial Management Services","Finance, General"],"content":"","date":1576108800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576108800,"objectID":"813a5ce03c883a42cf402cd2fb1799f7","permalink":"/2019/12/12/lukkin-coffee/","publishdate":"2019-12-12T00:00:00Z","relpermalink":"/2019/12/12/lukkin-coffee/","section":"post","summary":"","tags":["Financial Data","Earnings Reports"],"title":"Lukkin Coffee","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 45.01) 社会科学, 常规 Social Sciences, General.  45.0101) 社会科学, 常规 Social Sciences, General. Social sciences Specializations and courses explore how populations form laws, make decisions, behave in groups, and structure their communities. From education to economics to law, courses in the social sciences will improve your understanding of the dynamics between individuals and groups, and your ability to analyze behaviors and trends.\n Social Sciences Online Courses | Coursera  THE SOCIAL-ENGINEER TOOLKIT (SET)\n45.06) 经济学.  45.0601) 经济学, 常规.  45.0602) 应用经济学.  45.0603) 计量经济学和定量经济学.  45.0604) 发展经济学和国际发展.  45.0605) 国际经济学.  45.0699) 经济学, 其他.  Nash Equilibrium Non-Zero-Sum Games Pareto Optimality  进一步了解  Detail for CIP Code 45.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"e66745e54fab7ec7683ff6e13910022b","permalink":"/cipcode/45/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/45/","section":"cipcode","summary":"45) [SOCIAL SCIENCES](https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56\u0026cip=45).","tags":["CIP"],"title":"社会科学 SOCIAL SCIENCES","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 50.04) 设计和应用艺术 Design and Applied Arts. Arts and Humanities\nSpecializations and courses in the arts and humanities (including fine arts, history, and philosophy) explore the historical context of creative works and teach you to review source material critically, draw connections between diverse ideas, and evaluate evidence and arguments. Coursework in this field will help you become a better reader, thinker, artist, and writer.\nUniversity\nArts and Humanities | Harvard University\nCourses\nArts and Humanities Online Courses | Coursera\n 50.0404) 工业与产品设计 Industrial and Product Design. UI and UX Design\nUI / UX Design Specialization\nCourses\nUI / UX Design | Coursera\nDesign Material\nAdobe - Download Creative Cloud apps\nWebsite\n Projects | Lea Verou Bēhance   50.0410) 插画 Illustration. James Richards Sketchbook\n   50.0411) 游戏与互动媒体设计 Game and Interactive Media Design. Music\n Vizzed.com  Shining Soul\n Shining Soul II OST Soundtrack - Shining Soul II OST Soundtrack  50.06) 电影, 录像和摄影艺术 Film, Video and Photographic Arts.  50.0601) Film/Cinema/Video Studies. [FILMGRAB]\n  50.0605) Photographer 摄影.   Takashi Yasui\n  50.09) 音乐 Music.  50.0999) 音乐, 其他 Music, Other. AIDN\ndaniwell\nmikutap\n进一步了解  Detail for CIP Code 50.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"38fae999226ebb24e2d443dd3979b998","permalink":"/cipcode/50/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/50/","section":"cipcode","summary":"50) [VISUAL AND PERFORMING ARTS.](https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56\u0026cip=50)","tags":["CIP"],"title":"视觉和表演艺术 VISUAL AND PERFORMING ARTS","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 51.12) 医学.  51.1201) 医学.  51.1299) 医学, 其他.    徐旭栋  (2019). 鼻炎与鼻窦炎全解析.     进一步了解  Detail for CIP Code 51.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"941995d30392dffab05bc630a6b048ba","permalink":"/cipcode/51/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/51/","section":"cipcode","summary":"4 位数 CIP 代码 51.12) 医学.  51.1201) 医学.  51.1299) 医学, 其他.    徐旭栋  (2019). 鼻炎与鼻窦炎全解析.     进一步了解  Detail for CIP Code 51.","tags":["CIP"],"title":"健康专业和相关项目","type":"book"},{"authors":null,"categories":["The Classification of Instructional Programs"],"content":"4 位数 CIP 代码 52.01) 商业/贸易, 常规. 52.03) 会计和相关服务.  52.0301) 会计.  CPA® Certified Public Accountants CAS GAAP HKFRS IFRS   52.0303) 审计. 52.08) 财务和财务管理服务.  52.0801) 财务, 常规.    徐旭栋  (2015). 投资者关系 Investor Relations.     进一步了解  Detail for CIP Code 52.  ","date":1435746689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1435746689,"objectID":"ddc83a08fbaea2597d2d719982445d56","permalink":"/cipcode/52/","publishdate":"2015-07-01T10:31:29Z","relpermalink":"/cipcode/52/","section":"cipcode","summary":"4 位数 CIP 代码 52.01) 商业/贸易, 常规. 52.03) 会计和相关服务.  52.0301) 会计.  CPA® Certified Public Accountants CAS GAAP HKFRS IFRS   52.0303) 审计. 52.08) 财务和财务管理服务.  52.0801) 财务, 常规.","tags":["CIP"],"title":"商业, 管理, 营销和其他相关支持服务","type":"book"},{"authors":["徐旭栋"],"categories":["OS. Operating Systems"],"content":"关于 ","date":1613989889,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613989889,"objectID":"b4d89de606e276f7284ca5197d9d793a","permalink":"/2021/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2021-%E6%98%A5/","publishdate":"2021-02-22T10:31:29Z","relpermalink":"/2021/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2021-%E6%98%A5/","section":"post","summary":"关于 ","tags":["OS"],"title":"操作系统 2021 春","type":"book"},{"authors":["徐旭栋"],"categories":["Parks, Recreation, Leisure, Fitness, and Kinesiology, Other"],"content":"序 新的滑板到了\n从零开始了解滑板 滑板大概分为双翘板、小鱼板、大鱼板、长板和柯南板。 双翘板是主流的动作板子，可以带板跳起来做动作。 鱼板方便携带，主要用来代步另外，大鱼和小鱼在板型上没区别，成年人用小鱼板比较难站稳，相对来说更危险，建议成年人用大鱼板，小学生用小鱼板。 长板有舞板和速降板，很重不建议用来代步，虽然很稳。 柯南板是未来科技。\n不同类型的板适用不同的场景，按个人喜好进行选择，刚开始联系时带好护具注意安全即可，如果有毅力坚持练下去的建议亲自配一块专业板一步到位，反之可以考虑组装板。特别不建议购买玩具板，玩具板通常有很多缺点，板面没弹性、轮子大回弹差、桥很脆弱、轴承不顺滑，几个大幅度的动作板可能就断了，其唯一的好处可能就是便宜了。下文主要围绕双翘板展开讨论配件的选择。\nTrucks   以目前的工艺水平来看，桥建议一步到位上进口桥，主流品牌有：\n I 桥 Independent Trucks V 桥 VENTURE TRUCKS T 桥或者叫雷桥 THUNDER TRUCKS D 桥 DESTRUCTO  以出厂硬度来说 Indy 大多为高软桥，V 桥有高有低硬桥，T 桥是低桥，D 桥大多高硬桥。高桥会把板子撑得更高，也能避免轮子太大卡板。板的硬度主要由 PU 决定，PU 全称 Polyurethane，聚氨基甲酸酯。刚接触滑板用硬桥更好，软桥比较考验使用者的平衡能力，从软硬角度考虑硬桥会比较稳，但切记不可通过拧紧主桥螺母来使 PU 变硬，PU 是可能被挤爆的。\n桥的宽度一般要与板匹配，以 I 桥为例：\n   Truck Size Axle Width (in) Deck Size (in)     215 10.00 9.5 - 10.5   169 9.125 9 - 9.5   159 8.75 8.6 - 9   149 8.50 8.375 - 8.6   144 8.25 8.2 - 3.375   139 8.00 7.8 - 8.2   129 7.60 7.4 - 7.8   109 6.90 6.25 - 7.6    例如 8.25 的板子配 144 的 I 桥是最优的，根据材料和结构的不同，I 桥划分了几个系列：\n   TRUCKS Tall Hanger Baseplate Axle Kingpin      STAGE 11 MID 55mm 356 Aluminum 356 Aluminum 4140 Chromoly Grade 8 215 Available   STAGE 11 MID 52mm 356 Aluminum 356 Aluminum 4140 Chromoly Inverted，Grade 8    STAGE 11 HOLLOW 55mm 356 Aluminum 356 Aluminum Hollow Chromoly Hollow Chromoly    STAGE 11 FORGED HOLLOW 53.5mm 356 Aluminum Forged 6061 Aluminum Hollow Chromoly Hollow Chromoly 10% Lighter   STAGE 11 FORGED TITANIUM 53.5mm 356 Aluminum Forged 6061 Aluminum Solid Titanium Hollow Chromoly 15% Lighter    个人用的是 I 桥 144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard。\n  144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard  Deck    侧视图    俯视图 \n比较好的版面有：\n Girl Skateboards Almost Baker SANTA CRUZ Zero Skateboards Element chocolate Boardhead flipskateboards Powell Peralta Anti Hero  进口板一般弹性可以维持数个月以上，国产板稍差一些。木材与结构和胶水是板弹性的决定性因素，木质滑板一由七层枫木用胶水粘合后压制而成，核心在于每一层薄片的选材和质量把关。\n关于压制工艺：\n 热压为加温压制，热压板更适合批量标准化生产，目前热压技术更普及 冷压为常温压制  热压和冷压对板弹性维持时间的影响微乎其微，两个压制的区别仅仅是在压制板的时候加不加温度，个人目前自用 GIRL，弹性很好。\nWheels   动作轮一般是硬轮，硬度在 99A - 105A 左右，直径一般在 52mm - 54mm 偏小，回弹更好做滑板动作。刚开始练习时，硬轮由于硬度关系很容易被小碎石卡住，如果没掌握正确的摔倒姿势的话就会很危险。反之公路轮为软轮，有时也会被叫做刷街轮，通常硬度在 78A 到 90A 左右，公路轮比较大和软一般会配高桥，直径一般在 55mm - 60mm，在公路上不震脚可以压过小石头，相对动作轮更安全舒服。所以建议同时有刷街和做动作需求的备两套轮子，并且由于取轴承是比较麻烦的事情，所以建议每套轮子都配上一套轴承。\n主流轮子品牌有：\n BONES RICTA SPITFIRE WHEELS  对于公路轮由于体积较大，有卡板的风险，高速滑行时卡板会十分危险，通常 56mm 的即可。如果有需求要用更大的轮子比如 60mm，建议高桥再配合桥垫做增高，桥垫同样有避震的作用，可以防止桥把板体压坏。最后对于全能轮这个概念，个人觉得轮子只看硬度和大小，全能轮从硬度来看其实大多都是软轮。\nBearings   轴承的核心在于是否稳定，不容易爆轴，关于轴承的标准有 ABEC-5、ABEC-7、ABEC-9 等，比起数值来说更重要的还是稳定性。轴承比较推荐 Skate One 的 BONES，Skate One 还有另一个轴承品类 MINI LOGO，个人比较推荐 BONES Red，为国内代工。\n更高端的轴承有例如 BONES SWISS 陶瓷轴承，LUCKY 钛合金轴承，不过提升有限，边际效应较明显。\nGrip Tape 砂纸 没用过大牌的砂纸，砂纸个人认为是消耗极快的配件，\n板钉   最普通的配件，没什么好说的，太贵的就是智商税。\n护具 护具该有的还是要有，尤其是刚接触滑板的新人，保护好自己是非常重要的。像滑板、滑雪之类的运动，首要就是要学会如何摔倒，掌握正确的摔倒姿势与方法才能更好的保护自己，护具能够很好的帮助度过这个学习期的，切忌嫌护具丑而不带护具，骨折了可就得不偿失了。\n关于鞋子 不考虑代步，如果是经常做动作的话，鞋底很容易被砂纸磨薄，做动作的建议配一双滑板鞋，比较专业的牌子如下：\n DC Shoes Vans，容易开胶，Pro 系列只推荐联名 Geoff Rowley éS Skateboarding Emerica Etnies CONVERSE FALLEN FOOTWEAR LAKAI DEKLINE FOOTWEAR  养护方法 桥 桥作为最重要的核心大件，零件较多需要分开讲。\n主体 桥作为一个较为耐用的部件，建议进行一定程度的保养。一些桥比如 I 桥的桥轴部分是锻造铬钼钢，空心桥轴内部非常生锈，建议用防锈油进行保养。切忌不要用桥撬轴承，桥的螺纹是很错弱的。\nPU PU 作为减震器，和人的膝盖一样很脆弱，切忌主桥钉螺母不能拧过紧以避免 PU 开裂或者被挤爆，部分选手喜欢拧紧主要是不熟悉过软的桥导致的左右晃动，正确方式是换一个更硬的 PU。\n桥端螺母 侧螺母具有保护桥端螺纹的作用，一旦发现螺母形变或者滑牙需要及时更换，防止支架被的螺纹被螺母损坏。一般建议多备一些侧螺母，经常更换以保护桥主体。\n板面 滑板的板面通常是木制，相对其他的金属件来说会更脆弱，动作板为了保持弹性要注意尽量保持干燥，使用上切忌爱惜板面而放不开，每换一块板意味着你的一次成长。雨雪天的情况下不要玩板，如果不防水的板沾水，木头就会受潮变得酥软，从而失去弹性。\n轴承 轴承是主要的承重部位，轮子受到强烈的冲击后，非常容易被挤压导致爆轴承。同时由于轴承非常贴近地面，间隙之间极易容易进入小的颗粒物，高速旋转的状态下很快就会磨损，顺滑度也会降低，慢慢的就会损坏。此外如果是不防锈的轴承则需要注意进水生锈，如果不小心轮子过水，需要快速转动轮子甩水。\n轴承特别容易藏污纳垢，高端的轴承建议常清洗。轴承清洗时需要把防尘盖拆除，具体方法用曲别针从轴承的另一侧将防尘盖顶出，拆下的防尘盖用水清洗做一下防锈即可。轴承部分可以用 95% 酒精、汽油、煤油等油污易溶溶剂清洗，讲究一点可以配合 Bones 的清洗瓶。清洗轴承的主要目的是去除原本的润滑油脂或者防锈油以及滑行过程中残留的污垢，洗完后去除水分保持干燥然后上润滑油接着使用或者上防锈油储藏，润滑油大同小异，讲究的可以用 Bones 的润滑油。一般新轴承上油脂是用于防止轴承生锈，没有润滑作用，所以在洗完之后需要上润滑油。\n轮子 不怎么容易坏的耗材，变形或者坏了换新即可。\n砂纸 由于砂纸被踩在脚下，所以极其容易脏。砂纸不能用水清洗，会脱沙水失去摩擦力，板就没法被脚带起来。如果觉得没有到要换的程度的话，可以用砂纸擦进行处理，砂纸太脏建议直接更换。\n桥钉 最廉价的部件，不用怎么保养坏了就换。\n总结来说不用过于爱惜板，板存在的价值是用来滑的，板越新越说明是板混。滑板一旦长久搁置就容易受潮生锈，板也会失去弹性，一个玩了很久的板还和新的一样的话，它就失去了灵魂。\n进一步了解  Skateboard TRUCK GUIDE RIDE THE RIGHT SIZE TRUCK CHOOSE THE RIGHT SIZE FOR YOU DESTRUCTO Skate One Skateboard Anatomy 101  Glossary 部件  Deck 板 Truck 桥 Wheel 轮子 Bearing 轴承 Baseplate 底座  Truck  Tall 高度 Axle nut 桥轴端螺母 Axle washers 桥轴端垫片x Axle 桥轴 Hanger 悬轴 Kingpin 转向立轴 Kingpin nut 立轴螺母 Top cup washer 顶部杯形垫圈 Bushing PU 垫 Cone bushing 锥型 PU 垫 Cushing 软垫 Lower cup washer 底部杯形垫圈  材料  Aluminum 铝合金 Chromoly 铬钼钢 Forged Aluminum 锻造铝合金 Hollow Chromoly 中空铬钼钢 Solid Titanium 纯钛 Grade 8 美制 8 级标准 Inverted 倒置  ","date":1599609600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599609600,"objectID":"487eb24633dd00b05c3a3700b793bc93","permalink":"/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/","publishdate":"2020-09-09T00:00:00Z","relpermalink":"/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/","section":"post","summary":"深入了解滑板的各种部件以及如何选择、组装与保养","tags":["Skateboard"],"title":"滑板选配 101","type":"post"},{"authors":["徐旭栋"],"categories":null,"content":"Adobe Fonts Source Serif Source Sans Source Code Pro Microsoft Fonts Cascadia Code    Cascadia Code: standard version of Cascadia Cascadia Mono: a version of Cascadia that doesn\u0026rsquo;t have ligatures Cascadia (Code|Mono) PL: a version of Cascadia that has embedded Powerline symbols    Google Fonts   Google Noto Fonts JetBrains Fonts JetBrains Mono Other Fonts FiraCode     ligatures cheatsheet  geomanist   进一步了解  tonsky/FiraCode.  ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1571097600,"objectID":"c229249348bf83f64f1a6832773a6d44","permalink":"/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/","section":"post","summary":"Typefaces 索引","tags":["Typeface"],"title":"Typefaces 索引","type":"post"},{"authors":["徐旭栋"],"categories":["Gossip"],"content":"序 谈起这个博客，建立之初只是为了记录一些技术相关的话题，用来沉淀一些日常学习的技术知识点以及做备忘用。随着时间流逝已经 5 个年头了，写作也变成了一个习惯保持了下来，也不断的尝试从原来的计算机科学学术类逐渐扩大到 STEM 乃至其他的各类型的文章。\n \u0008创篇号 (2014)   随着不断的学习与深入，就越发会觉得自身各类知识面的狭窄与片面，潜在的求知欲被这种外在的驱动力所激发，促使着你不断挖掘知识的深度与拓宽学术广度。在写作过程中，如何组织与管理跨学科文章，如何针对选题主旨拿捏文本表现形式成为了不小的问题。由于理工科和文科在学术侧重上的区别会导致行文风格和段落组织大相径庭，比如 STEM 更强调数理逻辑和科学证明，会以各类图表和数据来增加文本说服力；在文章的选题上存在强调客观事实的文档或者说明类，也存在发表个人观点的强主观意愿的内容，不同的文章会有不同的处理方式，后续有机会抽几个章节赘述。\n为什么要写文章 就如美国物理学家约翰·阿奇博尔德·惠勒所说：\n “One can only learn by teaching.” — John Archibald Wheeler\n 以教为学是一个很好的学习方法，如果一个复杂深奥的问题能用直白浅显的语言讲清楚并传授给他人，那么说明这个知识点已经被学习者真正理解并运用。通常这么做可以促使你剖析知识要点，用你自己对领域知识的了解程度去做易懂的总结，这个过程会促使你回顾你学习过的内容，对知识盲区进行查漏补缺，直到最终能够用大白话、最简单的术语去描述并让人听懂。从个人角度来说，写文章的本质就是学习的沉淀，沉淀的目的是为了提炼再利用，这个过程就是一个知识的提炼总结以及教授传递。就好比字典、词典存在的意义：\n 提供语言领域内的使用指南 字、词汇、语言的知识点速查 知识的传递  写文章简单，写出有深度的文章难，写出即易懂又有深度的文章是难中之难。只学不沉淀必然会遗忘，再次遇到同样的问题就需要花时间重新回忆或直接踩坑，这就是写作与沉淀的目的。同样，在提炼沉淀之余，分类与索引也是必不可少的，上文提到写作的重要目的之一是再利用，如果只是写了文章而从不去使用，那就好比把一篇很有营养的文章加入了你的收藏夹，心想下次一定能用到，渐渐的你就会发现收藏夹越来越臃肿难以管理，最终变成你成长过程中的过客，这样的场景是不是似曾相识。\n所以本博客的所有文章会以忽略选题的内容为前提，把文章内容涉及到的学科领域作为类别归属，在此基础上以 CIP 的策略作分类化管理，使得学科特定的知识点查找与索引会非常简便。\n写作工具 博客系统 Hugo 开发者文档\nDocs\nHexo 关于 Hexo 的搭建可以参考  徐旭栋  (2014). 用 Hexo 搭建个人博客.   用富媒体润色文本 图标 flaticon\n图床 出于各种目的，比如减少服务器的压力、加快加载速度、减少发布包的体积等，图片资源会通常以 CDN 的形式来存储与部署，这里就要用到各种 CDN 服务。\n  GitHub user-images 在 GitHub 提 issue 时添加图片，GitHub 会将图片资源会分发至 CDN，生成地址为 user-images.githubusercontent.com/{path}/{hash} 的链接，从某种角度来看 GitHub 可以用来作图床。\n  用更强说服力的图表代替语言 Mermaid Mermaid 是一个集流程图、状态图、时序图、甘特图绘制库，使用 DSL 代码就可以绘制出漂亮清晰的图片，配合上 markdown 是 STEM 相关文章的利器，同时提供了在线编辑器提供实时预览。\nPlotly Plotly 是一个通过 JSON 作为数据源的图标绘制工具，并且提供了可视化在线编辑工具。\n文章的表现力 表现力需要更具选题的内容来作具体调整。\nSTEM 进一步了解    徐旭栋  (2014). 创篇号.     ","date":156816e4,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":156816e4,"objectID":"f3ca8c5f29d1cb5eef704fa5b0ec37b5","permalink":"/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/","publishdate":"2019-09-11T00:00:00Z","relpermalink":"/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/","section":"post","summary":"善用写作工具以及表现手法","tags":["Essay"],"title":"如何写出一篇好博文","type":"post"},{"authors":["徐旭栋"],"categories":null,"content":"鼻炎 鼻炎和咽炎有着密切的联系，临床上治咽炎先治鼻炎的病例很多，因为人体的五官是相通的，咽炎主要是由于咽喉位于呼吸道与消化道的要冲。长期鼻塞、张开呼吸造成干冷空气直达喉部而产生干痛。而粘稠痰常附于咽喉壁克引起刺激性咳嗽，甚至引起恶心、干呕。长期鼻涕倒流刺激咽喉引起咽喉炎如异物感、咽痒、灼热、干燥、微疼等。\n鼻炎是特别让人不舒服的病，得了鼻炎，呼吸不顺畅，连睡觉都睡不好真是让人烦恼。在大城市中，每十个人里面，就有一个是鼻炎患者，久治不愈很容易变成致死性的鼻咽癌，鼻咽癌是我国高发恶性肿瘤之一，发病率为耳鼻咽喉恶性肿瘤之首。全世界 80% 的鼻咽恶性肿瘤是鼻炎久治不愈恶化所致。鼻咽癌的表现为病侧耳鸣且逐渐加重，并伴有听力下降。鼻炎的主要危害有儿童毁容、学生智商降低、女性对生育造成严重影响、男性增加患高血压的风险、老年人危害生命。鼻炎是一种常见病，同时也是一种危险的疾病，如不及时治疗就会导致多种并发症如慢性鼻炎、鼻窦炎等。\n2017 年 11 月 29 日星尚频道 X 诊所节，主题《鼻炎知多少》，嘉宾刘环海，第二军医大学附属长征医院耳鼻咽喉头颈外科科室主任，上海市耳鼻咽喉头颈外科学会常委兼秘书长。\n鼻窦炎病理   窦道堵塞 症状缓解 通常来说，窦道堵塞是由于鼻窦黏膜水肿导致。在不借助手术、洗鼻等外部手段的情况下，缓解堵塞的方法通常是以加速鼻腔部位的血脉循环为主要手段，所以鼻窦炎患者在一些特定的场景下，可能会出现窦道短暂的通畅，包括但不限于：\n 精神紧张或者突然收到惊吓，交感神经的兴奋会使得血管收缩 就寝时单侧窦道堵塞，采用对侧卧位睡姿，堵住侧会变得通畅 进行运动之后，运动会使得全身血液更加循环畅通，通常窦道缓解的时间会相对更长，运动对于鼻窦炎以及自身免疫会有很大帮助  日常对脸部的穴位按摩也能促进血液循环，包括迎香穴和两眉之间，额窦的部位就是在眉间偏上部位，其带来效果的通畅常常持续几分钟左右。血液循环畅通了，黏膜水肿自然会暂时缓解，更多可以参考下方视频。\n  注意事项 鼻窦炎患者要注意尽量避免接触突然的冷空气或者其他刺激性气味或者各类过敏源。\n","date":1557532800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557532800,"objectID":"8bf89e70664f7b15b1790e31a29fdbd9","permalink":"/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/","publishdate":"2019-05-11T00:00:00Z","relpermalink":"/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/","section":"post","summary":"Sinusitis 101","tags":["Sinusitis"],"title":"鼻炎与鼻窦炎全解析","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["徐旭栋"],"categories":["Computer Science","Developer Conference"],"content":"TensorFlow 亲儿子 TensorFlow 是本届 GDD 的重点照顾对象，在开幕演讲中一位 Googla AI 的产品经理对 Google AI 的应用落地场景进行了简单的介绍，同时推荐了自家今年三月份的上线的 MLCC，旨在帮助广大爱好者快速无障碍入门 AI，在大幅降低门槛的前提下，使得每个人都能参与到其中。\n     同时一起宣布的还有 Google AI 中国中心会在北京以及上海举行机器学习应用冬令营，并且在可能的情况下会提供 Google AI 工程师的实习机会，将其更好的运用到实战。\n紧接着开幕演讲，主会场在 11:00 召开了面向所有开发者的 TensorFlow 简介。\n  Introduce to Tensorflow  会上介绍了什么是 TensorFlow、它是如何运作的、它该如何使用。介绍了 TensorFlow 这个平台如何更方便的帮助开发者构建要用于人工智能应用中的机器学习模型。\n会上展示了一个 Fashion MNIST 的现场 Demo。\n  Fashion MNIST  具体演示了如何利用 Keras 对 70000 个训练样本、10 个类别进行神经网络训练，包涵 Keras 一系列的：\n Sequential Model 的建立 loss 函数的配置 Optimizer 的选择 Model 的训练方式  大部分演示内容的要点都可以在 Keras Documentation 中找到。\n在 20 号当天下午还有一场《编写机器学习的7个步骤》Keynote 以及 21 号一整天的《TensorFlow 专场》传销大会。内容涵盖了：\n Swift for TensorFlow 以及 tensorflow.js，Swift 版本的 TensorFlow 早在今年 4 月已经开源，笔者感到很欣慰，作为一个 Apple Developer 终于不用担心苹果倒闭后需要面临失业的问题 TensorFlow Lite 允许 App 开发者压缩和优化 TensorFlow 模型，使之能在 Android、iOS 和各种物联网设备上运行，使得在未连接到云端的移动设备上运行智能应用变得可能 TensorFlow 的 DistributionStrategy Class 使得将工作量分散到多个 GPU、多节点训练变得可能，为训练大型机器学习模型提供了实际的解决方案  不过由于时间关系上述的 Keynote 笔者都没能参与，还是非常可惜的。\nFlutter 的磅礴野心 Flutter 可以说是本届 GDD 上的焦点主题，在此次大会上 Google 公布了 Flutter Release Preview 2，距离 Flutter 正式 Release 也变得指日可待。\n  Flutter Release Preview 2  在 20 日当天有关 Flutter 的 Keynote 一共被安排了 4 场，下午 4:45 开始的连续两场的内容关注点都在 Flutter 底层原理剖析以及 High Performance 上，因此笔者选择了去这两场。\n笔者在等待 Keynote 开始的期间，去产品展示区溜达了一圈，溜着溜着就溜到了 Flutter 展台，只见 Flutter 的几个工程师一直被围在人群之中回答问题，周围围观的吃瓜开发者疯狂输出问题，场面异常劲爆。Flutter 展台也是为数不多的吃瓜群众把注意力全放在内容本身而不是礼品和贴纸上的展台了。笔者靠着精致的走位顺利插入展台前排。在实际体验之后发现 Flutter 在运行过程中，除了部分场景下（大部分是 ScrollView 的场景下）出现了不跟手的情况，大部分情况下都十分流畅，在和 Flutter 工程师交流后也得到了解答，无论是 iOS 和 Android 都是基于 Skia 的 API 进行渲染，并且 iOS 底层和安卓一样也是基于 OpenGL ES 实现的，关于 iOS Skia 是如何编译可以参考这篇文档。\n    回到 Flutter 分会场，第一场 Flutter Keynote 的主题是《剖析你的 Flutter App》。整场 Keynote 围绕着什么是性能展开。通过横向对比双平台的 Render Architecture 异同，纵向对比 Native 与 JS 调用 Native API 的产生的不必要的性能损耗，最终引出 Flutter 渲染理念，更少的计算量带来更多的性能提升。\n      不过虽然听上去很美好，但是 Flutter 的性能表现实际上是与开发者的实现息息相关。Flutter 和大部分视图渲染架构一样也是通过遍历树去寻找渲染节点，存在节点遍历即存在性能损失，而这部分性能损失需要开发者手动去优化，官方在 Build 与 Paint 这两个 Phase 中结合现场演示给出了几条性能优化的实战建议：\n如何提高 Build 效率？\n  尽量降低遍历的出发点\n 通过标脏 setState 来实现 通过 InheritedWidget 来传递 state 热重载    重用同一子组件实例\n 能有效的做到在遍历至子组件时做到停止遍历    如何提高 Paint 效率？\n 设置 RepaintBoundary，在整个绘制树产生一次重绘时，通过 RepaintBoundary 来阻断重绘的区域    因此性能优化的重任落到开发者的身上了，又是一项体力活。在整个演示过程中使用到了一部分 Profile 工具以及 Debug Flag 来监测 App 的 Performance，具体可以在 Flutter Performance Profiling 以及 Debugging Flutter Apps 找到。\n到了第二场 Keynote 上来了个幽默的老哥，这场的主题是《深入介绍 Flutter Graphics 性能》。\n  深入介绍 Flutter Graphics 性能  在进行了一轮 Skia 牛逼吹爆后，进入正题，主要内容围绕着通过分析绘图指令来不断优化 App 的性能。Flutter 的渲染原理是将一个渲染帧录制成 SkPicture (skp) 提交给 Skia 进行渲染，利用这个特点，通过捕捉一帧 skp，配合 Skia Debugger，可以精确分析到单个渲染帧中每一条绘图指令，整场 Keynote 大部分时间都花在现场演示优化，具体不在此赘述。\n    值得一提的是，在实际调试过程中，官方不推荐且极其不推荐使用 iOS 模拟器进行调试，理由是 Skia 在 iOS 模拟器使用 CPU 作为渲染后端，和真机的 GPU 后端会有较大的性能上的出入。\nAndroid 把路走宽了 随着业界毒瘤果的 iPhone X 开卖，国内各大安卓厂商也纷纷跟风推出刘海屏的机器，说实话笔者个人认为刘海屏这个设计真的很丑。面对这么一大波国产刘海屏手机，谷歌非但没置之不理，反而却十分接地气的在 Android 9 中添加了刘海屏的适配方案显示屏缺口支持，颇有大厂风范。\n在 Android 9 中利用 DeepMind 通过对 App 进行使用频率分组来尽可能降低 CPU 唤醒频率以达到延长电池的续航能力，官方称唤醒频率被有效的降低了 30%。\n  Android Battery  对于非 SDK 接口的调用在 Android 9 会被限制，具体可以参考对非 SDK 接口的限制，旨在提高应用的稳定性。\n  Android SDK Restrict  Google 在 2018 Google I/O 上发布了新的框架组件 JetPack，今次在 GDD 上再次拿出来发酵一下，大致如上图所示。其中的 Navigation 和 iOS 中的 Storyboard 有着异曲同工之妙。JetPack 包含了大量的简化开发的新框架，具体可以参考官方文档 Android Jetpack。\n  Android JetPack  Google 通过 Android App Bundle 进行 apk 的动态分发，以提供 apk 的瘦身效果。在 iOS 中有类似的 On Demand resource，但比起 Android App Bundle] 有着更多的局限性。\n  Android APP Bundle  还有 WearOS、Firebase、ARCore WearOS WearOS 在这届 GDD 上更多的是商业上的介绍，广告以及产品上的介绍比较多，在开幕式上也花了一定的篇幅去介绍 WearOS 的合作伙伴以及品牌。与开发者相关的有《Wear OS 表盘开发入门》以及《Wear OS 应用开发入门》，由于时间有限没有前去与会。\n  ARCore  ARCore ARCore 也是本届 GDD 的焦点之一，ARCore 是 Google 的增强现实体验构建平台。 ARCore 利用不同的 API 让您的手机能够感知其环境、了解现实世界并与信息进行交互。今次 Google 一共安排了 2 场 Codelab 以及 4 场面向开发者的 Keynote 来帮助开发者更快更平滑的入门 ARCore 开发，非常遗憾的是笔者没有更多的时间去参与到其中。\nFirebase 这次大会上重点介绍了下 Firebase 的 Realtime Database，看上去和 CloudKit 差不多，主要的重点还是之后的 ML Kit for Firebase。结合了 ML Kit 的 Firebase 在 TensorFlow Lite 助力下，App 可以动态加载训练模型而非直接打包在 App 中，从而达到模型热升级的目的，对中小型开发团队来说是相当有好的。\n  ML Kit  最后 总得来说，这次 GDD 还是收获不小，Google 给予了开发者对于未来技术的引导、解答以及分享。技术分享有深有浅，还有许多非开发相关、针对商业市场的 Keynote 可供选择。未来 TensorFlow 依然是 Google 的绝对重点，Android 的整个生态越发趋于完善与规范，Flutter 蓄势待发准备大一统。不过比较可惜的是今年没有 IoT 的开发版可以拿，期待明年的 GDD。\n  終わり  ","date":1537434e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1609718400,"objectID":"4bda9fddaea1c8abbee1b7144a0108d0","permalink":"/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/","publishdate":"2018-09-22T04:19:00Z","relpermalink":"/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/","section":"event","summary":"了解 Google 创新技术，与 Google 全球产品专家面对面，亲身体验 Google 产品","tags":["Tensorflow","Firebase","Flutter","ARCore","GoogleIO"],"title":"Google Developer Days China 2018 参会记录","type":"event"},{"authors":null,"categories":null,"content":"我们收集哪些信息 通常，您能在匿名的状态下访问本网站网并获取信息。当我们需要能识别您的个人信息或者可以与您联系的信息时，我们会征求您的同意。\n","date":1530140400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1530140400,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"/privacy/","publishdate":"2018-06-28T00:00:00+01:00","relpermalink":"/privacy/","section":"","summary":"我们收集哪些信息 通常，您能在匿名的状态下访问本网站网并获取信息。当我们需要能识别您的个人信息或者可以与您联系的信息时，我们会征求您的同意。","tags":null,"title":"隐私条款","type":"page"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"进一步了解  protocolbuffers/protobuf: Protocol Buffers . Protocol Buffers | Google Developers.  ","date":1525564800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1525564800,"objectID":"339243e54793097ced4570730e3d1b4b","permalink":"/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/","publishdate":"2018-05-06T00:00:00Z","relpermalink":"/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/","section":"post","summary":"Protobuf 详解","tags":["Protobuf"],"title":"深入了解 Protocol Buffers","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"进一步了解  QUIC: A UDP-Based Multiplexed and Secure Transport. QUIC Tutorial. The Road to QUIC. QUIC, a multiplexed stream transport over UDP.  ","date":1497484800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1497484800,"objectID":"aca6095c697839e9f73c103006022397","permalink":"/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/","publishdate":"2017-06-15T00:00:00Z","relpermalink":"/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/","section":"post","summary":"QUIC 传输协议详解","tags":["HTTP"],"title":"深入了解 QUIC Transport Protocol","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"Hypertext Transfer Protocol Secure，超文本传输安全协议，又称 HTTP over TLS。是经由 HTTP 进行通信，并利用 SSL/TLS 来加密。HTTPS 主要目的是为了提供对服务器的身份认证，与传输过程中的数据完整性不被篡改，最早由网景（Netscape）在 1994 年提出，应用在网景领航员浏览器中。\nHTTP 在作数据传输协议使用时，由于是明文传输无任何安全保证，会存在内容被窃听的问题；由于没有身份认证机制，通信过程中会面临中间人攻击，例如数据被篡改、服务器身份伪装等。正因为 HTTP 存在这些风险问题才诞生了 HTTPS。\nHTTPS 本质上是一个复合协议，由 HTTP、TSL/SSL、TCP 协同工作，因此会涉及到较多领域的内容比如密码学、公钥与私钥、加密与认证、数字证书、数字签名等。\n此外 HTTPS 可能会与 RFC 2660 中的安全超文本传输协议 S-HTTP 相混淆。两者都为 HTTP 安全传输的实现，S-HTTP 为应用层协议，主要对传输内容加密；HTTPS 的核心为 SSL/TSL，SSL/TSL 协议位于传输层与应用层之间，确保整个通信过程都是安全的。\nHTTPS 通信流程 如上文所述，HTTPS 是对 HTTP 的扩展，由三部分组成，通信流程可以简化为：\n 通信双方通过三次握手建立 TCP 连接 通信双方通过四次握手建立 TLS 连接 HTTP Client 向 Server 发送请求，Server 响应返回 Response  sequenceDiagram autonumber participant Client participant Server rect rgb(191, 223, 255) Client -\u0026gt;\u0026gt; Server: Request https://www.google.com note right of Server: Encrypt Algorithm\u0026lt;br/\u0026gt;Hash Algorithm end rect rgb(200, 150, 255) Server-\u0026gt;\u0026gt;Client: Return Certificate Client-\u0026gt;\u0026gt;Client: Is Certificate Valid? Note over Client, Server: Invalid, show prompt. Client-\u0026gt;\u0026gt;Client: Is Valid, Random Magic Number R. Client-\u0026gt;\u0026gt;Client: Encrypt R with Public Key In Certificate end rect rgb(191, 223, 255) Client-\u0026gt;\u0026gt;Server: Transfer Encrypted R to Server Server-\u0026gt;\u0026gt;Server: Decrypted R with Private Key Server-\u0026gt;\u0026gt;Server: Encrypt Content with R end rect rgb(200, 150, 255) Server-\u0026gt;\u0026gt;Client: Return Encrypted Content Client-\u0026gt;\u0026gt;Client: Decrypt Content with R end  建立 TCP 链接 更多关于 TCP 的内容从以下这篇文章进一步了解。\n 徐旭栋  Wed, May 03, 2017   1 分钟阅读时长   CIP 11.07) Computer Science , 11.0701) Computer Science   NC. Networking and Communication  深入了解 TCP  TCP 详解\n   RFC 793    建立 TLS 链接 建立 TCP 链接后需要进行 TLS 握手，以浏览器和服务器的通信为例，通常 HTTPS 做单向认证，用于鉴别服务端的真伪，简化流程的如下：\n 浏览器向服务器的 TLS 端口（一般为 443）发起请求，此次请求携带了支持的加密算法和哈希算法。 服务器收到请求，选择浏览器支持的加密算法和哈希算法。 服务器将数字证书返回给浏览器，这里的数字证书可以是向权威机构比如 CA 申请的，也可以是自签名证书。 浏览器进入数字证书认证环节，这一部分是浏览器内置的 TLS 模块完成的。  首先浏览器会从系统内置的证书列表中索引，找到服务器下发证书对应的机构。 如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。 如果查到了对应的机构，则取出该机构颁发的公钥。 用机构的证书公钥解密得到证书的内容和证书数字签名，内容包括服务器的地址、服务器的公钥、证书的有效期等。 浏览器首先验证数字签名的合法性，验证过程类似 Bob 和 Pat 的通信过程。 签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。 如果网址一致会检查证书有效期，证书过期了也会提示用户。 以上都通过认证时，浏览器就可以安全使用证书中的服务器公钥了。 浏览器生成一个随机数 R，并使用服务器的公钥对 R 进行加密。   浏览器将加密之后的 R 传送给服务器。 服务器用自己的私钥解密得到 R。 服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。 浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。  整个过程主要为了认证服务端证书以及的公钥的合法性，因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法，主要是用来保护传输客户端生成的 Premaster Secret 用于对称加密的随机数私钥。后续内容传输都为对称加密。\n通常 TLS 会在系统内置的可信证书列表内索引匹配的证书链。这一过程也有例外，例如 macOS 上，Safari、Edge 和 Chrome 建立 TLS 连接时会从系统的 Keychain Access 根证书去索引；而 Firefox 安全度更高，会在浏览器内置的证书中索引，防止在系统被注入证书时 HTTPS 被窃听，常见的抓包软件就是通过把自签名证书注入到系统的证书链中以实现 HTTPS 的拦截。\n更多关于 SSL/TLS 的详细内容从以下这篇文章进一步了解。\n 徐旭栋  Tue, May 09, 2017   CIP 11.07) Computer Science , 11.0701) Computer Science   NC. Networking and Communication  深入了解 SSL/TLS Protocol  SSL/TLS 协议详解\n   RFC 6101   RFC 2246   RFC 4346   RFC 5246   RFC 8446    进一步了解  HTTPS. HTTP Over TLS. The Secure HyperText Transfer Protocol.  ","date":1494633600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1494633600,"objectID":"470a8133a5f059121ff2bce2dc7d2392","permalink":"/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/","publishdate":"2017-05-13T00:00:00Z","relpermalink":"/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/","section":"post","summary":"HTTPS 详解","tags":["HTTPS"],"title":"深入了解 HTTPS","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"进一步了解  Hypertext Transfer Protocol \u0026ndash; HTTP/1.1. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. An overview of HTTP.  ","date":1494460800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1494460800,"objectID":"09dffe34b88935a1f1f05c0e2e3011e9","permalink":"/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/","publishdate":"2017-05-11T00:00:00Z","relpermalink":"/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/","section":"post","summary":"HTTP 详解","tags":["HTTP"],"title":"深入了解 HTTP","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"TLS 1.0 TLS 2.0 TLS 3.0 进一步了解  The TLS Protocol Version 1.0. The Transport Layer Security (TLS) Protocol Version 1.3. Datatracker The Transport Layer Security (TLS) Protocol Version 1.3. Transport Layer Security - Wikipedia.  ","date":1494288e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1494288e3,"objectID":"07affd0e5a1ad80be3721c6e6d3379d4","permalink":"/2017/05/09/tls-handshaking-protocols/","publishdate":"2017-05-09T00:00:00Z","relpermalink":"/2017/05/09/tls-handshaking-protocols/","section":"post","summary":"TLS 握手协议","tags":["TLS"],"title":"TLS Handshaking Protocols","type":"book"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"TLS 1.0 TLS 2.0 TLS 3.0 进一步了解  The TLS Protocol Version 1.0. The Transport Layer Security (TLS) Protocol Version 1.3. Datatracker The Transport Layer Security (TLS) Protocol Version 1.3. Transport Layer Security - Wikipedia.  ","date":1494288e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1494288e3,"objectID":"ed053374d18a79307067455ee347fc66","permalink":"/2017/05/09/tls-record-protocol/","publishdate":"2017-05-09T00:00:00Z","relpermalink":"/2017/05/09/tls-record-protocol/","section":"post","summary":"TLS 记录协议","tags":["TLS"],"title":"TLS Record Protocol","type":"book"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"WebSocket 握手 WebSocket 为第 7 层应用层协议，建立连接的握手流程依赖于 4 层 TCP，由于 WebSocket 通过利用 HTTP 发起握手，所以这里的握手更类似于一次对 HTTP 协议切换的请求。\nClient 请求 WebSocket 的请求和 HTTP 的格式是一致的, 每行会以 \\r\\n 字符结尾，请求头的结束处也需要另起一行空白行：\nGET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com  最大的区别在于 WebSoeckt 的请求头会在 HTTP 的基础上带上 WS 协议切换标志位，告诉服务端将 HTTP 升级为 WebSocket。\nUpgrade: websocket Connection: Upgrade  Server 响应 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat  进一步了解  The WebSocket Protocol The WebSocket API (WebSockets). WebSocket.  ","date":1494028800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1494028800,"objectID":"27ab91e8eb1b4ebc24a0c359381a896a","permalink":"/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/","publishdate":"2017-05-06T00:00:00Z","relpermalink":"/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/","section":"post","summary":"WebSocket 协议详解","tags":["WebSocket"],"title":"深入了解 WebSocket Protocol","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"进一步了解  TRANSMISSION CONTROL PROTOCOL): Semantics and Content. Transmission Control Protocol - Wikipedia.  ","date":1493769600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1493769600,"objectID":"40283f788aee3c9ab756ca9ab9c0471b","permalink":"/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/","publishdate":"2017-05-03T00:00:00Z","relpermalink":"/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/","section":"post","summary":"TCP 详解","tags":["HTTP"],"title":"深入了解 TCP","type":"post"},{"authors":["徐旭栋"],"categories":["NC. Networking and Communication"],"content":"进一步了解  User Datagram Protocol. UDP Usage Guidelines.  ","date":1493596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1493596800,"objectID":"eba7cee14ab7fae71bf98197b06cf672","permalink":"/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/","publishdate":"2017-05-01T00:00:00Z","relpermalink":"/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/","section":"post","summary":"UDP 详解","tags":["UDP"],"title":"深入了解 UDP","type":"post"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Swift Programming Language"],"content":"随着 WWDC 2016 的离去，WWDC 2017 也已悄然竟接近，明年苹果将重回加州圣何塞 McEnery 举办开发者大会，这个时候那些该展望的、还没展望的，也基本被讨论的差不多了，虽然在这个时间点来讨论 Swift Performance 虽然有些老生常谈，但也不失为一个好的话题。\nclass 与 struct 的取舍 什么情况下该用哪种 first class type 来建立我们的 Model，虽然各路英才心里自有图谱，但还是很有必要拉出来讨论一下。到底是用 class 还是 struct、用 value 还是 reference ，关键的约束点在于性能开销与多态的实现方式。\n内存分配 人尽皆知 heap 比 stack 更昂贵，heap 牺牲了性能以换取比 stack 更自由的内存管理，stack 牺牲了复杂的数据结构来获取和 Int 赋值一样快的 allocation。\nheap 之所以昂贵、性能开销大，是因为开辟内存时需要考虑到多线程申请同一块内存 block 而产生的竞争问题，因此首先需要加锁来达到 Thread Safety，然后，需要去找到未被使用使用的内存并申请初始化，用完了之后还得还回去将其 deallocate，而我们能得到的好处则是更加动态的内存生命周期。并且不像 C++，Swift 只能在堆上初始化 class，对于 class 选型的取舍显得尤其重要。\n反观 stack，之所以其性能好是因为其开辟内存仅仅依赖于 ESP 的上下移动，以典型自底向上的栈结构为例，一次函数调用所需要的 stack allocate 仅仅需要上移 ESP，而当函数体结束时再把 ESP 指回入栈之前的位置，上段内存自然就 deallocate 了。每个线程有自己的 stack，不要考虑多线程加锁，也不需要考虑下一块内存是否可用。但限制在于，当执行一次完整的 call stack，EBP 的位置是固定的，意味着可以使用内存就这点，所以在栈上能做的事就被大大的限制，否则就等着 Overflow。\nstruct Car { var serial: Int } let car = Car(serial: 123456) // Fake car, have a fake serial, which is equal to car.serial let fakeCar = aCar // do sth with car, fakeCar  这样一段代码在 stack 上仅仅用了 2 个字的大小，用于存储两个 car 的 serial。就轻量级，开销低这些特点来说，在工程中用 struct 来建模看上去是挺美滋滋的，但抛开多态单就性能来说，是否意味着 struct 总是能成为 Modeling 的首选？答案是否定的，当 struct 遇见 ARC 时，她就变得并不那么轻量级了。\nARC Swift 对于 heap 上实例的内存管理，采用的机制依旧是 ARC。\nARC 的在性能上的开销主要是在 swift_retain \u0026amp; swift_release 所产生的多次 indirection 以及多线程的加锁保护。对于 trivial 的 struct 来说因为不涉及 ARC，因此没有影响。但当 struct 本身如果包含了需要 ARC 的实例时，他就变得不那么高效了。\nstruct Car { var name: String var model: String } let newCar = Car(name: \u0026quot;Tesla\u0026quot;, model: \u0026quot;Model S\u0026quot;) let myCar = newCar print(myCar.name)  就 Car 来说，name 和 model 虽然是 String， 是一个 struct，但是 String 的 underlying buffer storage 是开辟在堆上的，需要和 Class 一样的作 retain count，所以会产生如下所示代码。\nstruct Car { var name: String var model: String } let newCar = Car(name: \u0026quot;Tesla\u0026quot;, model: \u0026quot;Model S\u0026quot;) let myCar = newCar print(myCar.name) swift_retain(myCar.name._storage) swift_retain(myCar.model._storage) swift_release(myCar.name._storage) swift_release(myCar.model._storage) swift_release(newCar.name._storage) swift_release(newCar.model._storage)  过多的 retain \u0026amp; release 带来性能开销是我们不想看到的，而如果我们采用 class 来实现则展开成如下形式。\nclass Car { var name: String var model: String init(name: String, model: String) { self.name = name self.model = model } } let newCar = Car(name: \u0026quot;Tesla\u0026quot;, model: \u0026quot;Model S\u0026quot;) let myCar = newCar swift_retain(myCar) print(myCar.name) swift_retain(myCar) // ... do sth swift_release(myCar) swift_release(newCar)  在实际的过程中，Model 显然不会这么简单，一个对象上有 10 几 20 个需要的 ARC 的 property 也不是不可能的，这时候谨慎使用 struct 是我们需要注意的雷区。\n一个好的实践是多用 built-in 的 type 和结构来构建模型，比如 Car.model，作为一个 String，它其实没有很好的约束 Car.model 所想表达的内容，它可以是任何字符串例如 Car.model = \u0026quot;foo\u0026quot;，这是一个非常差的设计。因此如下所示，在这里我们可以采用 enum 来对 model 做约束。\nextension Car { enum Model { case s case x } } struct Car { var name: String var model: Car.Model }  虽然是一个很小的优化点，但结果即提高了语义的清晰度，又减少了不必要的开销，可谓一石双鸟。\n多态 Dyanmic Dispatch 作为类多态实现的基础之一，也是讨论了比较多的话题，对于 class 来说，编译器会给其添加额外的 field 来储存 Type 的信息，runtime 通过 Type 的 v-table 来找到对应的方法，具体关于 Dynamic Dispatch 的讨论可见之前的 Whole Module Optimization 分析，这里就不再赘述。\n回到 struct，如果我们需要在 struct 上实现多态，那就得依靠 protocol 来实现。\nprotocol Turboable { func turbo() } func turbo(_ stuffs: [Turboable]) { stuffs.forEach { $0.turbo() } } struct Car { var name: String } extension Car: Turboable { func turbo() { print(\u0026quot;turbo Car\u0026quot;) } } struct Jet { var name: String } extension Jet: Turboable { func turbo() { print(\u0026quot;turbo Jet\u0026quot;) } } struct Tractor { var name: String var serail: Int } extension Tractor: Turboable { func turbo() { print(\u0026quot;turbo Tractor\u0026quot;) } } let myStuffs: [Turboable] = [ Jet(name: \u0026quot;MiG-25\u0026quot;), Car(name: \u0026quot;Chevrolet\u0026quot;), Tractor(name: \u0026quot;Mercedes-Benz\u0026quot;,serial: 1) ] turbo(myStuffs)  这是一段很常见的 Protocol Oriented Programming，实际上这并不是没有额外性能开销的。和 Class 不一样，通过 protocol 实现的多态是通过 Protocol Witness Table 来做 Dispatch，每一个实现了 Turboable 的类型，编译器都会生成一份 PWT。\nstruct JetPWT { func turbo(_ jet: Jet) { jet.turbo() } } struct CarPWT { func turbo(_ car: Car) { car.turbo() } } struct TractorPWT { func turbo(_ tractor: Tractor) { tractor.turbo() } }  同时对于 Array，底层的 buffer 显然更喜欢以固定的大小去连续的存储元素，而不同的 type 却有着不同的内存布局，因此 Swift 使用了 Existential Containner 去存储元素，这样一个容器提供了个三个字大小的 value Buffer 用于存储元素。\n但如果元素的内存布局过大导致 value Buffer 放不下，例如三个字对于 struct Jet 足够大，但对于 struct Tractor，因为 String.size + Int.size \u0026gt; 3 使得它无法存放在只有三个字大小的 buffer 中。\n// 24 bytes, 3 word let jetSize = MemoryLayout\u0026lt;Jet\u0026gt;.size // 32 bytes, 4 words let tractorSize = MemoryLayout\u0026lt;Tractor\u0026gt;.size  因此 Existential Containner 会在堆上开辟空间用来拷贝存储一份 Tractor，同时将指针存放在 value Buffer 中。\n所以调用 func turbo(_ stuffs: [Turboable]) 实际上绝大部分的性能开销都花费在对结构体进行内存分配上。\n同时，谈及了内存操作，不同的 type 对应的内存布局是不同的，Existential Containner 需要额外信息才能为这些 type 做堆内存初始化、拷贝、释放，因此 Swift 引入了 Value Witness Table 来管理 value type 在堆上的生命周期。\nstruct JetVWT { // 在堆上初始化一块用于存放 Jet 的内存，并把地址赋给 Existential Containner func allocate() // 把 stack Jet 的内存 copy 到 heap 上 func copy() // 用于 class type 引用计数递减 func destruct() // 释放堆内存 func deallocate() } struct CarVWT { ... } struct TractorVWT { ... }  因此 Existential Containner 还需要额外的两个字的空间用来存放 PWT 和 VWT 的地址。\nstruct ExistContTurboable { var valueBuffer: (Int, Int, Int) var vwt: ValueWitnessTable var pwt: TurboableProtocolWitnessTable }  通常来说 Existential Containner 的大小是 5 个字。\n// 40 bytes, 5 words let turboableSize = MemoryLayout\u0026lt;Turboable\u0026gt;.size  虽然官方没声明，但是多个 protocol 的情况下一份 pwt 应该是不够的。\n// 48 bytes, 6 words let turboableSize = MemoryLayout\u0026lt;Turboable \u0026amp; CustomReflectable\u0026gt;.size  所以多个 protocol 的结构会是如下所示的布局。\nstruct ExistContTurboableCustomReflectable { var valueBuffer: (Int, Int, Int) var vwt: ValueWitnessTable var pwt: (TurboableProtocolWitnessTable, CustomReflectableWitnessTable) }  以上整个流程实现了 protocol 的 Dynamic Dispatch，那么最终 func turbo(_ stuffs: [Turboable]) 会生成下文所示的伪代码。\nfunc turbo(val: [ExistContTurboable]) { val.forEach { element in // on the heap var local = ExistContTurboable() let vwt = element.vwt let pwt = element.pwt local.vwt = vwt local.pwt = pwt // 拷贝 local var 至 valueBuffer 或者堆上的内存 vwt.allocateBufferAndCopyValue(\u0026amp;local, element) // 获取到 valueBuffer 或者堆上的实例 pwt.turbo(vwt.projectBuffer(\u0026amp;local)) // 清理现场 vwt.destructAndDeallocateBuffer() } }  相比于 class，通过 protocol 实现的 Dynamic Dispatch 所带来的性能下降根据数据大小的不同可能高达数倍，并且不仅仅是 protocol type，也包括了 stdlib 中的一些函数。\npublic func max\u0026lt;T\u0026gt;(_ x: T, _ y: T) -\u0026gt; T where T : Comparable  这是一个很典型的范型函数，编译器在优化 Scope 被限制的条件下，会保守的生成符合所有 case 的函数。\npublic func max\u0026lt;T\u0026gt;(_ x: T, _ y: T, _ pwt: TypePWT, _ vwt: TypeVWT) -\u0026gt; T where T : Comparable  同样用到了 PWT 和 VWT，函数体的内部也同样用 valueBuffer 来存储数据，一样是 3 个字的大小（苹果估计和 G 胖有仇），唯一的区别是没用 Existential Container 到，因为这个对于每次调用只有一种 type 的参数是没有必要的。\n当然这种通过范型实现的 Static Polymorphism 仍然是 Dynamic Dispathc 虽然对性能开销有影响，但是通过 Generic Specialization 可以使其达到 Static Dispathc，同样之前的 Whole Module Optimization 分析 有提及，所以不再赘述。\n 2017-07-14 Updated   在 WWDC 2017 上，苹果终于出手这个解决 valueBuffer 的性能问题了，Unpredictable Performance Cliff。苹果的方案是采用 COW Existential Buffers，简单来说就是太大没法放进 valueBuffer 的 value，苹果对其采用和类一样的 reference counting，多个 Existential Container 可以共享相同的 buffer 直到这个 value 需要被修改才会被重新分配内存，以减少 heap allocation 的次数，典型的 COW 机制。\n同样对于范型的 valueBuffer，原来的 heap allocation 被替换为 stack allocation，规避了堆内存管理，这下可以更加肆无忌惮的使用范型和 protocol 了。\n结语 我们数据建模的方式小改动会对性能造成巨大的影响，所以在我们设计每一个代码环节时，我们都有这样思维，这段代码发生了什么、会产生怎么样的性能开销、内存是如何分配的。\n在工程中都应该根据实际场景仔细斟酌采取哪种机制来获取优雅的实现，并在此基础上对性能做优化，是需要 class 的 OOP 特性，还是 struct 的 value 特性，是需要 protocol 的更加灵活的 Dynamic Polymorphism，还是由范型带来的更加 static 的 Static Polymorphism。\n总之还是那句话，工欲善其事，必先利其器，了解你的编译器，这样才能让编译器更好的理解你。\n参考文献  Understanding Swift Performance What\u0026rsquo;s New in Swift 4 Exploring Swift Memory Layout Real World Swift Performance  ","date":1480183205,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1480186805,"objectID":"896bfa8683c85a409d042488fae4d736","permalink":"/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/","publishdate":"2016-11-26T18:00:05Z","relpermalink":"/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/","section":"post","summary":"如何优化 Swift Performance","tags":["Swift","Compiler"],"title":"再谈 Swift Performance","type":"post"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Swift Programming Language"],"content":"Swift 自诞生以来，就标榜了 Performance。WWDC 2015 上苹果为 Swift 2 引入的 Swift Compiler 特性 Whole-Module Optimization 将其再一次拉上了 Performance 的舞台，那么 WMO 到底做了些什么？\n通常来说，Swift 文件是单独编译的，这样的编译模式不但可以充分发挥多核心的优势做到并行编译而且还能做到单文件维度的增量编译。\nstateDiagram-v2 File1.swift --\u0026gt; Compiler Compiler --\u0026gt; File1.o File2.swift --\u0026gt; Compiler Compiler --\u0026gt; File2.o File3.swift --\u0026gt; Compiler Compiler --\u0026gt; File3.o  这很合情也和很合理，用 Apple 的话来说就是\n That\u0026rsquo;s good 😀\n 然而这样会把 Optimizer 能获取到的上下文局限在单个文件内，那么显而易见的问题是，整个模块内的死函数、Dynamic Dispatch 的 V-Table 查询、泛型特例化等等都无法被很好的优化，所以精益求精的 Apple 认为，这还是不够 good，因此引入了 Whole-Moudle Optimization。\nstateDiagram-v2 File1.swift --\u0026gt; Compiler File2.swift --\u0026gt; Compiler File3.swift --\u0026gt; Compiler Compiler --\u0026gt; File.o  WMO 将整个模块的内的 Swift 文件合并成一个，把颗粒度提升到整个模块，这样可以做到在 Build Source 阶段，Optimizer 只进行一次模块级别的优化，用 Apple 的话来说就是：\n Analyze everything at once, aggressive optimization, very good 😀\n WMO 对于 Swift 所能带来的提升官方称有 2x ~ 5x，如此 good 的性能提升使得从 Xcode 8 开始 WMO 就成为了默认标配，所以 WMO 快在哪？\n泛型特例化 以 stdlib 中的函数为例。\n// File1.swift @_inlineable public func max\u0026lt;T : Comparable\u0026gt;(_ x: T, _ y: T) -\u0026gt; T { // In case `x == y`, we pick `y`. See min(_:_:). return y \u0026gt;= x ? y : x }  由于是泛型，编译器无从知道 type T 具体类型是 Int、Double 还是其它任何 Comparable 的类型，所以编译器会去函数表里找类型匹配函数， 同时编译器也无从知道 type T 是否需要为其 reference counting(e.g class Foo: Comparable)，所以为了应付所有可能的 type T 情况下，编译器会保守的生成如下伪代码。\n// File1.swift @_inlineable func max\u0026lt;T : Comparable\u0026gt;(x: T, y: T, FTable: FunctionTable) -\u0026gt; T { let xCopy = FTable.copy(x) let yCopy = FTable.copy(y) let ret = !FTable.lessThan(yCopy, xCopy) ? y : x FTable.release(x) FTable.release(y) return ret }  然而在 runtime 时期，对于诸如 Int 这类的基本类型来说，编译器插入的 copy()、release() 是毫无意义却又是确实存在的，所以和 Template Specialization 类似，Swift Compiler 引入了 Generic Specialization。\n// File1.swift func foo() { let x: Int = ... let y: Int = ... let ret = max(x, y) ... }  在这样一个上下文内，Compiler 能清楚的得知 type T = Int，因此 max\u0026lt;T\u0026gt; 会被拷贝并被特例化成 max\u0026lt;Int\u0026gt;。\nfunc max\u0026lt;Int\u0026gt;(x: Int, y: Int) -\u0026gt; Int { return y \u0026lt; x ? x : y }  然而问题是在如下的情况也是大部分工程中最常见的情况下，对于 File1.swift 来说 File2.Swift 在编译期是不可见的，Generic Specialization 也因此失去了作用。\n// Module Foo // File1.swift @_inlineable public func max\u0026lt;T : Comparable\u0026gt;(_ x: T, _ y: T) -\u0026gt; T { // In case `x == y`, we pick `y`. See min(_:_:). return y \u0026gt;= x ? y : x } // File2.swift func bar() { let x: Int = ... let y: Int = ... let ret = max(x, y) ... }   It\u0026rsquo;s not good 🙁.\n 就时候就能体现出 WMO 的优势，颗粒度上升至模块之后，File1，File2 会被合并，所有 Source 处于同一上下文，因此编译器有足够的信息去优化生成成如下 high perfromace 的代码。\n// Module Foo // Foo-Merged.swift @_inlineable public func max\u0026lt;Int\u0026gt;(_ x: Int, _ y: Int) -\u0026gt; Int { return y \u0026gt;= x ? y : x } func bar() { let x: Int = ... let y: Int = ... let ret = max\u0026lt;T\u0026gt;(x, y) ... }  Dynamic Dispatch 假设有一个 class Car。\n// Module A // File1.Swift class Car { // should not override var brand: String func turboCharge() // turboCharge implementation, called by turboCharge(), should not override func turboChargeImpl() } // File1.swift class Porsche: Car { var model: String override func turboCharge() // 对于子类，任何继承于父类的非 private func、property 都是以 Dynamic Dispatch // 的形式调用的，即使没有被 override // assumed to be overridden by compiler // func turboChargeImpl() }  然后我们有个 class Driver。\n// File2.swift class Driver { var name: String func turbo(of car: Car) { print(\u0026quot;Strat turbo of \\(car.brand)\u0026quot;) car.turboCharge() } }  那么对于 Driver.turbo 编译器会生成如下伪代码。\nclass Driver { ··· func turbo(a car: Car) { let brandGetter = Car.brandGetter(car) print(\u0026quot;Strat turbo of \\(brandGetter(car))\u0026quot;) let turboCharge = Car.turboCharge(car) turboCharge(car) } ··· }  由于局限于单文件 Scope，编译器无从得知所给到类的层级信息，自然无法得知有哪些 property，func 是被 override的，所以编译器必须插入间接运算以完成 Dynamic Dispatch。对于不会被 override 的 Car.brand、Car.turboChargeImpl，可以通过 final 限制子类的 override 或者通过 private 限制子类的 Access Control 来达到 Static Dispatch。\nclass Car { ··· final var brand: String private func turboChargeImpl() }  于是编译器就会生成如下伪代码。\nclass Driver { ··· func turbo(a car: Car) { print(\u0026quot;Strat turbo of \\(car.brand)\u0026quot;) let turboCharge = Car.turboCharge(car) turboCharge(car) } ··· }  回到 WMO，在上文基础上，假设有这样一个情景。\n// Module A // File2.swift class Driver { ··· func turbo(a porsche: Porsche) { porsche.turbo() } ··· }  这样一段代码会被改写成如下。\nclass Driver { ··· func turbo(a porsche: Porsche) { let turboCharge = Porsche.turboCharge(porsche) turboCharge(car) } ··· }  在 class Prosche 没有任何 subclass 的情况下，Dynamic Dispatch 实际上是毫无意义的，因此 WMO 又一次发挥了作用，把 Visibility 提升到整个模块之后 Compiler 能理解 Prosche 的类层级、并且 Prosche 没有子类，因此 func turbo(a porsche: Porsche) 是完全 Static 的，所以代码最终会被改写成如下。\n// Module A // A-Merged.Swift class Car { final var brand: String func turboCharge() private func turboChargeImpl() } class Porsche: Car { final var model: String override func turboCharge() } class Driver { func turbo(a car: Car) { print(\u0026quot;Strat turbo of \\(car.brand)\u0026quot;) let turboCharge = Car.turboCharge(car) turboCharge(car) } func turbo(a porsche: Porsche) { porsche.turbo() } }  相比于 objc 的一切皆动态，Swift 在编译器能获得丰富的信息去避免 Dynamic Dispatch 这也为什么 Swift 在 Object-Oriented Benchmark 上能秒杀 objc，可见一个设计优良的 class 不仅在工程易维护性上带来许多方便，同时在性能上也能获得巨大的收益。\nWMO 的适用范围 但就如上文所说的，WMO 下增量编译颗粒度上升至整个模块，意味着不管修改哪个文件，下一次 build 总是 Whole-Module build，大大增加了 build time，虽然 WMO 带来的 clean build 时间缩短是可观的，但和 -Onone、SFO 下的增量编译相比并不在一个量级，所以这对于日常的开发是没有必要的，因此 WMO 作为标配来说也仅仅是在 release build 的情况下，它并不是无敌的。\n同时在开启了优化的情况下，LLDB 也会表现的不正常\nMyApp was compiled with optimization - stepping may behave oddly; variables may not be available.  所以，如果有无法避免的理由需要在 Debug 情况下要用到 WMO，那么\n Debug 下打开 WMO，Other Swift Flags 里添加 -Onone Debug 下关闭 WMO，User-Defined 里添加 SWIFT_WHOLE_MODULE_OPTIMIZATION = YES  以上两种方式都可以把所有文件合并，且不做任何编译优化，减少了 Context 的分析，不但能够 Debug，而且相比于 Whole-Module Optimization 还可以达到更快的编译速度。对于 CocoaPods 引入的 Swift framework，可以在 hook 里为每个 target 做配置。\npost_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if config.name == 'Debug' config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Owholemodule' config.build_settings['OTHER_SWIFT_FLAGS'] = '-Onone $(inherited)' end end end end  总结 WMO 的情况下，配合良好的代码设计会给予整个工程带来不容忽视的收益，用 Apple 的话来说就是：\n All I need to do is to turn on Whole-Module Optimization. I don\u0026rsquo;t need to change code at all. By giving the compiler more information, by allowing the compiler to understand my class hierachy with more information, I was able to get this optimization for free without any work on your part.\n 进一步了解 Whole-Module Optimization in Swift 3 Optimizing Swift Performance Speeding Up Compile Times of Swift Projects Swift with a hundred engineers Chris Lattner\u0026rsquo;s Homepage  ","date":1468519205,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1468864805,"objectID":"5fa62fca920520c03b352673f8bd9418","permalink":"/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/","publishdate":"2016-07-14T18:00:05Z","relpermalink":"/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/","section":"post","summary":"Whole-Module Optimization 是如何工作的","tags":["Swift","Compiler"],"title":"Whole-Module Optimization 分析","type":"post"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Objective-C Programming Language","The Swift Programming Language"],"content":"序 Swift 3.0 问世之际，随之而来的是 API 的清晰语意、更加完备的泛型、更 Swift Style 的 C APIs 等等。这也意味着 Swift 未来霸主地位越来越难被撼动。回看 Objective-C，作为一门 1980s 诞生的语言，在 Swift 的持续迭代下，ObjC 越发失去生机，Type Inference 的缺失、Dynamic Dispatch 的性能开销、不安全的 runtime，过度啰嗦的 API 设计，都使得其在各方面被 Swift 全面碾压，大概目前能谈得上优势的也只剩下强大的 runtime 动态性和 C/C++ 混编了。\n今次回顾下 Objective-C，依稀能看出语言设计上的年代感，对于 Objective-C 来说，如果当初 Swift 没有出现的话，Objective-C 3.0 是否能如期问世？\n View \u0008The Objective-C Programming Language Evolution   Objective-C Evolution 开端 尽管 Swift 的语法与性能以其压倒性的优势凌驾于 ObjC 之上，但缺点和短板的也很明显：\n  从 Swift 1.0 到 2.3 再到目前的 3.0，Swift 的飞速发展有目共睹，但与此同时其不稳定的 ABI 也一直被诟病，开发者们戏称道 Swift 1.0/2.0/3.0 是三门语言，虽然并没有那么夸张，但其对于代码的冲击性是确确实实的，对于小型团队来说 Swift 的版本迁移可能就几天就解决了，然而对大型项目来说，这个变化是毁灭性的。同时 Swift 持续迭代中产生的 bug、issue 并不能被很快的解决，那么势必我们会偶然间为 Swift 的发展而踩坑。通常来说，这些迁移所带来的额外成本在快速迭代的开发环境下是不被允许的。\n  Swift 表现和 C++ 在很多地方都十分相似，非常 static，这也意味着 Swift 在动态性上非常薄弱，stdlib 中的 Mirror 相比于 ObjC 的 runtime，简直就是小巫见大巫，再者 Foundation 中的 KVC、KVO 在 Swift 中需要借助 NSObject 和 dynamic 来完成。\n  对于一些有历史包袱或者偏底层的框架来说，它们无法从 C/C++ 剥离，而对于 C++，Swift 则必须通过 C、ObjC 来作为桥梁，无形中增加了开发成本，同时 Swift 对于指针的支持特别是函数指针并不是那么的友好，虽然这也无可厚非，毕竟 Swift 强调 safe，指针本身就是 unsafe 的，但使用上总有那么些许的不流畅。\n  虽然目前的 Swift 依然有不少缺点，但作为一个积极的 Swift 布道者来说，其仍然是我目前为止评价最高的一门语言，其强大而优雅的语法特性、涵盖了多种模式的编码环境、内存管理哲学、以及针对性能所做的优化是目前的 Objective-C 望成莫及的。\n 了解更多    徐旭栋  (2016). Swift 设计哲学.   共生 事实上 Apple 为了让 Swift 和 Objective-C、Foundation 层面互相兼容，在 LLVM 上做了非常多的工作，同样在 Swift Native 层面也做了大量的 Cast 和 Bridge，以至于导致了好多 Bug，列举几个我遇到过的:\n NSError 的 overrelease，出现在 NSError 和 Error 互相 Cast 的场景，主要挂在 tryDynamicCastNSErrorObjectToValue，通过 Allocation 最终定位为 swift runtime 的 bug  SR-9207 Crash while casting object in swift    引入 Swift 的代价是巨大的，但带来的收益同样也很可观，客观来说 Objective-C 的地位已然被撼动，试问一句还能战多久？\n理想 Objective-C 最大优点在于非常动态，这同样也是其缺点。高度的动态性导致其类型的不安全，冗长的自描述语法导致编码时效率低下，和 C/C++ 高度兼容的多语言特性增加了编码方式的可能性，但也导致潜在要处理的编码场景变得更为复杂。\n汲取现代语言的特性，展望 Objective-C 3.0 可拓展的特性：\n 类似 var 和 let 关键字，参考 Swift，既满足了类型推导，又满足了可变性控制 guard 和 defer 关键字，参考 Go 和 Swift 构建优雅 Control Flow 的必要元素 aysnc 和 await 关键字和协程，参考 .NET 支持泛型和模版，目前的 Objective-C 仅支持轻量型泛型 以 . 语法代替 []，事实上 Foundation 中大量的 getter 都在逐渐适配成 @property，. 语法的可用范围正在逐渐变多 参数的空指针自描述，参考 Swift，在 Swift 中由 Optional 完成，Objective-C 中有 nullability 关键字，不过主要服务于 Objective-C 到 Swift 的 API naming Protocol 的默认实现，参考 Swift Access Control  Evolution 得益于 LLVM 以及出色的 Clang 前端，使得 Swift 以及一些现代语言的语法特性在 ObjC 中出现具有了可能性。拟参考 apple/swift-evolution 的形式，基于对 Objective-C 原生特性拓展研究以及衍生特性的挖掘目的，建立 The Objective-C Programming Language Evolution 作为 Objective-C 的 CodeLab。\n结语 虽然目前 Swift 在苹果的推动下气势越来越猛、野心也越来越大，未来越来越多的语言特性、更完备的 stdlib 以及更加稳定的 ABI 成为了苹果当下的主要目标。但包括苹果自己的框架在内，以及仍然有许多应用、优秀的开源库无法从 Objective-C/C++ 剥离。个人认为一些优秀并且已经被开源社区实现的特性是可以作为语言的标准特性加入到 Objective-C 的，就看 Apple 有没有这个意愿发布 Objective-C 3.0，毕竟 Apple 和  G 胖还是不一样的。\n进一步了解  徐旭栋  (2016). The Objective-C Programming Language Evolution.   ","date":1466850689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466854289,"objectID":"ec22334a96ab92637ba404365901e8a5","permalink":"/2016/06/25/introduce-objective-c-evolution/","publishdate":"2016-06-25T10:31:29Z","relpermalink":"/2016/06/25/introduce-objective-c-evolution/","section":"post","summary":"About The Objective-C Programming Language Evolution","tags":["Objective-C","Swift"],"title":"Introduce Objective-C Evolution","type":"post"},{"authors":null,"categories":null,"content":"关于  That day, if swift had never been released\u0026hellip;, would Objective-C be different?\n The objc-evolutions project maintains the personal major proposals for changes and enhancements to the The Objective-C Programming Language.\n进一步了解   徐旭栋  (2016). Introduce Objective-C Evolution.  项目    徐旭栋  (2016). The Objective-C Programming Language Evolution.   ","date":1466850689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466850689,"objectID":"9570a02b3f1f79e7b62b52004dc84d4f","permalink":"/project/project-objc-evolution/","publishdate":"2016-06-25T10:31:29Z","relpermalink":"/project/project-objc-evolution/","section":"project","summary":"The Objective-C Programming Language Evolution","tags":["Objective-C"],"title":"Objective-C Evolution","type":"project"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Objective-C Programming Language","The Swift Programming Language"],"content":"序 进一步了解  Design decisions / goals / philosophy of Swift Language design philosophy, Swift vs Other recent languages  ","date":1466850689,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1466854289,"objectID":"6f327e460b4069b4c8cf30c524aa7418","permalink":"/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/","publishdate":"2016-06-25T10:31:29Z","relpermalink":"/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/","section":"post","summary":"聊聊 Swift 语言的设计","tags":["Objective-C","Swift"],"title":"Swift 设计哲学","type":"post"},{"authors":["徐旭栋"],"categories":["IAS. Information Assurance and Security","Cryptography"],"content":"前言 故事的主人翁是 Bob，他有三个朋友 Pat、Doug 和 Susan。Bob 经常和他们网上冲浪，因为他的消息是明文传输的，在传递过程可能被人截获偷窥，也可能被人截获然后又篡改了，更有可能别人伪装成 Bob 本人跟他的好友通信，为了规避消息泄漏以及被篡改的风险，整个通信过程中会引入非对称加密算法以及数字签名。正文部分会添加个人的译注作为补充介绍一些背景与看法，接下来我们来看看 Bob 是怎么用非对称加密与好友通信的。\n正文 主人翁 Bob 得到了两把钥匙。其中一把称为公钥，另一把称为私钥。\n    Public Key\n Private Key    【译注】\n非对称加密算法（RSA）是内容加密的一类算法，它有两个密钥，公钥与私钥：\n 公开的、可以被所有人都可以获取的称之为公钥。 只有持有者知道，其他任何人获取不到的称之为私钥。  通过公钥加密的内容，只能通过私钥解密，同样通过私钥加密的内容也只能用公钥解密，公钥和私钥只有称谓上不同，本质上没有任何区别，是很典型的用途决定命名。通常私钥加密公钥解密，我们称之为身份认证；公钥加密私钥解密，我们称之为加密。非对称加密算法的安全性很高，但因为计算量庞大，比较消耗性能。\n Bob 的公钥可供任何需要的人使用，而他的私钥由他自己保密保存。密钥用于加密信息。将信息加密意味着“干扰”，只有拥有正确密钥的人才能将其解密并恢复成可读内容。Bob 两个密钥中的任意一个密钥都可以用来加密数据，并且使用另一个密钥解密数据。\n\nPat  \nSusan  \nDoug  \nOthers  Bob's Co-workers\n \u0026nbsp\u0026nbsp\u0026nbsp  Public Key\nAnyone can get Bob's Public Key, but Bob keeps his Private Key to himself.\n   【译注】\n这里可以理解成 Bob 把公钥直接复制成三份传输给了 Pat、Susan 以及 Doug。\n Susan 可以使用 Bob 的公钥加密消息，Bob 获取到加密消息之后可以用他的私钥去解密消息。Bob 的每个同事都可以获取到 Susan 的加密消息，但在没有 Bob 的私钥的情况下，这些数据毫无价值。\nflowchart LR a1(\u0026quot;Hey Bob, how about lunch \u0026lt;br/\u0026gt; at Taco Bell. I hear they \u0026lt;br/\u0026gt;have free refills!\u0026quot;) a2(HNFmsEm6Un\u0026lt;br/\u0026gt;BejhhyCGKOK\u0026lt;br/\u0026gt;JUxhiygSBCEiC\u0026lt;br/\u0026gt;0QYIh/Hn3xgiK\u0026lt;br/\u0026gt;BcyLK1UcYiY\u0026lt;br/\u0026gt;lxx2lCFHDC/A) b1(HNFmsEm6Un\u0026lt;br/\u0026gt;BejhhyCGKOK\u0026lt;br/\u0026gt;JUxhiygSBCEiC\u0026lt;br/\u0026gt;0QYIh/Hn3xgiK\u0026lt;br/\u0026gt;BcyLK1UcYiY\u0026lt;br/\u0026gt;lxx2lCFHDC/A) b2(\u0026quot;Hey Bob, how about lunch \u0026lt;br/\u0026gt; at Taco Bell. I hear they \u0026lt;br/\u0026gt;have free refills!\u0026quot;) subgraph Susan a1--\u0026gt; |Encrypt with \u0026lt;br/\u0026gt;Public Key| a2 end a2--\u0026gt; |Transfer| b1 subgraph Bob b1--\u0026gt;|Decrypt with \u0026lt;br/\u0026gt;Private Key| b2 end   【译注】\n比如 Susan 要和 Bob 讨论去哪吃午饭，Susan 就可以先把自己的明文内容用 Bob 给她的公钥做一次加密，然后把加密的内容传送给 Bob，Bob 收到消息后，用他的私钥解密消息的内容。\n通常公钥加密，私钥解密的过程我们称之为加密，完整的加密过程为：\n 发送方（Susan）通过可逆算法对内容 Message 用公钥进行加密，得到加密后的内容并发送 接收方（Bob）接收 Message，并用私钥解密得到 Message，这个消息只有 Bob 的私钥能够解密  密码学范畴内，加密的目的是为了不让别人看到传送的内容，加密的策略是在特定加密算法以及双方约定的密钥的基础上进行的，比如使用非对称加密算法和用公钥加密；而解密的策略则需要相关的解密算法及约定的密钥，比如非对称加密算法和用私钥解密，整个加密的过程是可逆的。\n更多可以参考分类 IAS. Information Assurance and Security, Cryptography\n 在有了私钥和对应的软件后，Bob 可以在文档和其他数据上进行数字签名。数字签名可以理解为 Bob 在数据上打上了印记，这个印记对于 Bob 来说是独一无二的，很难伪造。此外，针对已经进行过签名的数据，数字签名能够保障对数据所做的任何篡改都可以被探知。\n为了给一个文档签名，Bob 的软件通过“散列化”将数据压缩成几行，这几行的数据被称为消息摘要，并且没有任何方法能够将消息摘要还原成原始数据。Bob 的软件用私钥加密生成的消息摘要，这个结果就是数字签名。\nflowchart LR a1(Message) a2(Message Digest) a3(Digital Signature) a1--\u0026gt; |Hash| a2 a2--\u0026gt; |Encrypt with \u0026lt;br/\u0026gt;Private Key| a3  最后，Bob 的软件将数字签名附加到文档中，此时所有被散列化的数据都已经被签名。Bob 现在把文件传给了 Pat。\n 【译注】\n假设 Bob 收到 Pat 的消息后，决定给 Pat 回复。为了防止内容被篡改或者别人伪装成他的身份跟 Pat 通信，他决定先对消息的内容用散列算法做一次处理，得到一个哈希值，Bob 又用自己的私钥对哈希值做了一次加密得到一个数字签名，然后把签名和消息一起发送给 Pat。\nBob 的内容为明文传输，这个过程是可以被人拦截，但是 Bob 最担心的是内容被人篡改或者有人冒充自己跟 Pat 通信，而不是内容被窥探。这里其实涉及到了身份认证的概念，Bob 要向 Pat 证明通信的对方是 Bob 本人，同时也需要确保自己的内容是没被篡改的。\n 首先，Pat 的软件用 Bob 的公钥解密签名，将其还原为消息摘要。如果成功了，那么它证明了在文件上签名的人是 Bob，因为只有 Bob 才有他的私钥。随后，Pat 的软件将文档数据散列化成消息摘要，如果 Pat 生成的消息摘要与解密 Bob 的签名得到的消息摘要相同，则 Pat 知道被签名数据没有被更改。\nflowchart LR a1(Message \u0026lt;br/\u0026gt;+\u0026lt;br/\u0026gt;Digital Signature) a2(Message Digest) a3(Message Digest) a1--\u0026gt; |Hash| a2 a1--\u0026gt; |Decrypt with Public Key| a3   【译注】\nPat 接收到了 Bob 的消息，首先用 Bob 给的公钥对签名作了解密处理，得到了哈希值 A，然后 Pat 用了同样的哈希算法对消息内容作了一次散列化处理，得到另外一个哈希值 B，对比 A 和 B 如果相同，那么可以确认内容是由 Bob 本人撰写并没有被篡改。\n通常私钥加密，公钥解密的过程我们称之为身份认证，完整的认证过程为：\n 发送方（Bob）通过不可逆算法对内容 Message 进行处理（散列化也就是哈希），得到的结果值 Hash Bob 发送方（Bob）用私钥加密 Hash Bob 得到结果值作为数字签名 Digital Signature 与 Message 一起发送 接收方（Pat）接收 Message 和 Digital Signature，用公钥解密数字签名，如果成功得到结果 Hash Bob 说明是由 Bob 的私钥进行的签名 接收方（Pat）同样对 Message 哈希处理得到 Hash Pat 如果 Hash Pat 和 Hash Bot 一致，则说明内容没被篡改   Doug 是我们的一个心怀不满的员工，他想欺骗 Pat。Doug 十分确定 Pat 收到一条被签名过消息以及一个属于 Bob 的公钥。在 Pat 不知情的情况下，Doug 用 Bob 的名字创建了一对密钥，带有欺骗性伪装成 Bob 并发送了这个生成的公钥。Pat 在没有亲自收到 Bob 的公钥的情况下，如何确定 Bob 的公钥是真实的？\n 【译注】\n假设 Bob 是通过网络把公钥发送给他人的，如果 Doug 或者其他任何人截获了 Bob 给 Pat 的公钥。Doug 就开始伪装成 Bob 跟 Pat 无法确认对方是否是 Bob，所以需要引入第三方机构来验证 Bob 的真伪。\n 碰巧 Susan 在公司内的证书颁发中心工作，Susan 只需将 Bob 的公钥以及一些关于 Bob 的身份息进行数字签名，就可以为 Bob 创建数字证书。\nflowchart LR a1(Basic Info: \u0026lt;br/\u0026gt;Name \u0026lt;br/\u0026gt;Department \u0026lt;br/\u0026gt;Cubical Number\u0026lt;br/\u0026gt;Certificate Info: \u0026lt;br/\u0026gt;Expiration Date \u0026lt;br/\u0026gt;Serial Number\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;Bob's Public Key) a2(Digital Certificate) subgraph Bob a1 end a1--\u0026gt; |Sign Data| a2  现在，Bob 的同事们可以检查 Bob 的受信证书，以确保这个获取到的公钥的确属于 Bob。事实上除了 Susan 生成的证书签名，Bob 的公司没有人会接受其他任何签名。这使得 Susan 有权在私钥被盗或不再需要时撤销签名，甚至还有更广为接受的证书颁发机构来认证 Susan 的身份。现在假设 Bob 给 Pat 发送了一份签名文件，为了验证文档上的签名，Pat 的软件首先使用 Susan（证书颁发机构）的公钥来检查 Bob 证书上的签名，证书解密成功证明这个签名是用 Susan 的私钥创建的，表示是 Susan 创建了这个证书。证书的签名解密后，Pat 的软件可以检查 Bob 在证书颁发机构中是否信誉良好，以及所有与 Bob 身份相关的证书信息是否有被修改。随后，Pat 的软件从证书中提取 Bob 的公钥，并用它来检查 Bob 的签名。\n 【译注】\nBob 发现了自己的公钥被 Doug 获取之后，意识到公钥传输这个过程是有漏洞的，可以被拦截并伪装。所以文中的 Susan 作为第三方的权威认证就起到了关键作用，现实中我们会通过以权威机构“证书中心” (Certificate Authority, CA) 做认证。证书中心会用自己的私钥对 Bob 的公钥和 Bob 身份相关的信息一次加密。这样 Bob 通过网络将带有签名的数字证书传输给 Pat 后，Pat 可以用 CA 的公钥解密证书的签名，这样就可以安全获取 Bob 的公钥。\n 如果 Bob 的公钥成功解密了签名，那么 Pat 大可安心，签名是使用 Bob 的私钥创建的，这是因为 Susan 已经认证了匹配的公钥。当然如果签名有效，那么我们知道 Doug 没有试图更改签名内容。虽然这些步骤听起来可能很复杂，但它们都由 Pat 的软件在幕后处理。要验证一个签名，Pat 只需单击它。\n进一步了解  What is a Digital Signature?  ","date":1464134400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1464134400,"objectID":"04827aa0a8729c6f111a949acffea518","permalink":"/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/","publishdate":"2016-05-25T00:00:00Z","relpermalink":"/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/","section":"post","summary":"用 Bob 的故事简单介绍数字签名","tags":["Digital Signature"],"title":"什么是数字签名【译注】","type":"post"},{"authors":null,"categories":null,"content":"A latest buildable and debuggable Objective-C runtime project.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1461715200,"objectID":"28c9b510aa822747b85937109470f936","permalink":"/project/project-objc4/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/project-objc4/","section":"project","summary":"A latest buildable and debuggable Objective-C runtime project.","tags":["Objective-C"],"title":"objc4 runtime","type":"project"},{"authors":null,"categories":null,"content":"ToolKit for Compiled Asset Catalogs (.car file) written in Swift.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1461715200,"objectID":"4d29af41e38fe7840271d0c18b8e0f61","permalink":"/project/project-cartool/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/project-cartool/","section":"project","summary":"ToolKit for Compiled Asset Catalogs (.car file) written in Swift.","tags":["Swift"],"title":"swift-cartool","type":"project"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages","The Swift Programming Language","The Objective-C Programming Language"],"content":"Swift 中的快速枚举 Swift 中的 for...in 在 Swift 中所有实现了 Sequence 的类型都能用 for...in 来进行快速枚举，究其根本是因为 Sequence 都实现了一个迭代器 func makeIterator() -\u0026gt; Iterator: IteratorProtocol，我们实现一个支持随机枚举的类型。\n// 首先定义一个随机迭代器 struct RandomIterator\u0026lt;T\u0026gt;: IteratorProtocol { typealias Element = T private var elements: [Element] private var index: Int = 0 init(_ elements: [Element]) { self.elements = elements } mutating func next() -\u0026gt; T? { guard elements.count \u0026gt; 0 else { return nil } index = Int(arc4random_uniform(UInt32(elements.count))); let element = elements[index] defer { elements.remove(at: index) } return element; } } // 定义一个随机序列 struct RandomSequence\u0026lt;T\u0026gt;: Sequence { typealias Element = T private var elements: [Element] init(_ elements: [Element]) { self.elements = elements } typealias Iterator = RandomIterator\u0026lt;Element\u0026gt; func makeIterator() -\u0026gt; Iterator { return RandomIterator(elements) } }  输出为如下所示。\nlet seq = RandomSequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) let loopBegin = { print(\u0026quot;========= loop =========\u0026quot;) } loopBegin() for (i, e) in seq.enumerated() { print(\u0026quot;Elemet \\(i) is \\(e)\u0026quot;) } loopBegin() for (i, e) in seq.enumerated() { print(\u0026quot;Elemet \\(i) is \\(e)\u0026quot;) } // terminal ========= loop ========= Elemet 0 is 7 Elemet 1 is 8 Elemet 2 is 2 Elemet 3 is 4 Elemet 4 is 5 Elemet 5 is 1 Elemet 6 is 3 Elemet 7 is 9 Elemet 8 is 6 ========= loop ========= Elemet 0 is 3 Elemet 1 is 6 Elemet 2 is 7 Elemet 3 is 4 Elemet 4 is 5 Elemet 5 is 9 Elemet 6 is 2 Elemet 7 is 1 Elemet 8 is 8  Swift 下的 for...in 展开 Swift 下 for...in 最终会被展开成如下代码。\nvar iterator = seq.makeIterator() while let element = iterator.next() { print(element) }  Cocoa 中的 NSFastEnumeration 谈到 Cocoa 的 for...in，自然会联系到 @protocol NSFastEnumeration，其只一个方法需要实现。\ntypedef struct { unsigned long state; id __unsafe_unretained _Nullable * _Nullable itemsPtr; unsigned long * _Nullable mutationsPtr; unsigned long extra[5]; } NSFastEnumerationState; @protocol NSFastEnumeration - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len; @end   @param state 它保存了整个快速枚举过程所需要的 Context  itemsPtr 迭代元素的数组 mutationsPtr 一个标识符用于保证在枚举过程中的集合不被修改，这也是为什么在 for...in Loop 中修改 Mutable Collection 会导致 Crash 的原因 state 和 extra 保留字段，用于给 Iterator 保存上下文的信息   @param buffer 缓冲区，用于存放当前需要被迭代的元素 @param len 缓冲区的长度 @return 当前迭代缓冲区的元素个数，如果是 0 表示迭代完成  @protocol NSFastEnumeration 与 for...in 一段 for...in Loop。\nid\u0026lt;NSFastEnumeration\u0026gt; enumatable; for (id element in enumatable) { NSLog(@\u0026quot;%@\u0026quot;, element); }  $ clang -rewrite-objc main.m 之后如下所示：\nid/*\u0026lt;NSFastEnumeration\u0026gt;*/ enumatable; { id element; // 初始化 NSFastEnumerationState Context struct __objcFastEnumerationState enumState = { 0 }; // 开辟一块 size = 16 的缓冲区，用于给 Iterator 填充每次被迭代的元素 id __rw_items[16]; // 被迭代的集合 id l_collection = (id) enumatable; // 首次迭代，向实现了 NSFastEnumeration 的该集合对象对象发送消息 \u0026quot;countByEnumeratingWithState:objects:count:\u0026quot; _WIN_NSUInteger limit = ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend) ((id)l_collection, sel_registerName(\u0026quot;countByEnumeratingWithState:objects:count:\u0026quot;), \u0026amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16); // 检查 ret == 0 ?，如果为 0 表示迭代结束 if (limit) { // 获取 Mutations flag，用于集合修改校验 unsigned long startMutations = *enumState.mutationsPtr; do { unsigned long counter = 0; do { // 保证集合不被修改，否则抛出异常 if (startMutations != *enumState.mutationsPtr) objc_enumerationMutation(l_collection); // 获取枚举的元素 element = (id)enumState.itemsPtr[counter++]; // for...in 的 body NSLog((NSString *)\u0026amp;__NSConstantStringImpl__var_folders__7_td3r8r7j44s2gh39zqkkhlym0000gn_T_main_b0cf04_mi_0, element); } while (counter \u0026lt; limit); // 当前元素遍历完毕，开始下一次迭代 } while ( (limit = ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend) ((id)l_collection, sel_registerName(\u0026quot;countByEnumeratingWithState:objects:count:\u0026quot;), \u0026amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16)) ); element = ((id)0) } else { element = ((id)0); } }  简而言之，在完整的迭代流程中，每次会给 Iterator 传入一个缓冲区 buffer，用于填充需要被迭代的元素，同时会传入一个 NSFastEnumerationState 用来提供当前迭代状态的上下文，当该方法返回值 ret != 0，表示迭代并没有结束，反之亦然。相比于 IteratorProtocol 的单个返回元素，NSFastEnumeration 在调用过程中是批量返回元素的，在 Cocoa 中和 IteratorProtocol 的表现更加类似的则是 NSEnumerator 这个抽象类。\n@interface NSEnumerator\u0026lt;ObjectType\u0026gt; : NSObject \u0026lt;NSFastEnumeration\u0026gt; - (nullable ObjectType)nextObject; @end  实现一个基于 NSFastEnumeration 的随机迭代器 // main.mm @interface RandomIterator: NSObject \u0026lt;NSFastEnumeration\u0026gt; @property (nonatomic, assign) std::vector\u0026lt;id\u0026gt; elements; @property (nonatomic, assign) int capicity; - (id)initWithElements:(NSArray\u0026lt;id\u0026gt; *)elements; @end @implementation RandomIterator - (id)initWithElements:(NSArray\u0026lt;NSObject *\u0026gt; *)elements { if ((self = super.init)) { for (auto e in elements) { _elements.push_back(e); } _capicity = (int)_elements.size(); } return self; } - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id _Nullable __unsafe_unretained [])buffer count:(NSUInteger)len { auto countOfItemsAlreadyEnumerated = state-\u0026gt;state; // This is the initialization condition, so we'll do one-time setup here. if (countOfItemsAlreadyEnumerated == 0) { // state-\u0026gt;mutationsPtr MUST NOT be NULL and SHOULD NOT be set to self. state-\u0026gt;mutationsPtr = \u0026amp;state-\u0026gt;extra[0]; } auto count = 0; if (countOfItemsAlreadyEnumerated \u0026lt; _elements.size()) { state-\u0026gt;itemsPtr = buffer; while(count \u0026lt; len) { auto randomIndex = (int)arc4random() % MAX(1, (_capicity - 1 - countOfItemsAlreadyEnumerated)); buffer[countOfItemsAlreadyEnumerated++] = _elements[randomIndex]; count++; if (_elements.size() == 1) { break; } else { _elements.erase(_elements.begin() + randomIndex); } } } else { count = 0; } state-\u0026gt;state = countOfItemsAlreadyEnumerated; return count; } @end  输出如下\nint main(int argc, const char * argv[]) { auto elements = @[@1, @2, @3, @4, @5, @6, @7, @8, @9]; id\u0026lt;NSFastEnumeration\u0026gt; enumatable = [RandomIterator.alloc initWithElements: elements]; for (id element in enumatable) { NSLog(@\u0026quot;%@\u0026quot;, element); } return 0; } // terminal Iterator[30557:6346806] 3 Iterator[30557:6346806] 1 Iterator[30557:6346806] 7 Iterator[30557:6346806] 5 Iterator[30557:6346806] 6 Iterator[30557:6346806] 2 Iterator[30557:6346806] 8 Iterator[30557:6346806] 4 Iterator[30557:6346806] 9  进一步了解  Enumeration Sample  ","date":145368e4,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1453686549,"objectID":"cda32d3ce7a0bf304c8bb2547312d6f3","permalink":"/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","publishdate":"2016-01-25T00:00:00Z","relpermalink":"/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","section":"post","summary":"NSFastEnumeration 的实现原理","tags":["Objective-C","Swift"],"title":"快速枚举与迭代器","type":"post"},{"authors":["徐旭栋"],"categories":["PL. Programming Languages"],"content":" Continually Updated   __attribute__ 最初作为 GNU C 的特性，为 C/C++、Objective-C/C++ 提供了编译器级别的标注，用来修饰一个变量、函数或类型，包括但不限于以下特性。\n Function Attributes Variable Attributes Type Attributes Label Attributes Enumerator Attributes Statement Attributes  同样 Clang 也很好的兼容了 GGC 这一特性，并做了额外的扩展。\n Calling Conventions Nullability Attributes AMD GPU Attributes Consumed Annotation Checking Type Safety Checking OpenCL Address Spaces Customizing Swift Import  诸如优化、错误检查之类的机械化任务理应由编译器去完成，但常言道“工欲善其事，必先利其器”只有让编译器更加懂你，才能把编译器的性能、优化发挥到极致。\n目录  Variable Attributes  noescape section, __declspec(allocate) used   Type Attributes  objc_root_class   Function Attributes  overloadable   Customizing Swift Import  swift_bridge swift_bridged swift_name swift_newtype   进一步了解    Variable Attributes noescape    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     noescape clang::noescape clang::noescape    Yes    section, __declspec(allocate)    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     section gnu::section gnu::section allocate   Yes    section 特性使得我们能将指定的变量或者函数插入到指定 section 中，比如把一个字符串直接塞入数据段。\nchar *string __attribute((section(\u0026quot;__DATA, Custom\u0026quot;))) = \u0026quot;I'm a pure string.\u0026quot;  used __attribute((used)) 用来修饰变量或者函数。通常默认情况下，没有被引用的符号会被链接器优化去除。标注 used 之后意味着即使符号没有被引用，也不会被连接器优化掉。\nType Attributes objc_root_class 在 Foundation 中对应 OBJC_ROOT_CLASS，__attribute__((objc_root_class)) 用于申明一个没有根类的 objc class，我们可以利用这个特性实现类似 name space 的效果，使得 ObjC 变得更 Swift。\n__attribute__((objc_root_class)) @interface NotificationName @property (class, readonly) NSNotificationName NSApplicationDidFinishLaunching; @end @implementation NotificationName + (NSNotificationName)NSApplicationDidFinishLaunching { return NSApplicationDidFinishLaunchingNotification; } @end  Function Attributes overloadable    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     overloadable clang::overloadable clang::overloadable    Yes    Clang 为 C 引入了和 C++ 一样的 name mangling，使用 overloadable 对 C 函数进行 overload。\n#include \u0026lt;math.h\u0026gt; float __attribute__((overloadable)) tgsin(float x) { return sinf(x); } double __attribute__((overloadable)) tgsin(double x) { return sin(x); } long double __attribute__((overloadable)) tgsin(long double x) { return sinl(x); }  会得到类似于 _Z5tgsinf、_Z5tgsind、_Z5tgsine 这三个符号，同样对于 ObjC Type。\n#import \u0026lt;Foundation/Foundation.h\u0026gt; void __attribute__((overloadable)) detectTypeof(NSInteger i) { fprintf(stdout, \u0026quot;%s\\n\u0026quot;, @encode(typeof(i))); } void __attribute__((overloadable)) detectTypeof(CGFloat f) { fprintf(stdout, \u0026quot;%s\\n\u0026quot;, @encode(typeof(f))); } void __attribute__((overloadable)) detectTypeof(NSString *string) { fprintf(stdout, \u0026quot;%s: NSString\\n\u0026quot;, @encode(typeof(string))); } void __attribute__((overloadable)) detectTypeof(NSArray *array) { fprintf(stdout, \u0026quot;%s: NSArray\\n\u0026quot;, @encode(typeof(array))); } void __attribute__((overloadable)) detectTypeof(NSObject *object) { fprintf(stdout, \u0026quot;%s: NSObject\\n\u0026quot;, @encode(typeof(object))); } int main(int argc, const char * argv[]) { detectTypeof((NSInteger)1); detectTypeof(1.0); detectTypeof(@\u0026quot;Hello\u0026quot;); detectTypeof(@[@(1)]); detectTypeof(NSObject.new); return 0; }  运行结果如下所示。\nq d @: NSString @: NSArray @: NSObject  Customizing Swift Import swift_bridge    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     swift_bridge      Yes    swift_bridge 用于将 ObjC 的声明和 Swift 类型进行 Bridge，为 Swift Interoperability 的体现，更多可以参考 WWDC。Swift 标准库中的相当一部分类型都有 Interoperability 特性，与 Cocoa 有一层隐式 bridge，比如 NSArray、NSMutableArray 和 Swift.Array。\n下方例子中，ObjC 类 DerivatedObjCClass 被 bridge 到 Swift 中的 DerivatedClass。\n__attribute__((objc_root_class)) @interface BaseClass - (instancetype)init; @end __attribute__((__swift_bridge__(\u0026quot;DerivatedClass\u0026quot;))) @interface DerivatedObjCClass: BaseClass @end  更多相关内容可以参考 LLVM 的 Phab Review D87532 Sema: add support for __attribute__((__swift_bridge__)) 以及 swift 的 ClangImporter。\nswift_bridged    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     swift_bridged      Yes    在 CoreFoundation 中对应 CF_SWIFT_BRIDGED_TYPEDEF，配合 swift_bridge 使用，用于被 swift_bridge 描述的类型的 typedef 类型。以 NSString -\u0026gt; Swift.String 为例，在 ObjC 中有如下声明：\n@interface NSString; typedef NSString *AliasedString __attribute__((__swift_bridged_typedef__)); extern void foo(AliasedString _Nonnull str);  在 Swift 中会被 Bridge 为：\nfunc foo(_ str: String) -\u0026gt; Void  这个操作同样会由 Swift Compiler 直接完成，无需开发者手动声明。\nswift_name    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     swift_name      Yes    在 CoreFoundation 中对应 CF_SWIFT_NAME，swift_name 为 C/ObjC 的声明提供了在 Swift 中符号名，默认情况会根据 Swift Compiler 的算法规则自动生成。\n@interface NSData - (instancetype)initWithData:(NSData *)data __attribute__((__swift_name__(\u0026quot;Data.init(_:)\u0026quot;))); @end void __attribute__((__swift_name__(\u0026quot;squareRoot()\u0026quot;))) sqrtf(float f);  swift_newtype    GNU C++11 C2x __declspec Keyword Pragma Pragma clang attribute     swift_newtype swift_wrapper      Yes    在 CoreFoundation 中对应 _CF_TYPED_EXTENSIBLE_ENUM。\n进一步了解  Attributes in Clang Attribute Syntax Enumerator Attributes Compiler-specific Features NSHipster __ attribute __  ","date":1448725456,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1448729056,"objectID":"3129d05ea33e6b06c1f15a6c40a261c4","permalink":"/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/","publishdate":"2015-11-28T15:44:16Z","relpermalink":"/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/","section":"post","summary":"Clang Attributes 实战备忘录","tags":["Compiler","Clang"],"title":"Clang Attributes 使用文档","type":"post"},{"authors":["徐旭栋"],"categories":["PBD. Platform-Based Development","Apple Platform"],"content":" Xocde Plug-in 在 Xcode 8 之后已被禁用   Xcode 插件备忘清单 Alcatraz 用于搜索、安装、管理 Xcode 插件的插件，持项目模版和 Xcode 字体主题，省去了手动 Clone 再编译的过程。\nBBUDebuggerTuckAway 当编辑代码的时候，能自动隐藏 Debugger，尤其适用于边调试边修改的情况。\nClangFormat-Xcode 使用 ClangFormat 来格式化代码风格，支持 LLVM，Google，Chromium，Mozilla，WebKit，或者自定义设置，代码洁癖必备之一。使用自定义格式时 ClangFormat 会从当前正在输入的文件的最近一级的父目录依次向上查找，直到找到用于确定代码风格的 .clang-format 文件，因此通常放在工程文件根目录即可，文件内容使用 YAML 格式，具体风格配置可以参考 Clang-Format Style Options ，或者 clangformat.com。\ncocoapods-xcode-plugin CocoaPods 的 Xcode 插件，省去命令行的步骤，直接在 Xcode 中对 CocoaPods 进行管理。\nColorSense-for-Xcode 高效插件，可视化的 UIColor/NSColor。\nFuzzyAutocompletePlugin 模糊匹配输入，比 Xcode 的前缀匹配要方便许多，主要通过 hook 了 Xcode 自带的 IDEOpenQuicklyPattern 实现。\n Xcode 8 自带了模糊匹配   HOStringSense-for-Xcode 在 ColorSense-for-Xcode 基础上进行的修改，可视化编辑多种文本，正则表达式、多行文本、内联 HTML 等等。\nKSImageNamed-Xcode 使用 [NSImage/UIImage imageNamed:] 方法时，会给出所有工程文件中可选图片，并提图片预览。\nSCXcodeMiniMap 为 Xcode 编辑器增加了一个 MiniMap，不过会挡住报错提示以及较长的的代码的末端，同时支持各种语法高亮。\nSCXcodeSwitchExpander 与 SCXcodeMiniMap 为同一作者，为 swith 语句自动补全所有的 case，只能适用于枚举类型。\nVVDocumenter-Xcode 输入 /// 即可生成一个简易文档模版。\n 在 Xcode 8 已被苹果集成   XAlign 用于对齐代码，可以根据 =、Marco、Property 进行对齐，强迫症和代码洁癖必备\nXcodeColors 更改 NSLog 在 console 中输出的颜色，CocoaLumberjack 的依赖项\nXToDo 允许使用 TODO，FIXME，???，!!! 这些符号来标记需要完成的工作，汇总显示。\nXVim 让熟悉使用 vim 的开发者在 Xcode 中也能够有完整的 Vim 体验。\n","date":1420243201,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1420243201,"objectID":"2b0b185b950baa81fa5f6188debe1619","permalink":"/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/","publishdate":"2015-01-03T00:00:01Z","relpermalink":"/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/","section":"post","summary":"Xcode 插件整理归档","tags":["Xcode Plug-in"],"title":"Xcode 插件整理","type":"post"},{"authors":["徐旭栋"],"categories":["PBD. Platform-Based Development","Apple Platform"],"content":"当 url 字符串中含有特殊字符时，例如空格、汉字等，则必须对 url 字符串进行转义编码，否则 [NSURL URLWithString: urlString] 将返回 nil。\n#import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { NSString *urlString = [NSString stringWithFormat: @\u0026quot;https://www.google.com.hk/search?q=WWDC 2014\u0026quot;]; NSURL *url = [NSURL URLWithString:urlString]; NSLog(@\u0026quot;%@\u0026quot;, url); } return 0; }  输出的 url 结果为。\n21:07:11.784 test[8883:320995] (null)  对 urlString 进行编码以及输出的 url 结果。\n#import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { NSString *urlString = [NSString stringWithFormat: @\u0026quot;https://www.google.com.hk/search?q=WWDC 2014\u0026quot;]; NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]]; NSLog(@\u0026quot;%@\u0026quot;, url); } return 0; }  21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014  空格被转义为 UTF-8 编码，例如汉字\u0026quot;的\u0026quot;的 UTF-8 编码为 0xE7 0x9A 0x84，percent encode 之后就是 %E7%9A%84。\n 2015-07-20 Updated   在 iOS 9.0 / OSX 10.11 之后 - stringByReplacingPercentEscapesUsingEncoding: 就被废弃了，我们可以用 - stringByAddingPercentEncodingWithAllowedCharacters: 代替，参数类型为 NSCharacterSet。这个方法会把所有 Character Set 以外的字符进行 UTF-8 Percent Encoding，支持 url 编码的 Character Set 有如下所示。\n+ URLFragmentAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%\u0026lt;\u0026gt;[\\]^`{|} + URLHostAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%/\u0026lt;\u0026gt;?@\\^`{|} + URLPasswordAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%/:\u0026lt;\u0026gt;?@[\\]^`{|} + URLPathAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%;\u0026lt;\u0026gt;?[\\]^`{|} + URLQueryAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%\u0026lt;\u0026gt;[\\]^`{|} + URLUserAllowedCharacterSet // 7-bit ASCII 不包含 \u0026quot;#%/:\u0026lt;\u0026gt;?@[\\]^`  自定义的 NSCharacterSet 如下所示。\n[[NSCharacterSet characterSetWithCharactersInString:@\u0026quot; \\\u0026quot;#%/:\u0026lt;\u0026gt;?@[\\\\]^`{|}\u0026quot;] invertedSet]  所以最终的编码以及控制台输出就如下所示。\n#import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { NSString *urlString = [NSString stringWithFormat:@\u0026quot;https://www.google.com.hk/search?q=WWDC 2014\u0026quot;]; NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEncodingWithAllowedCharacters: NSCharacterSet.URLQueryAllowedCharacterSet]]; NSLog(@\u0026quot;%@\u0026quot;, url); } return 0; }  21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014  ","date":1417639479,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417640439,"objectID":"b0eb58895664afdb6e56cbcb0cc250bd","permalink":"/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/","publishdate":"2014-12-03T20:44:39Z","relpermalink":"/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/","section":"post","summary":"URL Percent-encoding","tags":["Cocoa","Foundation"],"title":"关于 NSURL +URLWithString: 返回 nil","type":"post"},{"authors":["徐旭栋"],"categories":["SE. Software Engineering"],"content":"添加 submodule 为仓库添加 submodule ⬇\n$ git submodule add {repo-url} /local/repo/path  git clone 带有 submodule 的工程 $ git clone {repo-url}  完成之后，submodule 的代码并没有一起 clone 到本地，查看工作区可以发现 submodule 的上下文内容。\n .gitmodules 存在，里面包含了 submodule 的 url 和 {path/to/submodule-name} {path/to/submodule-name} 存在，但是文件夹是空的 .git/config 里没有submodule库的信息  $ git status  没有发现有更改的地方。\n$ git submodule status  可以看到 submodule hash，前面带有 - 表示 submodule 还没有 checkout。\n拉取 submodule git submodule init 利用工作区 .gitmodules 的信息，在 .git/config 里建立了 submodule 索引 submodule.$name.url，通过如下命令可以看到 submodule 的索引。\ncat .git/config  git submodule update 默认走的是 git submodule update --checkout，利用 superproject 里记录的 hash 来 checkout submodule，这里就有个坑了。\n文档中是这么描述的。\n checkout the commit recorded in the superproject will be checked out in the submodule on a detached HEAD. If \u0026ndash;force is specified, the submodule will be checked out (using git checkout \u0026ndash;force if appropriate), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.\n detached HEAD 不属于任何一条 tree，如果之后忘记 checkout 到某条分支上的话，那之后所有 submodule 的 commit 都基于这个 detached HEAD，那么我们就不得不使用 cherry-pick，把基于 detached HEAD 提交的 commit 提交 pick 到已有的分支上。\n并且当 submodule 的嵌套层级太深的话，一层层的去 submodule 进行 init 以及 update 显然是不可取的，所以可以通过递归的方式去执行命令，这样能够做到 clone 主库以及递归拉取所有 submodule。\ngit clone {path/to/repo-name} --recurse  修改 submodule 通常在实际项目中执行 submodule update 的流程如下所示。\n 当 repo-A 目录下的 repo-B 为 submodule，在对其进行修改之后，查看此时的工作区状态。  $ git status On branch master\tChanges not staged for commit: (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: repo-B (modified content, untracked content) $ git diff diff --git a/submodules/repo-B b/submodules/repo-B --- a/submodules/repo-B +++ b/submodules/repo-B @@ -1 +1 @@ -Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e +Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e-dirty  发现 submodule 是 modified 并且工作目录 dirty，执行 submodule 提交修改。  $ cd submodules/repo-B $ git stage * $ git commit -am 'Update content' $ git status On branch master Your branch is ahead of 'origin/master' by 1 commit. (use \u0026quot;git push\u0026quot; to publish your local commits) nothing to commit, working directory clean  回到主项目，查看状态输出，显示 submodule 的 hash 已更新。  $ git status On branch master Changes not staged for commit: (use \u0026quot;git add/rm \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed) (use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working directory) modified: repo-B (new commits) $ git diff diff --git a/submodules/repo-B b/submodules/repo-B --- a/submodules/repo-B +++ b/submodules/repo-B @@ -1 +1 @@ -Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e +Subproject commit db560723ded8d1a0839dc08fb1e4324b30545c05  主工程提交修改。  $ git stage * $ git status On branch master Changes to be committed: (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) modified: repo-B $ git commit -am 'Update submodule'  从远程库更新 submodule 当远程库的提交里记录的 submodule hash 有更新时，拉取远程库后，我们需要 update 本地的 submodule。git submodule update 会比较主项目记录的 submodule hash 和 submodule 自身当前的 HEAD hash，git 会强制把 submodule 的 HEAD checkout 到 git 记录的 hash，因为是 checkout 所以 detached HEAD 的问题会再一次出现。\n$ git submodule update Submodule path 'submodules/repo-B': checked out 'db560723ded8d1a0839dc08fb1e4324b30545c05' $ cd submodules/repo-B $ git log --decorate --all commit 3b754aca54077269aedb328c6e738ab8a7ab3077 (master) # current submodule HEAD hash Author: username \u0026lt;username@exmail.com\u0026gt; Date: Sat Dec 5 22:26:21 2015 +0800 Modify _config.yml commit db560723ded8d1a0839dc08fb1e4324b30545c05 (HEAD) # main project submodule hash Author: username \u0026lt;username@exmail.com\u0026gt; Date: Sat Dec 5 21:46:40 2015 +0800 Modify _config.yml, Add two image commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e (origin/master, origin/HEAD) Author: username \u0026lt;username@exmail.com\u0026gt; Date: Tue Dec 1 20:06:31 2015 +0800 Modify _config.yml $ git status HEAD detached at db56072 $ git branch * (HEAD detached at db56072) master  要从根本上摆脱 detached HEAD 的问题，使用 rebase、merge 是正确的方式。\n  git submodule update --rebase the current branch of the submodule will be rebased onto the commit recorded in the superproject.\n  git submodule update --merge the commit recorded in the superproject will be merged into the current branch in the submodule.\n  进一步了解  git Documentation  ","date":1412456475,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1412460075,"objectID":"1e0aa7d560784eb44017e6a966bf2bc6","permalink":"/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","publishdate":"2014-10-04T21:01:15Z","relpermalink":"/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","section":"post","summary":"如何正确使用 git submodule","tags":["git","git submodule"],"title":"git submodule 使用过程中遇到的问题","type":"post"},{"authors":["徐旭栋"],"categories":["PBD. Platform-Based Development"],"content":"今次通过 Hexo 生成静态博客网站，所以配置服务器的流程可以省去，直接托管在 Github Pages 上即可，这也目前轻量级博客的趋势。\n环境安装 Node 环境安装 安装 NVM 在终端中运行如下命令。\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash  安装 Node.js 使用如下命令查找远程库版本。\n$ nvm ls-remote  找到合适的版本并安装。\n$ nvm install 5.1.0  安装 Hexo Hexo 有丰富的插件和主题，如果不能满足需求的话还可以自己动手，使用如下命令全局安装 hexo-cli。\n$ npm install hexo-cli -g  安装 Hexo 所需的依赖包。\n$ npm install hexo-renderer-ejs --save $ npm install hexo-renderer-stylus --save $ npm install hexo-renderer-marked --save  或者直接通过 package.json 一步到位。\n$ npm intall  添加文章 Posts 找个文件夹初始化 Blog 的工作目录。\n$ cd \u0026quot;/path/to/blog\u0026quot; $ hexo init  生成一篇文章。\n$ hexo new \u0026quot;用 Hexo 搭建个人博客\u0026quot;  使用 vim 或者其他 Markdown Editor 编辑文章。\n$ cd source/_posts $ vim 用-Hexo-搭建个人博客.md  附上 Markdown 语法。写完博文之后生成 html、css、.js 等静态网页文件，生成之后的内容在博客根目录 public 文件夹下，里面就是博客需要部署的内容。\n$ hexo generate  启动本地 Hexo 服务器。\n$ hexo server INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.  在浏览器内输入本地服务器地址预览博客。\n部署至 Github 部署到 Github 上用于 Github Pages 的 repo 有两种形式：\n 主页级 repo，页面部署到 master 分支下，访问 Github Pages 时使用 username.github.io，常用于个人主页。 项目级 repo，页面部署到 gh-pages 分支，访问 Github Pages 时使用 username.github.io/repo-name，常用于项目主页。  在 _config.yml 内配置完部署信息后 (deploy 字段) 执行如下命令。\n$ hexo clean $ hexo generate $ hexo deploy  或者使用如下命令。\n$ hexo g $ hexo d  完成部署至 Github，过个几分钟等 Github 更新完缓存再打开 {username}.github.io/{blog-repo} 或者 {username}.github.io 就能看到 Github Pages。\n绑定域名 Github 使用一系列 name-based 虚拟 WWW server 部署所有静态博客的 wwwroot 目录。虚拟服务器的地址就是上文提及的 {username}.github.io 和 {username}.github.io/{repo-name}，因此将需要绑定的域名指向 Github 的服务器 https://github.io，把域名解析权下放到 Github。\n同时 Github 服务器需要知道如何解析域名，所以 Github Pages 用户需要将绑定的域名通过 wwwroot 目录下的 CNAME 文件告知 WWW server 域名 =\u0026gt; repo/branch 的映射关系，所以在根目录 source 文件夹下建立一个 CNAME 文本文件，内容为绑定的域名。\n完成之后，输入命令查询下 dns 解析结果。\n$ dig blog.alchemistxxd.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.8.3-P1 \u0026lt;\u0026lt;\u0026gt;\u0026gt; blog.alchemistxxd.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 45658 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;blog.alchemistxxd.com. IN A ;; ANSWER SECTION: blog.alchemistxxd.com. 600 IN CNAME alchemistxxd.github.io. alchemistxxd.github.io. 2816 IN CNAME github.map.fastly.net. github.map.fastly.net. 142 IN A 103.245.222.133 ;; Query time: 299 msec ;; SERVER: 222.44.10.48#53(222.44.10.48) ;; WHEN: Wed Dec 2 23:41:45 2015 ;; MSG SIZE rcvd: 126  终わり\n进一步了解  Github Pages Hexo.io Hexo Documentation npm Docs  ","date":1402531200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402531200,"objectID":"c4014f9d60b0d41366e3c9a5538c7af3","permalink":"/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","publishdate":"2014-06-12T00:00:00Z","relpermalink":"/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","section":"post","summary":"用 Hexo 搭建个人博客的基本流程","tags":["Web Template System","Hexo","Hugo"],"title":"用 Hexo 搭建个人博客","type":"post"},{"authors":["徐旭栋"],"categories":["Gossip"],"content":"在浮躁快餐文化的催化下，人逐渐变的懒散与缺乏耐性，在这样的环境下要想压抑住浮躁的内心、放平心态好好学习也成了一件非常不容易的事情。\n走马观花是很多人在学习过程中遇到的问题，在从外部获取各种信息时我们总想着尽可能多的去汲取知识，却忽略了对于知识的复习与运用，渐渐的就会丧失了自我思考的能力，并且根据 Forgetting curve，学过的东西如果不用也不整理那要不了多久就会忘的一干二净，所以知识点的沉淀与复习运用是很重要的。于是乎觉着学习的东西要有个地方来沉淀复盘下，一直想趁着有时间搭个博客来纪录下以后学习的历程，沉淀下有关技术学习以及生活的点滴。所以，从今天开始写博文，在学习之路上留下点技术印记。\n","date":1402444800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402531200,"objectID":"d4b5399d0ac9976af3bf876b14d29280","permalink":"/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/","publishdate":"2014-06-11T00:00:00Z","relpermalink":"/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/","section":"post","summary":"学而不思则罔，思而不学则殆","tags":["Essay"],"title":"创篇号","type":"post"},{"authors":["徐旭栋","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Create your slides in Markdown - click the Slides button to check out the example.   Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372636800,"objectID":"ff6a19061a984819d30c916886db56ef","permalink":"/publication/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/example/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]