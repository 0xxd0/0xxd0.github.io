<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>徐旭栋</title><link>/</link><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><description>徐旭栋</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>Copyright © 2014 - 2021 Xudong Xu. 保留所有权利。</copyright><lastBuildDate>Mon, 22 Feb 2021 10:31:29 +0000</lastBuildDate><image><url>/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>徐旭栋</title><link>/</link></image><item><title>Apple Inc.</title><link>/2019/12/12/apple-inc./</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/apple-inc./</guid><description/></item><item><title>Lecture 1 - Introduction Five First Lessons</title><link>/2019/01/01/lecture-1-introduction-five-first-lessons/</link><pubDate>Tue, 01 Jan 2019 10:31:29 +0000</pubDate><guid>/2019/01/01/lecture-1-introduction-five-first-lessons/</guid><description>&lt;h3 id="overview">Overview&lt;/h3>
&lt;p> 
We introduce Game Theory by playing a game. We organize the game into players, their strategies, and their goals or payoffs; and we learn that we should decide what our goals are before we make choices. With some plausible payoffs, our game is a prisoners’ dilemma. We learn that we should never choose a dominated strategy; but that rational play by rational players can lead to bad outcomes. We discuss some prisoners’ dilemmas in the real world and some possible real-world remedies. With other plausible payoffs, our game is a coordination problem and has very different outcomes: so different payoffs matter. We often need to think, not only about our own payoffs, but also others’ payoffs. We should put ourselves in others’ shoes and try to predict what they will do. This is the essence of strategic thinking.&lt;/p>
&lt;h3 id="lecture-chapters">Lecture Chapters&lt;/h3>
&lt;p> &lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">What Is Strategy? [00:00:00]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Strategy: Where Does It Apply? [00:02:16]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">(Administrative Issues) [00:02:54]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Elements of a Game: Strategies, Actions, Outcomes and Payoffs [00:09:40]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Strictly Dominant versus Strictly Dominated Strategies [00:21:38]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Contracts and Collusion [00:29:33]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">The Failure of Collusion and Inefficient Outcomes: Prisoner&amp;rsquo;s Dilemma [00:33:35]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Coordination Problems [00:41:40]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1#" target="_blank" rel="noopener">Lesson Recap [01:07:53]&lt;/a>&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>TRANSCRIPT&lt;/th>
&lt;th>AUDIO&lt;/th>
&lt;th>LOW BANDWIDTH VIDEO&lt;/th>
&lt;th>HIGH BANDWIDTH VIDEO&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1?width=800px&amp;amp;height=600px&amp;amp;inline=true#colorbox-inline-1725096696" target="_blank" rel="noopener">html&lt;/a>&lt;/td>
&lt;td>&lt;a href="http://openmedia.yale.edu/cgi-bin/open_yale/media_downloader.cgi?file=/courses/fall07/econ159/mp3/econ159_01_090507.mp3" target="_blank" rel="noopener">mp3&lt;/a>&lt;/td>
&lt;td>&lt;a href="http://openmedia.yale.edu/cgi-bin/open_yale/media_downloader.cgi?file=/courses/fall07/econ159/mov/chapters/econ159_01_090507.mov" target="_blank" rel="noopener">mov [100MB]&lt;/a>&lt;/td>
&lt;td>&lt;a href="http://openmedia.yale.edu/cgi-bin/open_yale/media_downloader.cgi?file=/courses/fall07/econ159/medium/econ159_01_090507.mov" target="_blank" rel="noopener">mov [500MB]&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="learn-more">Learn More&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://oyc.yale.edu/economics/econ-159/lecture-1" target="_blank" rel="noopener">Lecture 1 - Introduction: Five First Lessons&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>OE-0001 Introduce Swift var, let keyword</title><link>/2016/06/26/oe-0001-introduce-swift-var-let-keyword/</link><pubDate>Sun, 26 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/26/oe-0001-introduce-swift-var-let-keyword/</guid><description>&lt;!-- # 引入 defer 关键字 -->
&lt;ul>
&lt;li>Proposal: &lt;a href="https://github.com/0xxd0/objc-evolution/blob/master/proposal/0001-swift-var-and-let.md" target="_blank" rel="noopener">OE-0001&lt;/a>&lt;/li>
&lt;li>Authors: &lt;a href="https://github.com/0xxd0" target="_blank" rel="noopener">Xudong Xu&lt;/a>&lt;/li>
&lt;li>Status: &lt;strong>Implemented&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>&lt;code>var&lt;/code> 和 &lt;code>let&lt;/code> 是 Swift 定义变量的重要关键字，描述了变量是否可以被修改，将这些关键字引入 Objective-C，以更好地表达变量的可变性。&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>在 Objective-C 中变量声明的 Type Inference 一直没有很好的解决方案，下方的显示类型声明代码是我们经常需要面对的：&lt;/p>
&lt;pre>&lt;code class="language-objc">NSMutableArray&amp;lt;NSString *&amp;gt;* array = [[NSMutableArray&amp;lt;NSString *&amp;gt; array];
&lt;/code>&lt;/pre>
&lt;p>在 Swift 中会由类型推导自动完成：&lt;/p>
&lt;pre>&lt;code class="language-swift">var elements = [String]();
&lt;/code>&lt;/pre>
&lt;h2 id="proposed-solution">Proposed solution&lt;/h2>
&lt;p>在 ObjC 中引入 &lt;code>let&lt;/code> 和 &lt;code>var&lt;/code> 关键字：&lt;/p>
&lt;pre>&lt;code class="language-objc">let elements = [NSMutableArray&amp;lt;NSString *&amp;gt; array];
&lt;/code>&lt;/pre>
&lt;p>影响范围为所有变量声明，并且同时兼容 C/C++。&lt;/p>
&lt;h2 id="detailed-design">Detailed design&lt;/h2>
&lt;p>得益于 Clang 将类型推导特性带入了 pure C，使得我们能在 C 代码中使用 &lt;code>__auto_type&lt;/code> 来做类型推导：&lt;/p>
&lt;pre>&lt;code class="language-c">// File.c
__auto_type str = &amp;quot;string&amp;quot;;
&lt;/code>&lt;/pre>
&lt;p>以 &lt;code>const&lt;/code> 修饰达到 &lt;code>let&lt;/code> 的效果，通过宏实现定义关键字：&lt;/p>
&lt;pre>&lt;code class="language-c">#ifdef __cplusplus
#define var auto
#define let const auto
#else
#define var __auto_type
#define let const __auto_type
#endif
&lt;/code>&lt;/pre>
&lt;p>使 C/ObjC 能像 Swift 一样使用 &lt;code>var&lt;/code> 和 &lt;code>let&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-objc">var vector = std::vector&amp;lt;NSInteger&amp;gt;{1, 2, 3};
let array = NSArray.alloc.init;
let block = ^void (id self, SEL _cmd) {
return;
};
&lt;/code>&lt;/pre>
&lt;h2 id="source-compatibility">Source compatibility&lt;/h2>
&lt;p>此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的语法，不会有任何更改格式正确的代码的行为。&lt;/p>
&lt;h2 id="alternatives-considered">Alternatives considered&lt;/h2>
&lt;p>在 C++ 的环境下，可以通过 &lt;code>auto&lt;/code> 完成类型推导：&lt;/p>
&lt;pre>&lt;code class="language-objc">auto array = [[NSMutableArray&amp;lt;NSString *&amp;gt; array];
&lt;/code>&lt;/pre>
&lt;p>但是这样会引入 C++，对于很多场景下这是没必要的。&lt;/p></description></item><item><title>如何衡量隐含波动率</title><link>/2020/07/28/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87/</link><pubDate>Tue, 28 Jul 2020 15:44:16 +0000</pubDate><guid>/2020/07/28/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87/</guid><description>&lt;p>隐含波动率（或称引申波幅，IV ）是了解何时买卖期权的最重要指标之一。IV 由特定股票或期货的期权合约的当前价格反推得出，用百分比表示，表示基于当前的期权价格，底层标的年化波动预期的标准差。例如，对于 200 美元的股票，IV 的 25％ 表示未来一年的标准差范围为 50 美元，更多关于 IV 的概念可以参考之前的文章。&lt;/p>
&lt;p>由于波动率对期权价格有很大影响，所以通常我们会在波动率较高的环境下作为期权卖方，而在波动率较低的环境时作为期权买方。因此如何衡量波动率的相对高低成为了一个问题，通常不同标的波动率的横向对比并没有太多实际意义，本文就同一标的的情况下，侧重讨论几种衡量 IV 高低的方法。&lt;/p>
&lt;h2 id="implied-volatility-percentile">Implied Volatility Percentile&lt;/h2>
&lt;p>隐含波动率百分位（Implied Volatility Percentile）为交易者提供了一个额外的度量标准来衡量期权价格的相对高低，下文统一用 IVP 描述。52 周 IVP 从当前日期前推一整年，通过观察历史波动率的高低，与当前的 IV 进行对比，计算出过去的一整年中低于当前 IV 值的天数占总天数的百分比。简单来说 IVP 主要统计在历史区间上有多少交易日的 IV 值是低于当前水准的，其公式为：&lt;/p>
&lt;p>$$ IVP = \sum_{i=1}^n [ \frac{ IV_i }{ IV_{ current } } ] \div n $$&lt;/p>
&lt;p>$$ n = Period $$&lt;/p>
&lt;p>通常在各种 Screener 或者 Broker 平台上能找到这个指标。图中的粉色标注的即为 IVP 趋势线，以 AAPL 为例目前的 IVP 为 62.7%，当日的全天平均波动率为 37.04%。&lt;/p>
&lt;p>&lt;img src="https://www.tradingview.com/x/7EPkTWA2/" alt="Implied Volatility Percentile">&lt;/p>
&lt;p>52 周 IVP 通过将 AAPL IV 低于其当前水平的交易日天数除以 252（一年中的交易日数 n = 252）得出的。例如当前的 IVP 为 62.7%，可以理解为 AAPL 的波动率在过去一年的 62.7％（或一年的三分之二）内低于当前的隐含波动率，这表明 AAPL 的波动率在一年内大约三分之二时间内一直低于 37.04％，剩余的三分之一时间内 IV 都高于当前的 37.04%。这个数据意味着相比于过去一年内的 AAPL IV，当前波动率处于较高的三分之一区域，因此当前 IVP 状态下的期权，相对于更低 IVP 周期的期权来说，会更昂贵。&lt;/p>
&lt;h2 id="implied-volatility-rank">Implied Volatility Rank&lt;/h2>
&lt;p>隐含波动率等级（Implied Volatility Rank）这个译文总觉得不怎么顺口，下文依旧还是统一用 IVR 描述。IVR 同样是很多交易员在做期权策略时会考虑的一个衡量指标。基于过去一年的 IV 水平，IVR 可以衡量出当前隐含波动率处于波动率区间的高低位置。同一标的 IVR 越高意味着当前期权的价格越昂贵，通常我们使用过去 52 周的最高 IV 值和最低 IV 作为波动率区间，如果需要计算短期波动率可以使用其他时间段，比如一些交易平台会支持 30 天、90 天、6 个月等等，简单来说 IVR 的主要是和统计区间的历史最高值和最低值去做比较，&lt;/p>
&lt;p>以 AAPL 为例，计算以一年为区间，当前的 IV 值对应的 IVR，首先参考 AAPL 的历史波动率曲线。&lt;/p>
&lt;!-- TradingView Widget BEGIN -->
&lt;div class="tradingview-widget-container">
&lt;div id="tradingview_b0716" style="height:300px">&lt;/div>
&lt;div class="tradingview-widget-copyright">&lt;a href="https://uk.tradingview.com/symbols/NASDAQ-AAPL/" rel="noopener" target="_blank">&lt;span class="blue-text">AAPL Chart&lt;/span>&lt;/a> by TradingView&lt;/div>
&lt;script type="text/javascript" src="https://s3.tradingview.com/tv.js">&lt;/script>
&lt;script type="text/javascript">
new TradingView.widget({
"autosize": true,
"symbol": "NASDAQ:AAPL",
"interval": "D",
"timezone": "Asia/Hong_Kong",
"theme": "light",
"style": "2",
"locale": "uk",
"toolbar_bg": "#f1f3f6",
"enable_publishing": false,
"hide_top_toolbar": true,
"hide_legend": true,
"save_image": false,
"studies": [
"HV@tv-basicstudies"
],
"container_id": "tradingview_b0716"
});
&lt;/script>
&lt;/div>
&lt;!-- TradingView Widget END -->
&lt;p>52 周 IV 最高出现在 2020 年 03 月的熔断，146.69% 左右，52 周最低出现在 2019 年 11 月，为 9.4%，以当前为基准，前推一年期的 IVR 计算公式为：&lt;/p>
&lt;p>$$ IVR = \frac { IV_{ Current } − IV_{ 52LowestLow } }{ IV_{ 52HighestHigh } − IV_{ 52LowestLow} } \times 100 % $$&lt;/p>
&lt;p>2020 年 07 月 28 日，全天隐含波动率的平均值为 37.04%，代入公式计算：&lt;/p>
&lt;p>$$ IV_{ Current } (0.3704) − IV_{ 52LowestLow } (.094) = 0.2764 $$&lt;/p>
&lt;p>$$ IV_{ 52HighestHigh }(1.4669) − IV_{ 52LowestLow } (.094) = 1.3729 $$&lt;/p>
&lt;p>$$ IV Rank = 0.2764/1.3729 = 0.2013 $$&lt;/p>
&lt;p>计算得出的 20.13% 的 IV Rank 意味着当前的 IV 处于过去一整年波动率区间低位 20.13% 处，说明当前的 IV 非常接近 52 周历史低点。在极端的情况下，比如当前 IV 在 1 年内的历史最低点或历史最高点处时，此时的 IVR 会呈现为 0% 或 100%。&lt;/p>
&lt;p>很显然 IVR 和 IVP 的值都在 0 到 1 之间，IVR 通常小于 IVP。两者的值越大，意味着此时 IV 相对历史水平来说更高，所以此时的期权价格也会更贵。由于数据统计复杂度的区别，部分刚接触这些指标的交易者会更青睐只需要统计最大最小值的 IVR，由于 IVR 没有统计意义上的算数平均和加权平均，所以当出现类似 3 月份 Volatility Spikes 的情况下，IV Rank 会出现一定的失真，事实上以 AAPL 为例，接近 40% 的 IV 值从主观角度很难说这是个非常低的 IV，所以在做决策时，IVR 和 IVP 应该作为同向指标一起参考，切忌将这两个指标分开分析，一切指标基于数学，切勿盲目遵循指标。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="tastytradenetwork.squarespace.com/tt/blog/implied-volatility-rank-and-percentile">IV Rank vs. IV Percentile&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.tastytrade.com/tt/shows/market-measures/episodes/ivr-and-ivp-the-numbers-08-30-2016" target="_blank" rel="noopener">IVR and IVP: The Numbers&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Tencent Holding Ltd.</title><link>/2019/12/12/tencent-holding-ltd./</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/tencent-holding-ltd./</guid><description>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.tencent.com/img/index/tencent_logo.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>腾讯科技股份有限公司&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>HT0002 如何在 macOS 上显示隐藏文件和文件夹</title><link>/2017/11/26/ht0002-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Sun, 26 Nov 2017 10:31:29 +0000</pubDate><guid>/2017/11/26/ht0002-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>&lt;p>您可以通过命令行来显示被 Mac 操作系统隐藏的文件和文件夹。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。&lt;/p>
&lt;h2 id="os-x-mavericks-及之后的-mac-操作系统">OS X Mavericks 及之后的 Mac 操作系统&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>完成之后，你将会在 Finder 中看到被隐藏的文件和文件夹。&lt;/li>
&lt;li>如果希望再次一次这些被隐藏的文件和文件夹时，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>【提示】&lt;/strong> 该命令适用于 OS X Mavericks 和 OS X Yosemite 系统。对于还在使用 OS X Mountain Lion 或是更早版本的系统的 Mac 用户来说，请使用如下的命令。&lt;/p>
&lt;h2 id="os-x-mountain-lion-及之前的-mac-操作系统">OS X Mountain Lion 及之前的 Mac 操作系统&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">defaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>完成之后，你将会在 Finder 中看到被隐藏的文件和文件夹。&lt;/li>
&lt;li>如果希望再次一次这些被隐藏的文件和文件夹时，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://support.apple.com/zh-cn/guide/mac-help/mchlp2304/mac" target="_blank" rel="noopener">在 Mac 上显示或隐藏文件扩展名 - Apple 支持&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>OE-0002 Introduce Swift defer keyword</title><link>/2016/06/26/oe-0002-introduce-swift-defer-keyword/</link><pubDate>Sun, 26 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/26/oe-0002-introduce-swift-defer-keyword/</guid><description>&lt;ul>
&lt;li>Proposal: &lt;a href="https://github.com/0xxd0/objc-evolution/blob/master/proposal/0002-introduce-swift-defer.md" target="_blank" rel="noopener">OE-0002&lt;/a>&lt;/li>
&lt;li>Authors: &lt;a href="https://github.com/0xxd0" target="_blank" rel="noopener">Xudong Xu&lt;/a>&lt;/li>
&lt;li>Status: &lt;strong>Implemented&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>&lt;code>defer&lt;/code> 是 Swift 定义变量的重要关键字，用于 Control Flow 在当前作用域退出之后的收尾操作，将 &lt;code>defer&lt;/code> 关键字引入 Objective-C，使 Control Flow 更优雅。&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>&lt;code>defer&lt;/code> 极大的改变了资源的获取与释放的代码编写流程，没有 &lt;code>defer&lt;/code> 的情况下，我们需要在所有的退出语句都加上收尾处理。&lt;/p>
&lt;pre>&lt;code class="language-swift">func foo() {
guard let list = class_copyMethodList(value, &amp;amp;outCount) else {
return
}
if (condition) {
// ...
free(list)
return
}
// ...
free(list)
}
&lt;/code>&lt;/pre>
&lt;p>用了 &lt;code>defer&lt;/code> 之后可以把精力放在 Control Flow 上，而不是在何处处理收尾，Swift 是一门提倡尽早 &lt;code>return&lt;/code> 的语言：&lt;/p>
&lt;pre>&lt;code class="language-swift">// with defer
func foo() {
guard let list = class_copyMethodList(value, &amp;amp;outCount) else {
return
}
defer {
free(list)
}
if (condition) {
// ...
return
}
// ...
return
}
&lt;/code>&lt;/pre>
&lt;h2 id="proposed-solution">Proposed solution&lt;/h2>
&lt;p>得益于 Clang 的 &lt;code>__attribute((cleanup()))&lt;/code> 特性，将 C Block 标记为一个从当前作用域退出之后执行的收尾用匿名函数。&lt;/p>
&lt;h2 id="detailed-design">Detailed design&lt;/h2>
&lt;p>实现参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/0xxd0/objc-evolution/blob/75e73c073dab38d3f464b4bc12dc317b4a247ff1/runtime/swift.h#L29" target="_blank" rel="noopener">runtime/swift.h#L29&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>通过宏定义的 defer，可以做到如下的 Control Flow：&lt;/p>
&lt;pre>&lt;code class="language-c">static pthread_mutex_t lock_key;
void foo() {
pthread_mutex_lock(&amp;amp;lock_key);
defer {
pthread_mutex_unlock(&amp;amp;lock_key);
};
var cls_count = (unsigned)0;
let cls_list = objc_copyClassList(&amp;amp;cls_count);
defer {
free(cls_list);
};
// do sth
}
&lt;/code>&lt;/pre>
&lt;h2 id="source-compatibility">Source compatibility&lt;/h2>
&lt;p>此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的 Control Flow，不会有任何更改格式正确的代码的行为。&lt;/p>
&lt;h2 id="alternatives-considered">Alternatives considered&lt;/h2>
&lt;p>无&lt;/p></description></item><item><title>HT0003 如何在 VMware Fusion 上进行端口映射</title><link>/2018/11/21/ht0003-%E5%A6%82%E4%BD%95%E5%9C%A8-vmware-fusion-%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</link><pubDate>Wed, 21 Nov 2018 10:31:29 +0000</pubDate><guid>/2018/11/21/ht0003-%E5%A6%82%E4%BD%95%E5%9C%A8-vmware-fusion-%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</guid><description>&lt;p>您可以通过编辑 VMware Fusion 的 NAT 配置文件来对端口进行映射。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。&lt;/p>
&lt;h2 id="修改配置文件">修改配置文件&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在获取管理员权限之后，通过 vim 或者手动编辑位于 /Library/Preferences/VMware Fusion.app/vmnet8/nat.conf 的 NAT 配置文件，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo vim /Library/Preferences/VMware\ Fusion.app/vmnet8/nat.conf
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>自定义 incomingtcp 下的端口号（左侧）与虚拟机的端口号（右侧）进行流量转发。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">[incomingtcp]
# Use these with care - anyone can enter into your VM through these...
# The format and example are as follows:
# &amp;lt;external port number&amp;gt; = &amp;lt;VM's IP address&amp;gt;:&amp;lt;VM's port number&amp;gt;
# 8080 = 172.16.3.128:80
&lt;/code>&lt;/pre>
&lt;h2 id="重启-vmware-network">重启 VMware Network&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在获取管理员权限之后，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --stop
sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --start
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>如果需要进一步了解 Fusion 的 NAT 配置，您可以参考 &lt;a href="https://www.vmware.com/support/ws3/doc/ws32_network21.html" target="_blank" rel="noopener">Advanced NAT Configuration&lt;/a>。&lt;/li>
&lt;/ol></description></item><item><title>OE-0003 Protocol Default Implementation</title><link>/2016/06/26/oe-0003-protocol-default-implementation/</link><pubDate>Sun, 26 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/26/oe-0003-protocol-default-implementation/</guid><description>&lt;!-- # 引入 var, let 关键字 -->
&lt;ul>
&lt;li>Proposal: &lt;a href="https://github.com/0xxd0/objc-evolution/blob/master/proposal/0003-protocol-default-implementation.md" target="_blank" rel="noopener">OE-0003&lt;/a>&lt;/li>
&lt;li>Authors: &lt;a href="https://github.com/0xxd0" target="_blank" rel="noopener">Xudong Xu&lt;/a>&lt;/li>
&lt;li>Status: &lt;strong>Implemented&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Swift 中，定义 Protocol 时，可以使用 extension 给某些方法提供默认实现，希望把此特性引入 Objective-C&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>在 Swift 中 Protocol 的默认实现一般为如下形式：&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Foo {
associatedtype Element
func method(_ arg: Element)
}
extension Foo where Element: Equatable {
func method(_ arg: Element) {
}
static func isEqual(_ lhs: Element, _ rhs: Element) -&amp;gt; Bool {
return lhs == rhs
}
}
&lt;/code>&lt;/pre>
&lt;p>对 Objective-C 来说还做不到这么强的泛型约束，但是希望能够做到基本的 Protocol 默认实现，比如给 UICollectionViewDelegate 加上不能选择的默认实现：&lt;/p>
&lt;pre>&lt;code class="language-objc">@extension(UICollectionViewDelegate)
- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {
return false
}
@end
&lt;/code>&lt;/pre>
&lt;h2 id="proposed-solution">Proposed solution&lt;/h2>
&lt;p>通过 ObjC runtime 配合 C Marco，在 &lt;code>dyld load&lt;/code> 之后 &lt;code>Clang Module Init&lt;/code> 之前向 Dummy Class 注入 Protocol 的默认实现。在 &lt;code>Class +load&lt;/code> 时候把默认实现的 &lt;code>Method&lt;/code> 添加到具体的 &lt;code>Class&lt;/code> 里。&lt;/p>
&lt;h2 id="detailed-design">Detailed design&lt;/h2>
&lt;p>实现参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/0xxd0/objc-evolution/blob/75e73c073dab38d3f464b4bc12dc317b4a247ff1/runtime/Extension.h#L20" target="_blank" rel="noopener">runtime/Extension.h#L20&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/0xxd0/objc-evolution/blob/75e73c073dab38d3f464b4bc12dc317b4a247ff1/runtime/Extension.cpp#L17" target="_blank" rel="noopener">runtime/Extension.cpp#L17&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-compatibility">Source compatibility&lt;/h2>
&lt;p>此特性是附加特性，并且不会破坏任何现有代码，只会精简先前繁琐的语法，不会有任何更改格式正确的代码的行为。&lt;/p>
&lt;h2 id="alternatives-considered">Alternatives considered&lt;/h2>
&lt;p>在 C++ 的环境下，可以通过 &lt;code>auto&lt;/code> 完成类型推导：&lt;/p>
&lt;pre>&lt;code class="language-objc">auto array = [[NSMutableArray&amp;lt;NSString *&amp;gt; array];
&lt;/code>&lt;/pre>
&lt;p>但是这样会引入 C++，对于很多场景下这是没必要的。&lt;/p></description></item><item><title>建筑及相关服务</title><link>/cipcode/04/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/04/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="0402-建筑httpsncesedgovipedscipcodecipdetailaspxy56cipid90267">04.02) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90267" target="_blank" rel="noopener">建筑.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-040200-建筑学预科httpsncesedgovipedscipcodecipdetailaspxy56cipid91756">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 04.0200) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=91756" target="_blank" rel="noopener">建筑学预科.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s1-hbhb-040201-建筑学httpsncesedgovipedscipcodecipdetailaspxy56cipid90268">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 04.0201) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90268" target="_blank" rel="noopener">建筑学.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s2-hbhb-040202-建筑设计httpsncesedgovipedscipcodecipdetailaspxy56cipid91759">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 04.0202) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=91759" target="_blank" rel="noopener">建筑设计.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s3-hbhb-040299-建筑学-其他httpsncesedgovipedscipcodecipdetailaspxy56cipid92997">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 04.0299) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=92997" target="_blank" rel="noopener">建筑学, 其他.&lt;/a>&lt;/h4>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=04" target="_blank" rel="noopener">Detail for CIP Code 04&lt;/a>.&lt;/li>
&lt;/ol>
&lt;!-- MINI HOUSE [Ouroboros arq](https://www.facebook.com/ouroborosarq/) -->
&lt;!--
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/mALTsnF2XRU" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
--></description></item><item><title>TESLA, Inc.</title><link>/2019/12/12/tesla-inc./</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/tesla-inc./</guid><description>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/b/bd/Tesla_Motors.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>NIO Inc.</title><link>/2019/12/12/nio-inc./</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/nio-inc./</guid><description>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/en/9/93/Nio_2020_Logo.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>HT0007 如何使用 SSL 证书签名 iOS .mobileconfig 文件</title><link>/2018/12/09/ht0007-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D-ios-.mobileconfig-%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 09 Dec 2018 10:31:29 +0000</pubDate><guid>/2018/12/09/ht0007-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D-ios-.mobileconfig-%E6%96%87%E4%BB%B6/</guid><description>&lt;p>您可以使用证书与 OpenSSL 签名 iOS 平台 .mobileconfig 文件。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。iPhoneOS / iPadOS 设备上的配置描述文件（.mobileconfig）是以 .plist 为载体，包含了设备安全策略、VPN 配置信息、Wi-Fi 设置、APN 设置、Exchange 帐户设置、Google 帐户设置、邮件设置以及允许 iPhone, iPod touch, iPad 与企业系统配合使用的证书。本文描述了开发者如何使用 SSL Certification 对 . mobileconfig 文件进行签名，以确保 iPhoneOS / iPadOS 系统上的安全性。&lt;/p>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;h3 id="理解证书的状态">理解证书的状态&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>状态&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Unsigned&lt;/td>
&lt;td>The mobileconfig is not signed by anyone. Therefore the source is unknown.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Unverified&lt;/td>
&lt;td>The mobileconfig is signed, but the source is not recognized as trusted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Verified&lt;/td>
&lt;td>The mobileconfig is signed and is recognized as a trusted source.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>当使用 Apple Configurator 2 为 iPhoneOS / iPadOS 添加 Profile 文件时，未签名的 .mobileconfig 文件会被标记为 &amp;ldquo;Unsigned&amp;rdquo; 状态，修复此问题我们需要对 Profile 进行签名。&lt;/p>
&lt;h3 id="准备所需要的文件">准备所需要的文件&lt;/h3>
&lt;ol>
&lt;li>未签名的 .mobileconfig 文件，&lt;strong>UnsignedProfile.mobileconfig&lt;/strong>&lt;/li>
&lt;li>证书对应 Private Key，&lt;strong>PrivateKey.pem&lt;/strong>&lt;/li>
&lt;li>与 SSL 证书对应的证书链（中级证书），&lt;strong>CertChain.pem&lt;/strong>&lt;/li>
&lt;li>受信任的 SSL 证书，自签名证书、TrustAsia, Let’s Encrypt 等签发的免费 SSL 证书，商业 SSL 证书，&lt;strong>Certificate.pem&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h3 id="签名方式">签名方式&lt;/h3>
&lt;pre>&lt;code class="language-bash">openssl smime
-sign \
-in UnsignedProfile.mobileconfig \
-out SignedProfile.mobileconfig \
-signer Certificate.pem \
-inkey PrivateKey.pem \
-certfile CertChain.pem \
-outform der -nodetach
&lt;/code>&lt;/pre>
&lt;h2 id="使用自签名证书签名">使用自签名证书签名&lt;/h2>
&lt;p>创建可引导安装器后，请按照以下步骤进行使用：&lt;/p>
&lt;h3 id="从-keychain-access-导出自签名证书">从 Keychain Access 导出自签名证书&lt;/h3>
&lt;p>Keychain Access -&amp;gt; Certificate Assistance -&amp;gt; Create a Certificate，根据提示创建证书，创建完成之后对证书私钥进行导出，右键证书点击 Export 导出 Certificate.per，右键私钥点击 Export 导出 PrivateKey.p12，通过命令行将 .p12 转换为 .pem，将 Certificate.per 转换为 Certificate.pem。&lt;/p>
&lt;pre>&lt;code class="language-bash">openssl pkcs12 -in PrivateKey.p12 -out PrivateKey.pem -nodes
openssl x509 -trustout -inform DER -outform PEM -in Certificate.cer -out Certificate.pem
&lt;/code>&lt;/pre>
&lt;h3 id="下载根证书和中间证书">下载根证书和中间证书&lt;/h3>
&lt;p>本文使用 AppleIncRootCertificate.cer 根证书和 AppleApplicationIntegrationCA5G1.cer 中间证书，更多证书可以访问 Apple PKI。下载完成后通过命令行从 Root Certificate 和 Intermediate Certificate 提取 Certificates 和 Keys，参考 &lt;a href="info.ssl.com/article.aspx?id=12149">INFO.SSL&lt;/a>。&lt;/p>
&lt;pre>&lt;code class="language-bash">openssl x509 -trustout -inform DER -outform PEM -in AppleIncRootCertificate.cer -out Root.pem
openssl x509 -trustout -inform DER -outform PEM -in AppleApplicationIntegrationCA5G1.cer -out Intermediate.pem
&lt;/code>&lt;/pre>
&lt;p>将 Intermediate.pem 和 Root.pem 中的文本内容合并为一份文件 AppleIncCertificateChain.pem，此时 AppleIncCertificateChain.pem 将会包含两份证书。&lt;/p>
&lt;h3 id="签名">签名&lt;/h3>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在获取管理员权限之后，在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">openssl smime \
-sign \
-in UnsignedProfile.mobileconfig \
-out SignedProfile.mobileconfig \
-signer Certificate.pem \
-inkey PrivateKey.pem \
-certfile AppleIncCertificateChain.pem \
-outform der -nodetach
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://letsencrypt.org/" target="_blank" rel="noopener">Free SSL/TLS Certificates&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/2363234" target="_blank" rel="noopener">possible status of a mobileconfig? - Apple Community&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.apple.com/certificateauthority/" target="_blank" rel="noopener">Apple PKI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://support.apple.com/zh-cn/guide/server/apd2474fbab/mac" target="_blank" rel="noopener">在 macOS 服务器中创建自签名证书 - Apple 支持&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>BERKSHIRE HATHAWAY INC.</title><link>/2019/12/12/berkshire-hathaway-inc./</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/berkshire-hathaway-inc./</guid><description>&lt;p>BERKSHIRE HATHAWAY ANNUAL &amp;amp; INTERIM REPORTS&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Year&lt;/th>
&lt;th>1st&lt;/th>
&lt;th>2nd&lt;/th>
&lt;th>3rd&lt;/th>
&lt;th>Annual*&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Quarter&lt;/td>
&lt;td>Quarter&lt;/td>
&lt;td>Quarter&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2020&lt;/td>
&lt;td>&lt;a href="https://www.berkshirehathaway.com/qtrly/1stqtr20.pdf" target="_blank" rel="noopener">
&lt;i class="fas fa-file-pdf pr-1 fa-fw">&lt;/i> 1stqtr20&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://www.berkshirehathaway.com/qtrly/2ndqtr20.pdf" target="_blank" rel="noopener">
&lt;i class="fas fa-file-pdf pr-1 fa-fw">&lt;/i> 2ndqtr20&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://www.berkshirehathaway.com/qtrly/3rdqtr20.pdf" target="_blank" rel="noopener">
&lt;i class="fas fa-file-pdf pr-1 fa-fw">&lt;/i> 3rdqtr20&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>Netflix</title><link>/2019/12/12/netflix/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/netflix/</guid><description>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>计算机与信息科学及支持服务</title><link>/cipcode/11/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/11/</guid><description>&lt;ul class="cta-group">
&lt;li>
&lt;a href="https://www.acm.org/binaries/content/assets/education/cs2013_web_final.pdf" target="_blank" rel="noopener" class="btn btn-primary px-3 py-3">Computer Science Curricula 2013&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="1102-计算机编程httpsncesedgovipedscipcodecipdetailaspxy56cip1102">11.02) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.02" target="_blank" rel="noopener">计算机编程.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s1-hbhb-110201-计算机编程程序设计师-常规httpsncesedgovipedscipcodecipdetailaspxy56cip110201">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 11.0201) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.0201" target="_blank" rel="noopener">计算机编程/程序设计师, 常规.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s2-hbhb-110204-计算机游戏编程httpsncesedgovipedscipcodecipdetailaspxy56cip110204">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 11.0204) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.0204" target="_blank" rel="noopener">计算机游戏编程.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s3-hbhb-110299-计算机编程-其他httpsncesedgovipedscipcodecipdetailaspxy56cip110299">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 11.0299) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.0299" target="_blank" rel="noopener">计算机编程, 其他.&lt;/a>&lt;/h4>
&lt;h3 id="1107-计算机科学httpsncesedgovipedscipcodecipdetailaspxy56cip1107">11.07) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.07" target="_blank" rel="noopener">计算机科学.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s4-hbhb-110701-计算机科学httpsncesedgovipedscipcodecipdetailaspxy56cip110701">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 11.0701) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11.0701" target="_blank" rel="noopener">计算机科学.&lt;/a>&lt;/h4>
&lt;p>
&lt;div class="col-12 ">
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/">深入了解 Protocol Buffers&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">
&lt;i class="fab fa-google mr-1">&lt;/i>
protobuf
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/">深入了解 QUIC Transport Protocol&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/draft-ietf-quic-transport-34.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
draft-ietf-quic-transport-34
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/">深入了解 HTTPS&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc2818.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 2818
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/">深入了解 HTTP&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc2616.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
HTTP/1.1 - RFC 2616
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/">深入了解 WebSocket Protocol&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc6455.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 6455
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/">深入了解 TCP&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc793.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 793
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/">深入了解 UDP&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc768.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 768
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc8085.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 8085
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/">再谈 Swift Performance&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/">Whole-Module Optimization 分析&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/">Swift 设计哲学&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/06/25/introduce-objective-c-evolution/">Introduce Objective-C Evolution&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="/project/project-objc-evolution/">
项目
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/">什么是数字签名【译注】&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">
&lt;i class="fas fa-external-link-alt mr-1">&lt;/i>
Original Post
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/">快速枚举与迭代器&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2015).
&lt;a href="/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">Clang Attributes 使用文档&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2015).
&lt;a href="/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/">Xcode 插件整理&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/">关于 NSURL &amp;#43;URLWithString: 返回 nil&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">git submodule 使用过程中遇到的问题&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">用 Hexo 搭建个人博客&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="col-12 ">
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2021).
&lt;a href="/2021/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2021-%E6%98%A5/">操作系统 2021 春&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://github.com/LearningOS/os-lectures" target="_blank" rel="noopener">
&lt;i class="fab fa-github mr-1">&lt;/i>
GitHub
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="http://os.cs.tsinghua.edu.cn/oscourse/OS2021spring" target="_blank" rel="noopener">
&lt;i class="far fa-graduation-cap mr-1">&lt;/i>
OS2021 spring
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/12/27/ht0025-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%A3%80%E8%A7%86-pci-%E8%AE%BE%E5%A4%87/">HT0025 如何在 macOS 上检视 PCI 设备&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/">HT0013 如何向 iOS 系统中添加自定义字体&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/12/09/ht0007-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D-ios-.mobileconfig-%E6%96%87%E4%BB%B6/">HT0007 如何使用 SSL 证书签名 iOS .mobileconfig 文件&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/11/21/ht0003-%E5%A6%82%E4%BD%95%E5%9C%A8-vmware-fusion-%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/">HT0003 如何在 VMware Fusion 上进行端口映射&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/11/09/ht0022-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84-macos-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/">HT0022 如何创建可引导的 macOS 安装镜像&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2018).
&lt;a href="/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/">HT0026 未越狱如何降级 iOS 应用版本&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/11/26/ht0002-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/">HT0002 如何在 macOS 上显示隐藏文件和文件夹&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/post/tech-for-good/tsinghua-oscourse/">清华大学计算机系操作系统&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://github.com/LearningOS" target="_blank" rel="noopener">
&lt;i class="fab fa-github mr-1">&lt;/i>
the Learning Hub of OS Course
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="http://os.cs.tsinghua.edu.cn/oscourse/" target="_blank" rel="noopener">
&lt;i class="far fa-graduation-cap mr-1">&lt;/i>
oscourse
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/post/tech-for-good/deep-dive-into-ssl-tls/">深入了解 SSL/TLS Protocol&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://toolietf.org/pdf/rfc6101.pdfs." target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 6101
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc2246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 2246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc4346.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 4346
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc5246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 5246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc8446.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 8446
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/09/tls-record-protocol/">TLS Record Protocol&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/05/09/tls-handshaking-protocols/">TLS Handshaking Protocols&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2017).
&lt;a href="/2017/01/11/ht0030-%E5%A6%82%E4%BD%95%E5%9C%A8-icloud-%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%87%E4%BB%B6/">HT0030 如何在 iCloud 中屏蔽不需要同步的文件&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/post/tech-for-good/apple-swift/">深入了解 Swift 源码&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;/span>
(2016).
&lt;a href="/2016/06/26/oe-0001-introduce-swift-var-let-keyword/">OE-0001 Introduce Swift var, let keyword&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;/span>
(2016).
&lt;a href="/2016/06/26/oe-0003-protocol-default-implementation/">OE-0003 Protocol Default Implementation&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;/span>
(2016).
&lt;a href="/2016/06/26/oe-0002-introduce-swift-defer-keyword/">OE-0002 Introduce Swift defer keyword&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/post/tech-for-good/objc-evolution-proposals/">The Objective-C Programming Language Evolution&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2015).
&lt;a href="/post/tech-for-good/objc-runtime-101/">深入了解 Objective Runtime&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="/project/project-objc4/">
项目
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2015).
&lt;a href="/post/tech-for-good/enhancing-productivity-with-mac/">使用 Mac 提高生产力&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/div>&lt;/p>
&lt;h2 id="归档方案">归档方案&lt;/h2>
&lt;h3 id="苹果文档的执行方式">苹果文档的执行方式&lt;/h3>
&lt;p>目前苹果知识库主要以 HT 和 Apple Developer Documentation 为主，任何产品相关的问题都在 Apple Support 以 HT 形式进行发布，Apple Developer Documentation 则服务于开发者。苹果在早期通过命名前缀的方式来对各种类型的文档进行分类、组织以及归档：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>HT 前缀的文章为 How to，用于解答产品使用问题等，目前仍服务于官网 Apple Support，例如 &lt;a href="https://support.apple.com/en-us/HT201485" target="_blank" rel="noopener">If you forgot the answers to your Apple ID security questions - Apple Support&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TN 前缀的文章为 Technical Note，服务于开发者，例如 &lt;a href="https://developer.apple.com/library/archive/technotes/tn2431/_index.html" target="_blank" rel="noopener">Technical Note TN2431: App Testing Guide&lt;/a>，目前苹果已经对 TN 系列文章进行归档并停止维护，并迁移至 &lt;a href="https://developer.apple.com/documentation/" target="_blank" rel="noopener">Featured | Apple Developer Documentation&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TS 前缀的文章通常表示为 Troubleshoot，用于排查各类产品的软硬件问题，例如 &lt;a href="https://support.apple.com/en-us/TS2000" target="_blank" rel="noopener">Mac doesn&amp;rsquo;t start up from disc - Apple Support&lt;/a>，目前苹果也对 TS 系列文章归档并停止维护，并迁移至 HT 系列。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TA 前缀的文章表示为 Technical Article，用于发布一些软硬件相关的技术信息与文档等，例如 &lt;a href="https://support.apple.com/kb/TA29664?locale=en_US&amp;amp;viewlocale=en_US" target="_blank" rel="noopener">Apple 500MB &amp;amp; 1GB Hard Drives: SCSI Pin Configuration&lt;/a>、&lt;a href="https://support.apple.com/kb/TA45611?locale=en_US" target="_blank" rel="noopener">NeXTSTEP 3.3 Driver: 3Com EtherLink III&lt;/a>，目前苹果已对 TA 系列文章归档并停止维护。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="计算机科学知识库">计算机科学知识库&lt;/h3>
&lt;p>知识库的索引和技术文档的实施方案，针对本博客如何建立个人计算机科学知识库的执行的方案。&lt;/p>
&lt;p>参考苹果的组织方式，将知识库模版分为 HT 模版和 Developer Documentation 模版：&lt;/p>
&lt;ul>
&lt;li>HT 文章命名采取 HT&amp;lt;版号递增&amp;gt; &amp;lt;标题&amp;gt;，主要承载各类软硬件的使用、配置、问题排查。&lt;/li>
&lt;li>Developer Documentation 文章命名采取 TN&amp;lt;版号递增&amp;gt; &amp;lt;标题&amp;gt;，主要承载开发者相关的技术沉淀。&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=11" target="_blank" rel="noopener">Detail for CIP Code 11&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>苹果文档相&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/library/archive/sitemap.php" target="_blank" rel="noopener">Documentation Archive&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/8073603" target="_blank" rel="noopener">A List of the latest posted kbase articles - Apple Community&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/7017106" target="_blank" rel="noopener">the meaning of Apple articles prefixes li… - Apple Community&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/4030257" target="_blank" rel="noopener">What&amp;rsquo;s up with HT#### and TS####? - Apple Community&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/docs/DOC-4791" target="_blank" rel="noopener">Knowledgebase links of the info.apple.com… - Apple Community&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/2527240" target="_blank" rel="noopener">Apple Knowledge base (kb) articles - Apple Community&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>HT0013 如何向 iOS 系统中添加自定义字体</title><link>/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/</link><pubDate>Mon, 10 Dec 2018 10:31:29 +0000</pubDate><guid>/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/</guid><description>&lt;p>为 iPhoneOS / iPadOS 设备添加自定义字体。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。&lt;/p>
&lt;h2 id="概览">概览&lt;/h2>
&lt;p>iOS 并不限制第三方添加字体到系统之中，当你有自定义字体想在你的 app 或者其他系统内建应用（e.g. Notes.app, Pages.app）中使用时，通过 iOS 提供的多种方法你可以实现不同的结果。&lt;/p>
&lt;h2 id="为应用添加自定义字体">为应用添加自定义字体&lt;/h2>
&lt;p>为一个 app 添加字体，字体的使用范围限制于当前 app 之中，如图所示，将字体拖入至工程，并勾选对应的 Target Membership。&lt;/p>
&lt;figure id="figure-adding-a-custom-font-to-your-app">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://docs-assets.developer.apple.com/published/35bc80c902/d373ed5c-a36b-46fe-9bd8-bf49700072be.png" alt="Adding a Custom Font to Your App" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Adding a Custom Font to Your App
&lt;/figcaption>&lt;/figure>
&lt;p>通过 Info.plist &lt;strong>UIAppFonts&lt;/strong> (Fonts provided by application) 字段向 Xcode 工程注册字体，完成之后就可以像其他 iOS 内建字体一样使用你的自定义字体。&lt;/p>
&lt;p>更多请参考 Apple 文档 &lt;a href="https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app" target="_blank" rel="noopener">Adding a Custom Font to Your App | Apple Developer Documentation&lt;/a>。&lt;/p>
&lt;h2 id="向-ios-系统注册自定义字体">向 iOS 系统注册自定义字体&lt;/h2>
&lt;p>为系统内建的应用提供自定字体需要用到 iOS 13 新提供的 CoreText 的 API，同时需要在 App.entitlements 中添加 Fonts Capability 并勾选 Install Fonts，使用字体时需要勾选 Use Installed Fonts。&lt;/p>
&lt;figure id="figure-wwdc19-session-227">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="WWDC19 Session 227" srcset="
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManagerRegisterFontURLS_hucfda22ca6c1719673d5d88e7507b81b7_232878_9ca56f76f669a9bb2328814904fa0a72.png 400w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManagerRegisterFontURLS_hucfda22ca6c1719673d5d88e7507b81b7_232878_9247fa423d8040f4d4794ff63936225f.png 760w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManagerRegisterFontURLS_hucfda22ca6c1719673d5d88e7507b81b7_232878_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManagerRegisterFontURLS_hucfda22ca6c1719673d5d88e7507b81b7_232878_9ca56f76f669a9bb2328814904fa0a72.png"
width="760"
height="265"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
WWDC19 Session 227
&lt;/figcaption>&lt;/figure>
&lt;figure id="figure-adding-a-custom-font-to-your-app">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://docs-assets.developer.apple.com/published/1b7e45d9c2/f9329213-4abb-413e-a339-4b91ee4bf554.png" alt="Adding a Custom Font to Your App" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Adding a Custom Font to Your App
&lt;/figcaption>&lt;/figure>
&lt;p>如果其他 app 需要使用通过 CTFontManagerRegisterFontURLS 进行注册的字体，需要通过 CTFontManagerRequestFonts 进行 request 才能获得字体。&lt;/p>
&lt;figure id="figure-wwdc19-session-227">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="WWDC19 Session 227" srcset="
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManager_hufa3c300f7b67ee5ae15dbf3386edc981_197468_d835121eea6317e508f6ec0613a1a020.png 400w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManager_hufa3c300f7b67ee5ae15dbf3386edc981_197468_3f5f43825a98d8037f1011dc43c66f45.png 760w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManager_hufa3c300f7b67ee5ae15dbf3386edc981_197468_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/CTFontManager_hufa3c300f7b67ee5ae15dbf3386edc981_197468_d835121eea6317e508f6ec0613a1a020.png"
width="760"
height="308"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
WWDC19 Session 227
&lt;/figcaption>&lt;/figure>
&lt;p>更多请参考 &lt;a href="https://developer.apple.com/videos/play/wwdc2019/227/" target="_blank" rel="noopener">Font Management and Text Scaling - WWDC 2019 - Videos - Apple Developer&lt;/a>。&lt;/p>
&lt;h2 id="通过-mobileconfig-向-ios-系统添加自定义字体">通过 .mobileconfig 向 iOS 系统添加自定义字体&lt;/h2>
&lt;p>通过 CoreText 提供的 API 有需要使用 CTFontManagerRequestFonts 的限制，所以无法适用于部分没有使用此 API 的 app (e.g. Notes.app)，因此可以通过 Apple Configurator 2 生成字体 Profile 来配置字体，打开 Apple Configurator 2 并切换到 Fonts 页面，点击右侧的 Configure，就会弹出对话框要求选择字体。
单个描述文件的容量上限约为 20 megabytes，所以对于较小西文字体文件，可以将整个 Font Family 配置到同一个描述文件中，对于较大的非西文字体，则应该逐个单独添加。&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/apple-configurator-2_hue98665b1bff3ce65595dad0b7d546b64_380522_0f4b7d4bad2f0c26aeda9a2d176e8267.png 400w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/apple-configurator-2_hue98665b1bff3ce65595dad0b7d546b64_380522_83820084f4395201ee05488b62318eb0.png 760w,
/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/apple-configurator-2_hue98665b1bff3ce65595dad0b7d546b64_380522_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/12/10/ht0013-%E5%A6%82%E4%BD%95%E5%90%91-ios-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/apple-configurator-2_hue98665b1bff3ce65595dad0b7d546b64_380522_0f4b7d4bad2f0c26aeda9a2d176e8267.png"
width="760"
height="659"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app" target="_blank" rel="noopener">Adding a Custom Font to Your App | Apple Developer Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/227/" target="_blank" rel="noopener">Font Management and Text Scaling - WWDC 2019 - Videos - Apple Developer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/57653398/ios-13-custom-fonts-download-and-installation" target="_blank" rel="noopener">iOS 13 Custom Fonts download and installation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fonts.google.com" target="_blank" rel="noopener">Browse Fonts - Google Fonts&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.google.cn/get/noto/" target="_blank" rel="noopener">Google Noto Fonts&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>工程学</title><link>/cipcode/14/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/14/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="1401-工程学-常规-engineering-generalhttpsncesedgovipedscipcodecipdetailaspxy56cip1401">14.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=14.01" target="_blank" rel="noopener">工程学, 常规 Engineering, General.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-140101-工程学-常规-engineering-generalhttpsncesedgovipedscipcodecipdetailaspxy56cip140101">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 14.0101) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=14.0101" target="_blank" rel="noopener">工程学, 常规 Engineering, General.&lt;/a>&lt;/h4>
&lt;h3 id="1410-电气-电子-与通信工程-electrical-electronics-and-communications-engineeringhttpsncesedgovipedscipcodecipdetailaspxy56cip1410">14.10) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=14.10" target="_blank" rel="noopener">电气, 电子, 与通信工程 Electrical, Electronics, and Communications Engineering.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s1-hbhb-141001-电气与电子工程-electrical-and-electronics-engineeringhttpsncesedgovipedscipcodecipdetailaspxy56cip141001">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 14.1001) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=14.1001" target="_blank" rel="noopener">电气与电子工程 Electrical and Electronics Engineering.&lt;/a>&lt;/h4>
&lt;h5 id="central-processing-unit-cpu">Central Processing Unit (CPU)&lt;/h5>
&lt;p>&lt;a href="https://www.intel.com/content/www/us/en/products/chipsets.html" target="_blank" rel="noopener">Intel Chipset Products&lt;/a>&lt;/p>
&lt;p>&lt;strong>Security Issue&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html" target="_blank" rel="noopener">Project Zero: Reading privileged memory with a side-channel&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://lkml.org/lkml/2018/1/3/797" target="_blank" rel="noopener">LKML: Linus Torvalds: Re: Avoid speculative indirect calls in kernel&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://newsroom.intel.com/news/intel-responds-to-security-research-findings/#gs.dl9pi8" target="_blank" rel="noopener">Intel Responds to Security Research Findings&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://newsroom.intel.com/news/intel-security-issue-update-addressing-reboot-issues/#gs.dl694l" target="_blank" rel="noopener">Intel Security Issue Update: Addressing Reboot Issues&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Pipeline&lt;/p>
&lt;p>MIPS&lt;/p>
&lt;p>ARM Chipset&lt;/p>
&lt;p>Wave Computing&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=14" target="_blank" rel="noopener">Detail for CIP Code 14&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Electronic_engineering" target="_blank" rel="noopener">Electronic engineering - Wikipedia&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/International_Electrotechnical_Commission" target="_blank" rel="noopener">International Electrotechnical Commission - Wikipedia&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/International_Telecommunication_Union" target="_blank" rel="noopener">International Telecommunication Union - Wikipedia&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Organization&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://www.ieee.org/" target="_blank" rel="noopener">IEEE&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.iec.ch/" target="_blank" rel="noopener">IEC&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.itu.int/en/Pages/default.aspx" target="_blank" rel="noopener">ITU&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>外语, 文学, 和语言学</title><link>/cipcode/16/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/16/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="1601-linguistic-comparative-and-related-language-studies-and-serviceshttpsncesedgovipedscipcodecipdetailaspxy56cip1601">16.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=16.01" target="_blank" rel="noopener">Linguistic, Comparative, and Related Language Studies and Services.&lt;/a>&lt;/h3>
&lt;h3 id="1603-东亚语言-文学-和语言学httpsncesedgovipedscipcodecipdetailaspxy56cip1603">16.03) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=16.03" target="_blank" rel="noopener">东亚语言, 文学, 和语言学.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-160302-日本语和文学httpsncesedgovipedscipcodecipdetailaspxy56cip160302">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 16.0302) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=16.0302" target="_blank" rel="noopener">日本语和文学.&lt;/a>&lt;/h4>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=16" target="_blank" rel="noopener">Detail for CIP Code 16&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>家庭与消费者科学/人文科学</title><link>/cipcode/19/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/19/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="1905-食物-营养-与相关服务httpsncesedgovipedscipcodecipdetailaspxy56cip1905">19.05) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=19.05" target="_blank" rel="noopener">食物, 营养, 与相关服务.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-190504-人类营养学-human-nutritionhttpsncesedgovipedscipcodecipdetailaspxy56cip190504">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 19.0504) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=19.0504" target="_blank" rel="noopener">人类营养学 Human Nutrition.&lt;/a>&lt;/h4>
&lt;p>&lt;strong>Protein&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/zh-cn/%e9%9b%9e%e8%9b%8b" target="_blank" rel="noopener">&lt;strong>雞蛋&lt;/strong>&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>蛋白质&lt;/th>
&lt;th>单位蛋白质热量 (Kcal/g)&lt;/th>
&lt;th>单位蛋白质脂肪 (g/g)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>全蛋&lt;/td>
&lt;td>12.3&lt;/td>
&lt;td>1.18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>蛋白&lt;/td>
&lt;td>5.15&lt;/td>
&lt;td>0.008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>蛋白粉&lt;/td>
&lt;td>5&lt;/td>
&lt;td>0.05&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>营养成分&lt;/th>
&lt;th>单位&lt;/th>
&lt;th>每 100 克含量&lt;/th>
&lt;th>每只 (60g) 含量&lt;/th>
&lt;th>每 100 克鸡蛋白含量&lt;/th>
&lt;th>每只鸡蛋白 (30g) 含量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>水&lt;/td>
&lt;td>克&lt;/td>
&lt;td>74.6&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>能量&lt;/td>
&lt;td>千卡&lt;/td>
&lt;td>155&lt;/td>
&lt;td>93&lt;/td>
&lt;td>60&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>蛋白质&lt;/td>
&lt;td>克&lt;/td>
&lt;td>12.6&lt;/td>
&lt;td>7.5&lt;/td>
&lt;td>11.6&lt;/td>
&lt;td>3.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>脂肪&lt;/td>
&lt;td>克 10.6&lt;/td>
&lt;td>6.4&lt;/td>
&lt;td>0.1&lt;/td>
&lt;td>0.03&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>碳水化合物&lt;/td>
&lt;td>克&lt;/td>
&lt;td>1.1&lt;/td>
&lt;td>&lt;/td>
&lt;td>3.1&lt;/td>
&lt;td>0.9&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=19" target="_blank" rel="noopener">Detail for CIP Code 19&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://athleanx.com/protein" target="_blank" rel="noopener">ATHLEAN-X GUIDE TO PROTEINS&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>HT0022 如何创建可引导的 macOS 安装镜像</title><link>/2018/11/09/ht0022-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84-macos-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/</link><pubDate>Fri, 09 Nov 2018 10:31:29 +0000</pubDate><guid>/2018/11/09/ht0022-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84-macos-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/</guid><description>&lt;p>您可以将磁盘镜像用作安装 Mac 操作系统的启动磁盘。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。&lt;a href="https://support.apple.com/zh-cn/HT201475" target="_blank" rel="noopener">升级 macOS&lt;/a> 或&lt;a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">重新安装 macOS&lt;/a> 不需要安装器，但如果您在多台电脑上安装 macOS 时，可引导安装器就会很有用。&lt;/p>
&lt;h2 id="创建可引导安装器需要满足的条件">创建可引导安装器需要满足的条件&lt;/h2>
&lt;ul>
&lt;li>备用宗卷（格式化为 Mac OS 扩展格式），至少有 13 GB 可用储存空间&lt;/li>
&lt;li>已下载 macOS Big Sur、Catalina、Mojave、High Sierra 或 El Capitan 的安装器&lt;/li>
&lt;/ul>
&lt;h2 id="下载-macos">下载 macOS&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>下载：&lt;a href="https://itunes.apple.com/cn/app/macos-big-sur/id1526878132?ls=1&amp;amp;mt=12" target="_blank" rel="noopener">macOS Big Sur&lt;/a>、&lt;a href="https://itunes.apple.com/cn/app/macos-catalina/id1466841314?ls=1&amp;amp;mt=12" target="_blank" rel="noopener">macOS Catalina&lt;/a>、&lt;a href="https://itunes.apple.com/cn/app/macos-mojave/id1398502828?ls=1&amp;amp;mt=12" target="_blank" rel="noopener">macOS Mojave&lt;/a> 或 &lt;a href="https://itunes.apple.com/cn/app/macos-high-sierra/id1246284741?ls=1&amp;amp;mt=12" target="_blank" rel="noopener">macOS High Sierra&lt;/a>
这些内容将作为名为“安装 macOS [版本名称]”的 App 下载到您的“应用程序”文件夹。如果安装器在下载后打开，请退出而不要继续安装。要获取正确的安装器，请从运行 &lt;a href="https://support.apple.com/zh-cn/HT201260" target="_blank" rel="noopener">macOS Sierra 10.12.5 或更高版本&lt;/a>或者 El Capitan 10.11.6 的 Mac 中进行下载。如果您是企业管理员，请通过 Apple 下载，而不要通过本地托管的软件更新服务器进行下载。 &lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载：&lt;a href="updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg">OS X El Capitan&lt;/a>
这个内容将作为名为“InstallMacOSX.dmg”的磁盘映像下载。在与 El Capitan 兼容的 Mac 上，打开下载的磁盘映像，并运行其中名为 InstallMacOSX.pkg 的安装器。它会在您的“应用程序”文件夹中安装一个名为“安装 OS X El Capitan”的 App。您将通过这个 App（而不是磁盘映像或 .pkg 安装器）创建可引导安装器。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="在终端中使用-hdiutil-命令">在“终端”中使用 “hdiutil” 命令&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在“终端”中键入或粘贴以下命令，按下 Return 键以输入命令，创建安装镜像。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">hdiutil create -o ~/Desktop/MyVolume -size 8g -layout SPUD -fs HFS+J &amp;amp;&amp;amp; \
hdiutil attach ~/Desktop/MyVolume.dmg -noverify -mountpoint /Volumes/Install\ macOS\ Beta
&lt;/code>&lt;/pre>
&lt;h2 id="在终端中使用-createinstallmedia-命令">在“终端”中使用 “createinstallmedia” 命令&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo /Applications/Install\ macOS\ Beta.app/Contents/Resources/createinstallmedia —volume /Volumes/MyVolume.dmg --nointeraction
&lt;/code>&lt;/pre>
&lt;p>键入命令后：&lt;/p>
&lt;ol>
&lt;li>按下 Return 键以输入这个命令。&lt;/li>
&lt;li>出现提示时，请键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不会显示任何字符。&lt;/li>
&lt;li>出现提示时，请键入 Y 以确认您要抹掉宗卷，然后按下 Return 键。创建可引导安装器过程中，“终端”将显示进度。 &lt;/li>
&lt;li>当“终端”提示操作已完成时，宗卷的名称将与您下载的安装器名称相同，例如“Install macOS Catalina”。您现在可以退出“终端”并弹出宗卷。&lt;/li>
&lt;/ol>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/macos/Big-Sur/macos-big-sur-terminal-create-bootable-installer.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="创建-iso-镜像文件">创建 .iso 镜像文件&lt;/h2>
&lt;ol>
&lt;li>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。&lt;/li>
&lt;li>在“终端”中键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">hdiutil convert ~/Desktop/MyVolume.dmg -format UDTO -o ~/Desktop/MyVolume.cdr
mv ~/Desktop/MyVolume.cdr ~/Desktop/MyVolume.iso
&lt;/code>&lt;/pre>
&lt;h2 id="使用可引导安装镜像">使用可引导安装镜像&lt;/h2>
&lt;p>创建可引导安装镜像后，在支持从磁盘镜像启动的操作系统上，请按照以下步骤进行使用：&lt;/p>
&lt;ol>
&lt;li>将可引导安装器作为硬件系统的虚拟磁盘。&lt;/li>
&lt;li>将系统开机或重新启动后，进入磁盘引导。&lt;/li>
&lt;li>根据提示选取您的语言。&lt;/li>
&lt;li>从“实用工具”窗口中选择“安装 macOS”（或“安装 OS X”），然后点按“继续”，并按照屏幕上的说明进行操作。&lt;/li>
&lt;/ol>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ul>
&lt;li>参考 &lt;a href="https://support.apple.com/zh-cn/HT201372" target="_blank" rel="noopener">如何创建可引导的 macOS 安装器 - Apple 支持&lt;/a> 制作 USB 启动安装器&lt;/li>
&lt;li>参考 &lt;a href="https://support.apple.com/zh-cn/HT201475" target="_blank" rel="noopener">如何升级至 macOS Big Sur - Apple 支持&lt;/a> 获取 Big Sur 安装镜像。&lt;/li>
&lt;/ul></description></item><item><title>HT0025 如何在 macOS 上检视 PCI 设备</title><link>/2018/12/27/ht0025-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%A3%80%E8%A7%86-pci-%E8%AE%BE%E5%A4%87/</link><pubDate>Thu, 27 Dec 2018 10:31:29 +0000</pubDate><guid>/2018/12/27/ht0025-%E5%A6%82%E4%BD%95%E5%9C%A8-macos-%E4%B8%8A%E6%A3%80%E8%A7%86-pci-%E8%AE%BE%E5%A4%87/</guid><description>&lt;p>通过 &lt;a href="mj.ucw.cz/sw/pciutils/">PCI Utilities&lt;/a> 可以获取到 Mac 操作系统下所有 &lt;a href="https://en.wikipedia.org/wiki/Conventional_PCI" target="_blank" rel="noopener">PCI&lt;/a> 设备信息。&lt;/p>
&lt;p>以下高级步骤主要适用于系统管理员以及熟悉命令行的其他人员。&lt;/p>
&lt;h2 id="在终端中使用-lspci-命令">在“终端中”使用 &lt;code>lspci&lt;/code> 命令&lt;/h2>
&lt;p>&lt;code>lspci&lt;/code> 需要用到 &lt;code>AppleACPIPlatformExpert&lt;/code>，需要在内核调试模式下才可运行&lt;/p>
&lt;ol>
&lt;li>安装 &lt;a href="https://github.com/pciutils/pciutils" target="_blank" rel="noopener">PCI Utilities&lt;/a>。&lt;/li>
&lt;li>进入 macOS 恢复模式，进入“实用工具”菜单中的“终端”。如果当前 macOS 开启了 &lt;a href="https://en.wikipedia.org/wiki/System_Integrity_Protection" target="_blank" rel="noopener">SIP&lt;/a> (e.g. El Capitan, Sierra)，请在终端中键入或粘贴以下命令以关闭 SIP。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">csrutil disable
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>在“终端“键入或粘贴以下命令。通过 nvram 命令以 Verbose Mode 启动操作系统，同时打开内核调试特性。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">nvram boot-args=&amp;quot;-v debug=0x144”
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>完成后，请退出“终端”，并重启系统。&lt;/li>
&lt;li>重启完进入系统后，此时 &lt;code>lspci&lt;/code> 即可使用。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-lspci-获取-pci-设备信息">使用 &lt;code>lspci&lt;/code> 获取 PCI 设备信息&lt;/h2>
&lt;ol>
&lt;li>在“终端”键入或粘贴以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo /usr/local/sbin/lspci -tv
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>根据提示键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不显示任何字符。&lt;/li>
&lt;li>以 &lt;a href="https://support.apple.com/en-us/HT201300" target="_blank" rel="noopener">MacBookPro12,1&lt;/a> 为例，可以看到所有 PCI 设备列表。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">-[0000:00]-+-00.0 Intel Corporation Broadwell-U Host Bridge -OPI
+-02.0 Intel Corporation Iris Graphics 6100
+-03.0 Intel Corporation Broadwell-U Audio Controller
+-14.0 Intel Corporation Wildcat Point-LP USB xHCI Controller
+-15.0 Intel Corporation Wildcat Point-LP Serial IO DMA Controller
+-15.4 Intel Corporation Wildcat Point-LP Serial IO GSPI Controller #1
+-16.0 Intel Corporation Wildcat Point-LP MEI Controller #1
+-1b.0 Intel Corporation Wildcat Point-LP High Definition Audio Controller
+-1c.0-[01]--
+-1c.1-[02]--
+-1c.2-[03]----00.0 Broadcom Limited BCM43602 802.11ac Wireless LAN SoC
+-1c.4-[05-ff]--
+-1c.5-[04]----00.0 Samsung Electronics Co Ltd Device a801
+-1f.0 Intel Corporation Wildcat Point-LP LPC Controller
+-1f.3 Intel Corporation Wildcat Point-LP SMBus Controller
\-1f.6 Intel Corporation Wildcat Point-LP Thermal Management Controller
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>在“终端”键入或粘贴以下命令，可以获取到网卡信息。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo /usr/local/sbin/lspci | grep Network
03:00.0 Network controller: Broadcom Limited BCM43602 802.11ac Wireless LAN SoC (rev 01)
&lt;/code>&lt;/pre>
&lt;ol start="5">
&lt;li>对于关闭了 SIP 的情况下，出于安全考虑，有必要在完成以上必要步骤后再次开启 SIP，进入恢复模式，在“终端”键入以下命令。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">csrutil enable
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;p>要进一步了解 &lt;code>lspci&lt;/code> 命令，在终端中输入 &lt;code>sudo /usr/local/sbin/lspci -h&lt;/code> 或者查阅 PCI Utilities &lt;a href="mj.ucw.cz/sw/pciutils/">项目主页&lt;/a>。&lt;/p></description></item><item><title>HT0026 未越狱如何降级 iOS 应用版本</title><link>/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/</link><pubDate>Thu, 14 Jun 2018 15:44:16 +0000</pubDate><guid>/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/</guid><description>&lt;h2 id="如何获取-ipa">如何获取 ipa&lt;/h2>
&lt;p>要获取应用下载链接，在未越狱的情况下，由于每一个 &lt;code>ipa&lt;/code> 都和 Apple ID 绑定，并且有 Apple 的签名，所以必须要通过官方途径配合 Apple 账号下载。在 Windows 上可以直接通过 iTunes 方式获取 &lt;code>ipa&lt;/code>，而在 macOS 上目前有两种获取 &lt;code>ipa&lt;/code> 方式：&lt;/p>
&lt;ol>
&lt;li>iTunes&lt;/li>
&lt;li>Apple Configurator&lt;/li>
&lt;/ol>
&lt;h3 id="ipa-的下载流程">ipa 的下载流程&lt;/h3>
&lt;h4 id="itunes-的-ipa-下载流程">iTunes 的 ipa 下载流程&lt;/h4>
&lt;p>在 iTunes 下，一次购买下载 &lt;code>ipa&lt;/code> 的流程由一个发往服务器为 &lt;code>buy.itunes.apple.com&lt;/code>、Path 为 &lt;code>WebObjects/MZBuy.woa/wa/buyProduct&lt;/code> 的请求作为开始。构造请求时会向 &lt;code>appExtVrsId&lt;/code> 字段注入 Build 号，来指定获取具体某个版本的 &lt;code>ipa&lt;/code>（默认为最新上架的一个 Build Number），再利用 &lt;code>GUID&lt;/code> 和 &lt;code>DSID&lt;/code> 生成 &lt;code>kbsync&lt;/code> 请求鉴权信息，完成 Request 构造。收到 Response 之后，分析 Response Body 中的 &lt;code>XML&lt;/code> 文件，可以找到包含签名后的下载链接，iTunes 利用这个链接完成 &lt;code>ipa&lt;/code> 的下载，链接的形式如下所示。&lt;/p>
&lt;pre>&lt;code class="language-shell">https://iosapps.itunes.apple.com/itunes-assets/Purple114/v4/bf/36/04/bf360426-5231-2db4-ff0b-430c788ec5c6/pre-thinned13659119744838198600.lc.7948000812590706.EOTME2CVXCUZU.signed.dpkg.ipa?accessKey=${accessKey}
&lt;/code>&lt;/pre>
&lt;p>可以看到请求的 &lt;code>ipa&lt;/code> 为 &lt;code>pre-thinned13......ipa&lt;/code>；Path 为 &lt;code>itunes-assets/Purple114/v4/bf/36/04/bf360426-5231-2db4-ff0b-430c788ec5c6&lt;/code>，由于同一个应用，不同设备的 &lt;code>ipa&lt;/code> 包都是不同的，所以文件服务器上必然有大量包含了 &lt;code>pre-thinned&lt;/code> 的 ipa，所以 &lt;code>hash&lt;/code> 过的 Path 可用于文件索引加速，但会使得反向推算特定版本特定设备的 &lt;code>ipa&lt;/code> 变得几乎不可能；&lt;code>accessKey&lt;/code> 为 public key 且具有时效性，用于文件访问鉴权。&lt;/p>
&lt;p>综上可以得知 &lt;code>ipa&lt;/code> 文件路径难以推测，并且请求具有实效性，因此在 Response 处没有太多的可挖掘的点。而将 &lt;code>appExtVrsId&lt;/code> 这个字段作为切入点是比较合理的。&lt;/p>
&lt;h4 id="apple-configurator-的-ipa-下载流程">Apple Configurator 的 ipa 下载流程&lt;/h4>
&lt;p>在 Apple Configurator 2 中，苹果针对请求做了修改 Path 变为 &lt;code>WebObjects/MZFinance.woa/wa/volumeStoreDownloadProduct&lt;/code>，请求的 Plist 如下所示。&lt;/p>
&lt;pre>&lt;code>&amp;lt;key&amp;gt;guid&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;${guid}&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;kbsync&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;${kbsync}&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;salableAdamId&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;414478124&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;serialNumber&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;${serialNumber}&amp;lt;/string&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>可以发现并没有字段可以来指定版本信息，一筹莫展。&lt;/p>
&lt;h3 id="通过-itunes-获取-ipa">通过 iTunes 获取 ipa&lt;/h3>
&lt;div class="alert alert-note">
&lt;div>
2020 年 03 月 18 日 后，从 iTunes 12.6.5 的 App Store 下载应用会直接 SSL 握手失败，iTunes 的方式失效。
&lt;/div>
&lt;/div>
&lt;p>自 macOS Mojave 之后，iTunes 的 App Store 的功能就逐渐淡出舞台了，&lt;a href="https://secure-appldnld.apple.com/itunes12/091-87821-20180912-69177170-B085-11E8-B6AB-C1D03409AD2A/iTunes12.6.5.dmg" target="_blank" rel="noopener">iTunes 12.6.5.3&lt;/a> 是最后一个可以浏览 App Store 的 iTunes 版本。&lt;/p>
&lt;h4 id="安装-itunes-12653">安装 iTunes 12.6.5.3&lt;/h4>
&lt;p>在 Mojave 之后安装 iTunes 会受到限制，需要绕过校验系统版本的 iTunes Installer，直接提取安装包内部的 iTunes.app 移至 /Applications 使用。在 macOS Mojave 10.14.4 之后，苹果直接对 iTunes 版本做了限制，打开 iTunes 会提示你当前系统不支持 12.6.5，这时候需要提高 info.plist 里的版本号绕过 macOS 的校验，可以使用 Apple Script 来完成上述步骤。&lt;/p>
&lt;script type="application/javascript" src="https://gist.github.com/0xxd0/c5e410690e501de1786e72499b03eff4.js">&lt;/script>
&lt;p>针对历史版本的 iTunes，以及其残留物无法删除干净的情况下，可以使用如下 &lt;code>shell&lt;/code> 脚本。&lt;/p>
&lt;script type="application/javascript" src="https://gist.github.com/0xxd0/f4ad266c6df5b9b62433f86a0881b9b6.js">&lt;/script>
&lt;p>完成安装后，如果启动 iTunes 时提示 &amp;ldquo;iTunes Library.itl&amp;rdquo; 错误，则需要移除 Music 目录下 iTunes 文件夹内 iTunes Library.itl 文件。此外也可以通过 &lt;a href="https://github.com/cormiertyshawn895/Retroactive" target="_blank" rel="noopener">Retroactive&lt;/a> 安装 iTunes，同样也包括其他被苹果删除的内建应用。&lt;/p>
&lt;h4 id="从-itunes-抓取下载数据">从 iTunes 抓取下载数据&lt;/h4>
&lt;p>以 Charles 为例，按照以下步骤进行下载地址抓取&lt;/p>
&lt;ol>
&lt;li>打开 Charles，配置证书打开，SSL Proxying 加入 &lt;code>*.apple.com&lt;/code>。&lt;/li>
&lt;li>开 iTunes，选择一个应用下载，以 WeChat 为例。&lt;/li>
&lt;li>在 Charles 中过滤 path 为 &lt;code>WebObjects/MZBuy.woa/wa/buyProduct&lt;/code> 的请求，添加 &lt;code>breakpoints&lt;/code>。&lt;/li>
&lt;li>查看 Response Body 中 &lt;code>XML&lt;/code> 字段 &lt;code>softwareVersionExternalIdentifiers&lt;/code>，该数组包含了所有可下载的 Build 号。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-xml">&amp;lt;key&amp;gt;softwareVersionExternalIdentifiers&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
...
&amp;lt;integer&amp;gt;717062721&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;719842773&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;726302660&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;746082682&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;811222902&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;811530944&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;811669817&amp;lt;/integer&amp;gt;
&amp;lt;integer&amp;gt;811953630&amp;lt;/integer&amp;gt;
...
&amp;lt;/array&amp;gt;
&lt;/code>&lt;/pre>
&lt;ol start="5">
&lt;li>根据 &lt;a href="https://mixrank.com/appstore/apps/414478124/versions" target="_blank" rel="noopener">MIXRANK&lt;/a> 查询版本对应的 Build 号。&lt;/li>
&lt;/ol>
&lt;figure id="figure-build-number">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Build Number" srcset="
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/build-version-map_hu7721f23abd3aabca125ada159a160f16_195919_a68d9f8a3109a2303308b3144f941c93.png 400w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/build-version-map_hu7721f23abd3aabca125ada159a160f16_195919_d486c938359d9c29c4f1a7acb62a54a8.png 760w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/build-version-map_hu7721f23abd3aabca125ada159a160f16_195919_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/build-version-map_hu7721f23abd3aabca125ada159a160f16_195919_a68d9f8a3109a2303308b3144f941c93.png"
width="760"
height="557"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Build Number
&lt;/figcaption>&lt;/figure>
&lt;ol start="6">
&lt;li>取消之前的下载，并再次下载触发断点，编辑 Request，将请求的 &lt;code>appExtVrsId&lt;/code> 字段的值替换成对应的版本号，并 Excute。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-xml">&amp;lt;key&amp;gt;appExtVrsId&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;830005675&amp;lt;/string&amp;gt;
&lt;/code>&lt;/pre>
&lt;ol start="7">
&lt;li>完成下载之后可得到指定版本的 ipa。&lt;/li>
&lt;/ol>
&lt;h3 id="使用-apple-configurator">使用 Apple Configurator&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
暂时还未找到通过 Apple Configurator 2 降级的方法
&lt;/div>
&lt;/div>
&lt;h4 id="安装-apple-configurator-2">安装 Apple Configurator 2&lt;/h4>
&lt;p>&lt;a href="https://apps.apple.com/cn/app/apple-configurator-2/id1037126344" target="_blank" rel="noopener">点击链接&lt;/a> 从 Mac App Store 直接安装 Apple Configurator 2&lt;/p>
&lt;h4 id="如何从-apple-configurator-2-抓取下载数据">如何从 Apple Configurator 2 抓取下载数据&lt;/h4>
&lt;p>首先从 Apple Configurator 2 发起下载请求，以 WeChat 为例，选择 WeChat 点击 Add。&lt;/p>
&lt;figure id="figure-wechat">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="WeChat" srcset="
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-wechat_hu409c0142164a426ac1eab9af4e5507e1_490825_8ae8f77353d25851add9e69a7ab97c46.png 400w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-wechat_hu409c0142164a426ac1eab9af4e5507e1_490825_f526c1bf2d21b88dde2c195036a5cdec.png 760w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-wechat_hu409c0142164a426ac1eab9af4e5507e1_490825_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-wechat_hu409c0142164a426ac1eab9af4e5507e1_490825_8ae8f77353d25851add9e69a7ab97c46.png"
width="760"
height="507"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
WeChat
&lt;/figcaption>&lt;/figure>
&lt;p>从 Apple Configurator 2 抓取下载数和 iTunes 的唯一区别点在于断点的位置，如下图所示。&lt;/p>
&lt;figure id="figure-break-point">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Break Point" srcset="
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/buyitunes-breakpoint_huf641f3175853c64aed3b6229b150b204_94151_c5821320c8699a94522f86b62f74760c.png 400w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/buyitunes-breakpoint_huf641f3175853c64aed3b6229b150b204_94151_574de24b7c3e5c75268b0f0fe62a3be4.png 760w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/buyitunes-breakpoint_huf641f3175853c64aed3b6229b150b204_94151_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/buyitunes-breakpoint_huf641f3175853c64aed3b6229b150b204_94151_c5821320c8699a94522f86b62f74760c.png"
width="760"
height="153"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Break Point
&lt;/figcaption>&lt;/figure>
&lt;p>其余流程在理论上没有任何区别，但如&lt;a href="#Apple-Configurator-%e7%9a%84-ipa-%e4%b8%8b%e8%bd%bd%e6%b5%81%e7%a8%8b">“Apple Configurator 的 ipa 下载流程”&lt;/a>中所述，核心在于如何修改版本，暂时还没找到方法，目前苹果应该是把 Build Number 查询与修改这一步放到了服务端。&lt;/p>
&lt;h2 id="安装-ipa">安装 ipa&lt;/h2>
&lt;p>使用 Apple Configurator 2，添加一个 App，点击 Choose from my Mac 选择上一步骤中抓取到的 ipa。&lt;/p>
&lt;figure id="figure-install-ipa">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Install IPA" srcset="
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-install-ipa_hu98537246a3a2a82ed81ec0a73f2cf4e6_751964_94209d88307529f92adea8d6df8b9fb6.png 400w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-install-ipa_hu98537246a3a2a82ed81ec0a73f2cf4e6_751964_afee8a21139800545e80ebdbe4e0c28a.png 760w,
/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-install-ipa_hu98537246a3a2a82ed81ec0a73f2cf4e6_751964_1200x1200_fit_lanczos_2.png 1200w"
src="/2018/06/14/ht0026-%E6%9C%AA%E8%B6%8A%E7%8B%B1%E5%A6%82%E4%BD%95%E9%99%8D%E7%BA%A7-ios-%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC/apple-configurator-2-install-ipa_hu98537246a3a2a82ed81ec0a73f2cf4e6_751964_94209d88307529f92adea8d6df8b9fb6.png"
width="760"
height="469"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Install IPA
&lt;/figcaption>&lt;/figure>
&lt;p>按步骤安装完成 ipa 的部署即可。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://forums.macrumors.com/threads/itunes-12-6-5-3-on-macos-catalina-10-15.2184518/" target="_blank" rel="noopener">iTunes 12.6.5.3 on MacOS Catalina 10.15&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.theiphonewiki.com/wiki/DSID" target="_blank" rel="noopener">DSID&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://support.apple.com/zh-cn/HT208079" target="_blank" rel="noopener">使用 iTunes 在业务环境中部署应用&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/251200031?page=2" target="_blank" rel="noopener">Updating apps using iTunes 12.6.5.3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discussions.apple.com/thread/251211447" target="_blank" rel="noopener">iTunes 12.6.5 Apps don’t download since 18/03/2020&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">Public-key cryptography&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>生物及生物医学科学</title><link>/cipcode/26/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/26/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="2601-生物学-常规httpsncesedgovipedscipcodecipdetailaspxy56cipid90677">26.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90677" target="_blank" rel="noopener">生物学, 常规.&lt;/a>&lt;/h3>
&lt;h3 id="2605-微生物学和免疫学httpsncesedgovipedscipcodecipdetailaspxy55cip2605">26.05) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=55&amp;amp;cip=26.05" target="_blank" rel="noopener">微生物学和免疫学.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-260503-医学微生物学和细菌学httpsncesedgovipedscipcodecipdetailaspxy55cip260503">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 26.0503) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=55&amp;amp;cip=26.0503" target="_blank" rel="noopener">医学微生物学和细菌学.&lt;/a>&lt;/h4>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=26" target="_blank" rel="noopener">Detail for CIP Code 26&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://medicine.yale.edu/bbs/" target="_blank" rel="noopener">Yale University / Yale Combined Program in the Biological and Biomedical Sciences (BBS)&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>数学和统计学</title><link>/cipcode/27/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/27/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=27" target="_blank" rel="noopener">Detail for CIP Code 27&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>Bilibili</title><link>/2019/12/12/bilibili/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/bilibili/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2></description></item><item><title>HT0030 如何在 iCloud 中屏蔽不需要同步的文件</title><link>/2017/01/11/ht0030-%E5%A6%82%E4%BD%95%E5%9C%A8-icloud-%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate><guid>/2017/01/11/ht0030-%E5%A6%82%E4%BD%95%E5%9C%A8-icloud-%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>&lt;h5 id="文件名">文件名&lt;/h5>
&lt;ul>
&lt;li>是 .DS_Store&lt;/li>
&lt;li>以 (A Document Being Saved 开头&lt;/li>
&lt;li>包含 .nosync（大小写不敏感）&lt;/li>
&lt;li>是 .ubd&lt;/li>
&lt;li>包含 .weakpkg&lt;/li>
&lt;li>是 tmp（大小写不敏感）&lt;/li>
&lt;li>是 .tmp（大小写不敏感）&lt;/li>
&lt;li>是 desktop.ini（大小写不敏感）&lt;/li>
&lt;li>以 ~$ 开头&lt;/li>
&lt;li>是 Microsoft User Data（大小写不敏感）&lt;/li>
&lt;li>是 $RECYCLE.BIN（大小写不敏感）&lt;/li>
&lt;li>是 iPhoto Library（大小写不敏感）&lt;/li>
&lt;li>是 Dropbox（大小写不敏感）&lt;/li>
&lt;li>是 OneDrive（大小写不敏感）&lt;/li>
&lt;li>是 IDrive-Sync（大小写不敏感）&lt;/li>
&lt;li>是 .dropbox（大小写不敏感）&lt;/li>
&lt;li>是 .dropbox.attr（大小写不敏感）&lt;/li>
&lt;/ul>
&lt;h5 id="文件的扩展名">文件的扩展名&lt;/h5>
&lt;ul>
&lt;li>是 .tmp&lt;/li>
&lt;li>是 .photoslibrary&lt;/li>
&lt;li>是 .photolibrary&lt;/li>
&lt;li>是 .aplibrary&lt;/li>
&lt;li>是 .migratedaplibrary&lt;/li>
&lt;li>是 .migratedphotolibrary&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://apple.stackexchange.com/questions/254313/how-to-exclude-a-sub-folder-from-icloud-drive-in-macos-sierra" target="_blank" rel="noopener">How to exclude a sub folder from iCloud drive in macOS Sierra?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>公园, 娱乐, 休闲, 健身和人体运动学</title><link>/cipcode/31/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/31/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="3199-公园-娱乐-休闲-健身和人体运动学-其他httpsncesedgovipedscipcodecipdetailaspxy56cipid90741">31.99) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90741" target="_blank" rel="noopener">公园, 娱乐, 休闲, 健身和人体运动学, 其他.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-319999-公园-娱乐-休闲-健身和人体运动学-其他httpsncesedgovipedscipcodecipdetailaspxy56cipid90742">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 31.9999) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90742" target="_blank" rel="noopener">公园, 娱乐, 休闲, 健身和人体运动学, 其他.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>
&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=31" target="_blank" rel="noopener">Detail for CIP Code 31&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>休闲以及娱乐活动 LEISURE AND RECREATIONAL ACTIVITIES</title><link>/cipcode/36/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/36/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="3601-休闲以及娱乐活动-leisure-and-recreational-activitieshttpsncesedgovipedscipcodecipdetailaspxy56cip3601">36.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=36.01" target="_blank" rel="noopener">休闲以及娱乐活动 Leisure and Recreational Activities.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-360102-手工艺品与模型制作-handicrafts-and-model-makinghttpsncesedgovipedscipcodecipdetailaspxy56cip360102">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 36.0102) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=36.0102" target="_blank" rel="noopener">手工艺品与模型制作 Handicrafts and Model-Making.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>BANDAI®&lt;/p>
&lt;ul>
&lt;li>GUNPLA®&lt;/li>
&lt;li>GUNDAM BASE&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>AUTOART®&lt;/p>
&lt;ul>
&lt;li>MC12 FIA GT1 2010&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TAMIYA®&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cn.mclaren.com/racing/heritage/cars/1988-formula-1-mclaren-mp4-4/" target="_blank" rel="noopener">MP4/4&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Porsche®&lt;/p>
&lt;ul>
&lt;li>保时捷 911 水平 6 缸对置发动机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>LEGO®&lt;/p>
&lt;ul>
&lt;li>LEGO® Super Mario™&lt;/li>
&lt;li>71360 Adventures with Mario Starter Course 
&lt;ul>
&lt;li>Coming Soon on August 1, 2020&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>71360 Adventures with Mario Starter Course&lt;/li>
&lt;li>&lt;a href="https://www.lego.com/en-us/product/adventures-with-mario-starter-course-71360" target="_blank" rel="noopener">Adventures with Mario Starter Course 71360 | LEGO® Super Mario™ | Buy online at the Official LEGO® Shop US&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.lego.com/en-us/product/harley-davidson-fat-boy-10269" target="_blank" rel="noopener">Harley-Davidson® Fat Boy® 10269 | Creator Expert | Buy online at the Official LEGO® Shop US&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.amazon.com/LEGO-Technic-Mobile-Discontinued-manufacturer/dp/B00E3OPSJM" target="_blank" rel="noopener">LEGO Technic 42009 Mobile Crane MK II(Discontinued by manufacturer)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.lego.com/en-us/product/rough-terrain-crane-42082" target="_blank" rel="noopener">Rough Terrain Crane 42082 | Technic™ | Buy online at the Official LEGO® Shop US&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="hahahugoshortcode-s1-hbhb-360109-旅行和探索-travel-and-explorationhttpsncesedgovipedscipcodecipdetailaspxy56cip360109">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 36.0109) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=36.0109" target="_blank" rel="noopener">旅行和探索 Travel and Exploration.&lt;/a>&lt;/h4>
&lt;figure id="figure-visual-travels-airpanohttpwwwairpanocom---lake-hibara">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://www.airpano.com/photogallery/images_1550/325_785070.jpg" alt="[Visual Travels AirPano](http://www.airpano.com/) - Lake Hibara" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
&lt;a href="http://www.airpano.com/">Visual Travels AirPano&lt;/a> - Lake Hibara
&lt;/figcaption>&lt;/figure>
&lt;h4 id="hahahugoshortcode-s3-hbhb-360115-音乐-musichttpsncesedgovipedscipcodecipdetailaspxy56cip360115">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 36.0115) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=36.0115" target="_blank" rel="noopener">音乐 Music.&lt;/a>&lt;/h4>
&lt;p>Apple Music - &lt;a href="https://github.com/Musish/Musish" target="_blank" rel="noopener">Musish: Apple Music&amp;hellip;ish&lt;/a>&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=36" target="_blank" rel="noopener">Detail for CIP Code 36&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>Lukkin Coffee</title><link>/2019/12/12/lukkin-coffee/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>/2019/12/12/lukkin-coffee/</guid><description/></item><item><title>社会科学 SOCIAL SCIENCES</title><link>/cipcode/45/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/45/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="4501-社会科学-常规-social-sciences-generalhttpsncesedgovipedscipcodecipdetailaspxy56cip4501">45.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=45.01" target="_blank" rel="noopener">社会科学, 常规 Social Sciences, General.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-450101-社会科学-常规-social-sciences-generalhttpsncesedgovipedscipcodecipdetailaspxy56cip450101">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0101) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=45.0101" target="_blank" rel="noopener">社会科学, 常规 Social Sciences, General.&lt;/a>&lt;/h4>
&lt;p>Social sciences Specializations and courses explore how populations form laws, make decisions, behave in groups, and structure their communities. From education to economics to law, courses in the social sciences will improve your understanding of the dynamics between individuals and groups, and your ability to analyze behaviors and trends.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.coursera.org/browse/social-sciences" target="_blank" rel="noopener">Social Sciences Online Courses | Coursera&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.trustedsec.com/tools/the-social-engineer-toolkit-set/" target="_blank" rel="noopener">THE SOCIAL-ENGINEER TOOLKIT (SET)&lt;/a>&lt;/p>
&lt;h3 id="4506-经济学httpsncesedgovipedscipcodecipdetailaspxy56cipid90861">45.06) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90861" target="_blank" rel="noopener">经济学.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s1-hbhb-450601-经济学-常规httpsncesedgovipedscipcodecipdetailaspxy56cipid90862">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0601) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90862" target="_blank" rel="noopener">经济学, 常规.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s2-hbhb-450602-应用经济学httpsncesedgovipedscipcodecipdetailaspxy56cipid90863">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0602) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90863" target="_blank" rel="noopener">应用经济学.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s3-hbhb-450603-计量经济学和定量经济学httpsncesedgovipedscipcodecipdetailaspxy56cipid90864">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0603) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90864" target="_blank" rel="noopener">计量经济学和定量经济学.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s4-hbhb-450604-发展经济学和国际发展httpsncesedgovipedscipcodecipdetailaspxy56cipid90865">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0604) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90865" target="_blank" rel="noopener">发展经济学和国际发展.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s5-hbhb-450605-国际经济学httpsncesedgovipedscipcodecipdetailaspxy56cipid90866">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0605) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90866" target="_blank" rel="noopener">国际经济学.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s6-hbhb-450699-经济学-其他httpsncesedgovipedscipcodecipdetailaspxy56cipid90867">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 45.0699) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cipid=90867" target="_blank" rel="noopener">经济学, 其他.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%e7%ba%b3%e4%bb%80%e5%9d%87%e8%a1%a1" target="_blank" rel="noopener">Nash Equilibrium&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/1998-99/game-theory/nonzero.html" target="_blank" rel="noopener">Non-Zero-Sum Games&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%e5%b8%95%e7%b4%af%e6%89%98%e6%9c%80%e4%bc%98" target="_blank" rel="noopener">Pareto Optimality&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=45" target="_blank" rel="noopener">Detail for CIP Code 45&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>视觉和表演艺术 VISUAL AND PERFORMING ARTS</title><link>/cipcode/50/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/50/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="5004-设计和应用艺术-design-and-applied-artshttpsncesedgovipedscipcodecipdetailaspxy56cip5004">50.04) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.04" target="_blank" rel="noopener">设计和应用艺术 Design and Applied Arts.&lt;/a>&lt;/h3>
&lt;p>&lt;strong>Arts and Humanities&lt;/strong>&lt;/p>
&lt;p>Specializations and courses in the arts and humanities (including fine arts, history, and philosophy) explore the historical context of creative works and teach you to review source material critically, draw connections between diverse ideas, and evaluate evidence and arguments. Coursework in this field will help you become a better reader, thinker, artist, and writer.&lt;/p>
&lt;p>&lt;strong>University&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.harvard.edu/on-campus/arts-and-humanities" target="_blank" rel="noopener">Arts and Humanities | Harvard University&lt;/a>&lt;/p>
&lt;p>&lt;strong>Courses&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.coursera.org/browse/arts-and-humanities" target="_blank" rel="noopener">Arts and Humanities Online Courses | Coursera&lt;/a>&lt;/p>
&lt;h4 id="hahahugoshortcode-s0-hbhb-500404-工业与产品设计-industrial-and-product-designhttpsncesedgovipedscipcodecipdetailaspxy56cip500404">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 50.0404) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0404" target="_blank" rel="noopener">工业与产品设计 Industrial and Product Design.&lt;/a>&lt;/h4>
&lt;p>&lt;strong>UI and UX Design&lt;/strong>&lt;/p>
&lt;p>UI / UX Design Specialization&lt;/p>
&lt;p>&lt;strong>Courses&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.coursera.org/specializations/ui-ux-design" target="_blank" rel="noopener">UI / UX Design | Coursera&lt;/a>&lt;/p>
&lt;p>&lt;strong>Design Material&lt;/strong>&lt;/p>
&lt;p>Adobe - &lt;a href="https://helpx.adobe.com/download-install/kb/creative-cloud-apps-download.html" target="_blank" rel="noopener">Download Creative Cloud apps&lt;/a>&lt;/p>
&lt;p>&lt;strong>Website&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://lea.verou.me/projects/" target="_blank" rel="noopener">Projects | Lea Verou&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.behance.net/" target="_blank" rel="noopener">Bēhance&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="hahahugoshortcode-s1-hbhb-500410-插画-illustrationhttpsncesedgovipedscipcodecipdetailaspxy56cip500410">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 50.0410) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0410" target="_blank" rel="noopener">插画 Illustration.&lt;/a>&lt;/h4>
&lt;p>&lt;a href="http://www.jamesrichardssketchbook.com/" target="_blank" rel="noopener">James Richards Sketchbook&lt;/a>&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://3.bp.blogspot.com/-HaBbAcpH3Is/W2ePSIM8X-I/AAAAAAAAB2A/6ZnmgPfIzhoJzh1ZoclNaHGNdRh5Dg9bgCLcBGAs/s1600/Picadilly%2BCircus607.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h4 id="hahahugoshortcode-s3-hbhb-500411-游戏与互动媒体设计-game-and-interactive-media-designhttpsncesedgovipedscipcodecipdetailaspxy56cip500411">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 50.0411) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0411" target="_blank" rel="noopener">游戏与互动媒体设计 Game and Interactive Media Design.&lt;/a>&lt;/h4>
&lt;p>Music&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://Vizzed.com" target="_blank" rel="noopener">Vizzed.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Shining Soul&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.vizzed.com/videogames/music.php?game=10836#/player1?catid=0&amp;amp;trackid=20" target="_blank" rel="noopener">Shining Soul II OST Soundtrack - Shining Soul II OST Soundtrack&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="5006-电影-录像和摄影艺术-film-video-and-photographic-artshttpsncesedgovipedscipcodecipdetailaspxy56cip5006">50.06) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.06" target="_blank" rel="noopener">电影, 录像和摄影艺术 Film, Video and Photographic Arts.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s4-hbhb-500601-filmcinemavideo-studieshttpsncesedgovipedscipcodecipdetailaspxy56cip500601">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 50.0601) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0601" target="_blank" rel="noopener">Film/Cinema/Video Studies.&lt;/a>&lt;/h4>
&lt;p>&lt;a href="https://film-grab.com" target="_blank" rel="noopener">[FILMGRAB]&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;h4 id="500605-photographer-摄影httpsncesedgovipedscipcodecipdetailaspxy56cip500605">50.0605) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0605" target="_blank" rel="noopener">Photographer 摄影.&lt;/a>&lt;/h4>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://takashiyasui.com" target="_blank" rel="noopener">Takashi Yasui&lt;/a>&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://64.media.tumblr.com/27d29f86eae4e1f6a690c7b11e627d6d/2c3cf23d2c93b5fb-9c/s1280x1920/23b7654af6692c6d31ca54bdc308d25e760394da.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h3 id="5009-音乐-musichttpsncesedgovipedscipcodecipdetailaspxy56cip5009">50.09) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.09" target="_blank" rel="noopener">音乐 Music.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s6-hbhb-500999-音乐-其他-music-otherhttpsncesedgovipedscipcodecipdetailaspxy56cip500999">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 50.0999) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50.0999" target="_blank" rel="noopener">音乐, 其他 Music, Other.&lt;/a>&lt;/h4>
&lt;p>AIDN&lt;/p>
&lt;p>&lt;a href="https://aidn.jp/about/" target="_blank" rel="noopener">daniwell&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mikutap.dcc.cat/" target="_blank" rel="noopener">mikutap&lt;/a>&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=50" target="_blank" rel="noopener">Detail for CIP Code 50&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>健康专业和相关项目</title><link>/cipcode/51/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/51/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="5112-医学httpsncesedgovipedscipcodecipdetailaspxy56cip5112">51.12) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=51.12" target="_blank" rel="noopener">医学.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-511201-医学httpsncesedgovipedscipcodecipdetailaspxy56cip511201">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 51.1201) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=51.1201" target="_blank" rel="noopener">医学.&lt;/a>&lt;/h4>
&lt;h4 id="hahahugoshortcode-s1-hbhb-511299-医学-其他httpsncesedgovipedscipcodecipdetailaspxy56cip511299">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 51.1299) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=51.1299" target="_blank" rel="noopener">医学, 其他.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2019).
&lt;a href="/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/">鼻炎与鼻窦炎全解析&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=51" target="_blank" rel="noopener">Detail for CIP Code 51&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>商业, 管理, 营销和其他相关支持服务</title><link>/cipcode/52/</link><pubDate>Wed, 01 Jul 2015 10:31:29 +0000</pubDate><guid>/cipcode/52/</guid><description>&lt;h2 id="4-位数-cip-代码">4 位数 CIP 代码&lt;/h2>
&lt;h3 id="5201-商业贸易-常规httpsncesedgovipedscipcodecipdetailaspxy56cip5201">52.01) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.01" target="_blank" rel="noopener">商业/贸易, 常规.&lt;/a>&lt;/h3>
&lt;h3 id="5203-会计和相关服务httpsncesedgovipedscipcodecipdetailaspxy56cip5203">52.03) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.03" target="_blank" rel="noopener">会计和相关服务.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s0-hbhb-520301-会计httpsncesedgovipedscipcodecipdetailaspxy56cip520301">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 52.0301) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.0301" target="_blank" rel="noopener">会计.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>CPA® Certified Public Accountants&lt;/li>
&lt;li>CAS&lt;/li>
&lt;li>GAAP&lt;/li>
&lt;li>HKFRS&lt;/li>
&lt;li>IFRS&lt;/li>
&lt;/ul>
&lt;h4 id="hahahugoshortcode-s1-hbhb-520303-审计httpsncesedgovipedscipcodecipdetailaspxy56cip520303">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 52.0303) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.0303" target="_blank" rel="noopener">审计.&lt;/a>&lt;/h4>
&lt;h3 id="5208-财务和财务管理服务httpsncesedgovipedscipcodecipdetailaspxy56cip5208">52.08) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.08" target="_blank" rel="noopener">财务和财务管理服务.&lt;/a>&lt;/h3>
&lt;h4 id="hahahugoshortcode-s2-hbhb-520801-财务-常规httpsncesedgovipedscipcodecipdetailaspxy56cip520801">
&lt;i class="far fa-hashtag pr-1 fa-fw">&lt;/i> 52.0801) &lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52.0801" target="_blank" rel="noopener">财务, 常规.&lt;/a>&lt;/h4>
&lt;ul>
&lt;li>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2015).
&lt;a href="/post/investor/investor-relations/">投资者关系 Investor Relations&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://nces.ed.gov/ipeds/cipcode/cipdetail.aspx?y=56&amp;amp;cip=52" target="_blank" rel="noopener">Detail for CIP Code 52&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>操作系统 2021 春</title><link>/2021/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2021-%E6%98%A5/</link><pubDate>Mon, 22 Feb 2021 10:31:29 +0000</pubDate><guid>/2021/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2021-%E6%98%A5/</guid><description>&lt;h2 id="关于">关于&lt;/h2></description></item><item><title>滑板选配 101</title><link>/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>新的滑板到了&lt;/p>
&lt;h2 id="从零开始了解滑板">从零开始了解滑板&lt;/h2>
&lt;p>滑板大概分为双翘板、小鱼板、大鱼板、长板和柯南板。
&lt;strong>双翘板&lt;/strong>是主流的动作板子，可以带板跳起来做动作。
&lt;strong>鱼板&lt;/strong>方便携带，主要用来代步另外，大鱼和小鱼在板型上没区别，成年人用小鱼板比较难站稳，相对来说更危险，建议成年人用大鱼板，小学生用小鱼板。
&lt;strong>长板&lt;/strong>有舞板和速降板，很重不建议用来代步，虽然很稳。
&lt;strong>柯南板&lt;/strong>是未来科技。&lt;/p>
&lt;p>不同类型的板适用不同的场景，按个人喜好进行选择，刚开始联系时带好护具注意安全即可，如果有毅力坚持练下去的建议亲自配一块专业板一步到位，反之可以考虑组装板。特别不建议购买玩具板，玩具板通常有很多缺点，板面没弹性、轮子大回弹差、桥很脆弱、轴承不顺滑，几个大幅度的动作板可能就断了，其唯一的好处可能就是便宜了。下文主要围绕双翘板展开讨论配件的选择。&lt;/p>
&lt;h3 id="trucks">Trucks&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_db6ad4bfced4c87e5848cb795af4e1d0.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_79599387eb3c99be963f9884ee5ea445.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/truck_hu7cc135965814268cce9338f64a00165b_55227_db6ad4bfced4c87e5848cb795af4e1d0.png"
width="500"
height="427"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>以目前的工艺水平来看，桥建议一步到位上进口桥，主流品牌有：&lt;/p>
&lt;ul>
&lt;li>I 桥 &lt;a href="https://independenttrucks.com/trucks" target="_blank" rel="noopener">Independent Trucks&lt;/a>&lt;/li>
&lt;li>V 桥 &lt;a href="https://venturetrucks.net" target="_blank" rel="noopener">VENTURE TRUCKS&lt;/a>&lt;/li>
&lt;li>T 桥或者叫雷桥 &lt;a href="https://www.thundertrucks.com" target="_blank" rel="noopener">THUNDER TRUCKS&lt;/a>&lt;/li>
&lt;li>D 桥 &lt;a href="https://destructotrucks.com" target="_blank" rel="noopener">DESTRUCTO&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以出厂硬度来说 Indy 大多为高软桥，V 桥有高有低硬桥，T 桥是低桥，D 桥大多高硬桥。高桥会把板子撑得更高，也能避免轮子太大卡板。板的硬度主要由 PU 决定，PU 全称 Polyurethane，聚氨基甲酸酯。刚接触滑板用硬桥更好，软桥比较考验使用者的平衡能力，从软硬角度考虑硬桥会比较稳，但切记不可通过拧紧主桥螺母来使 PU 变硬，PU 是可能被挤爆的。&lt;/p>
&lt;p>桥的宽度一般要与板匹配，以 I 桥为例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Truck Size&lt;/th>
&lt;th>Axle Width (in)&lt;/th>
&lt;th>Deck Size (in)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>215&lt;/td>
&lt;td>10.00&lt;/td>
&lt;td>9.5 - 10.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>169&lt;/td>
&lt;td>9.125&lt;/td>
&lt;td>9 - 9.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>159&lt;/td>
&lt;td>8.75&lt;/td>
&lt;td>8.6 - 9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>149&lt;/td>
&lt;td>8.50&lt;/td>
&lt;td>8.375 - 8.6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>144&lt;/td>
&lt;td>8.25&lt;/td>
&lt;td>8.2 - 3.375&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>139&lt;/td>
&lt;td>8.00&lt;/td>
&lt;td>7.8 - 8.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>129&lt;/td>
&lt;td>7.60&lt;/td>
&lt;td>7.4 - 7.8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>109&lt;/td>
&lt;td>6.90&lt;/td>
&lt;td>6.25 - 7.6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例如 8.25 的板子配 144 的 I 桥是最优的，根据材料和结构的不同，I 桥划分了几个系列：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>TRUCKS&lt;/th>
&lt;th>Tall&lt;/th>
&lt;th>Hanger&lt;/th>
&lt;th>Baseplate&lt;/th>
&lt;th>Axle&lt;/th>
&lt;th>Kingpin&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>STAGE 11 MID&lt;/td>
&lt;td>55mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>4140 Chromoly&lt;/td>
&lt;td>Grade 8&lt;/td>
&lt;td>215 Available&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 MID&lt;/td>
&lt;td>52mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>4140 Chromoly&lt;/td>
&lt;td>Inverted，Grade 8&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 HOLLOW&lt;/td>
&lt;td>55mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 FORGED HOLLOW&lt;/td>
&lt;td>53.5mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Forged 6061 Aluminum&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>10% Lighter&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>STAGE 11 FORGED TITANIUM&lt;/td>
&lt;td>53.5mm&lt;/td>
&lt;td>356 Aluminum&lt;/td>
&lt;td>Forged 6061 Aluminum&lt;/td>
&lt;td>Solid Titanium&lt;/td>
&lt;td>Hollow Chromoly&lt;/td>
&lt;td>15% Lighter&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>个人用的是 I 桥 144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard。&lt;/p>
&lt;figure id="figure-144-stage-11-forged-hollow-chris-joslin-silver-blue-standard">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://ptw.nhs-inc.com/product_images/48367.jpg" alt="144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard" loading="lazy" data-zoomable width="600" />&lt;/div>
&lt;/div>&lt;figcaption>
144 Stage 11 Forged Hollow Chris Joslin Silver Blue Standard
&lt;/figcaption>&lt;/figure>
&lt;h3 id="deck">Deck&lt;/h3>
&lt;p>
&lt;figure id="figure-侧视图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="侧视图" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_c29ee4e9d4982a31ba3c4e3bd052d9e5.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_e0e339aa904b3a89c75cc3db87b93938.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-side-view_hu173824dd48df387f224b656727befb4a_22205_c29ee4e9d4982a31ba3c4e3bd052d9e5.png"
width="550"
height="166"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
侧视图
&lt;/figcaption>&lt;/figure>
&lt;figure id="figure-俯视图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="俯视图" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_0f7588260c8af2202ad1f788dc7847d4.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_efaabd6a5103d31ac0642c332f58eeef.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/deck-top-view-mounting-holes_hub572d475d02f98ef6f85596cc965bea1_64134_0f7588260c8af2202ad1f788dc7847d4.png"
width="550"
height="228"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
俯视图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>比较好的版面有：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://girlskateboards.com/former-amateurs" target="_blank" rel="noopener">Girl Skateboards&lt;/a>&lt;/li>
&lt;li>Almost&lt;/li>
&lt;li>Baker&lt;/li>
&lt;li>&lt;a href="https://santacruzskateboards.com" target="_blank" rel="noopener">SANTA CRUZ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zeroskateboards.com" target="_blank" rel="noopener">Zero Skateboards&lt;/a>&lt;/li>
&lt;li>Element&lt;/li>
&lt;li>&lt;a href="https://chocolateskateboards.com/erik" target="_blank" rel="noopener">chocolate&lt;/a>&lt;/li>
&lt;li>Boardhead&lt;/li>
&lt;li>&lt;a href="https://flipskateboards.com" target="_blank" rel="noopener">flipskateboards&lt;/a>&lt;/li>
&lt;li>Powell Peralta&lt;/li>
&lt;li>Anti Hero&lt;/li>
&lt;/ul>
&lt;p>进口板一般弹性可以维持数个月以上，国产板稍差一些。木材与结构和胶水是板弹性的决定性因素，木质滑板一由七层枫木用胶水粘合后压制而成，核心在于每一层薄片的选材和质量把关。&lt;/p>
&lt;p>关于压制工艺：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>热压&lt;/strong>为加温压制，热压板更适合批量标准化生产，目前热压技术更普及&lt;/li>
&lt;li>&lt;strong>冷压&lt;/strong>为常温压制&lt;/li>
&lt;/ul>
&lt;p>热压和冷压对板弹性维持时间的影响微乎其微，两个压制的区别仅仅是在压制板的时候加不加温度，个人目前自用 GIRL，弹性很好。&lt;/p>
&lt;h3 id="wheels">Wheels&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_2b6e4bb4ca820f9e4cb2d6a2a12e00fd.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_f332793aa9f0e57c1eebecb8179cdaba.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/wheels_hue1ca365361d2c53ab95a2ec86ddd80cb_176815_2b6e4bb4ca820f9e4cb2d6a2a12e00fd.png"
width="300"
height="607"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>动作轮一般是硬轮，硬度在 99A - 105A 左右，直径一般在 52mm - 54mm 偏小，回弹更好做滑板动作。刚开始练习时，硬轮由于硬度关系很容易被小碎石卡住，如果没掌握正确的摔倒姿势的话就会很危险。反之公路轮为软轮，有时也会被叫做刷街轮，通常硬度在 78A 到 90A 左右，公路轮比较大和软一般会配高桥，直径一般在 55mm - 60mm，在公路上不震脚可以压过小石头，相对动作轮更安全舒服。所以建议同时有刷街和做动作需求的备两套轮子，并且由于取轴承是比较麻烦的事情，所以建议每套轮子都配上一套轴承。&lt;/p>
&lt;p>主流轮子品牌有：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bones.com" target="_blank" rel="noopener">BONES&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rictawheels.com" target="_blank" rel="noopener">RICTA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.spitfirewheels.com" target="_blank" rel="noopener">SPITFIRE WHEELS&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>对于公路轮由于体积较大，有卡板的风险，高速滑行时卡板会十分危险，通常 56mm 的即可。如果有需求要用更大的轮子比如 60mm，建议高桥再配合桥垫做增高，桥垫同样有避震的作用，可以防止桥把板体压坏。最后对于全能轮这个概念，个人觉得轮子只看硬度和大小，全能轮从硬度来看其实大多都是软轮。&lt;/p>
&lt;h3 id="bearings">Bearings&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_f4f7b5e1c2e26d0d4bf54cfbf2f0ff4e.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_85d0c364c9d2d8d3d9cf2cc35f43da27.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bearings_hud33645ae7a1689193279dd4a90c69e17_133396_f4f7b5e1c2e26d0d4bf54cfbf2f0ff4e.png"
width="300"
height="604"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>轴承的核心在于是否稳定，不容易爆轴，关于轴承的标准有 ABEC-5、ABEC-7、ABEC-9 等，比起数值来说更重要的还是稳定性。轴承比较推荐 Skate One 的 BONES，Skate One 还有另一个轴承品类 MINI LOGO，个人比较推荐 BONES Red，为国内代工。&lt;/p>
&lt;p>更高端的轴承有例如 BONES SWISS 陶瓷轴承，LUCKY 钛合金轴承，不过提升有限，边际效应较明显。&lt;/p>
&lt;h3 id="grip-tape-砂纸">Grip Tape 砂纸&lt;/h3>
&lt;p>没用过大牌的砂纸，砂纸个人认为是消耗极快的配件，&lt;/p>
&lt;h3 id="板钉">板钉&lt;/h3>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="" srcset="
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_4acc4c757fdfd5ccdd00f02e7e72e8f0.png 400w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_07b44e926cfee555ddcb8308b530c238.png 760w,
/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_1200x1200_fit_lanczos_2.png 1200w"
src="/2020/09/09/%E6%BB%91%E6%9D%BF%E9%80%89%E9%85%8D-101/bolts-nuts_hu61d19f7ef4b9fa84efb6feb4b6ab309e_87514_4acc4c757fdfd5ccdd00f02e7e72e8f0.png"
width="300"
height="332"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>最普通的配件，没什么好说的，太贵的就是智商税。&lt;/p>
&lt;h3 id="护具">护具&lt;/h3>
&lt;p>护具该有的还是要有，尤其是刚接触滑板的新人，保护好自己是非常重要的。像滑板、滑雪之类的运动，首要就是要学会如何摔倒，掌握正确的摔倒姿势与方法才能更好的保护自己，护具能够很好的帮助度过这个学习期的，切忌嫌护具丑而不带护具，骨折了可就得不偿失了。&lt;/p>
&lt;h3 id="关于鞋子">关于鞋子&lt;/h3>
&lt;p>不考虑代步，如果是经常做动作的话，鞋底很容易被砂纸磨薄，做动作的建议配一双滑板鞋，比较专业的牌子如下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.dcshoes.com/?geopopup=false" target="_blank" rel="noopener">DC Shoes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.vanstaiwan.com" target="_blank" rel="noopener">Vans&lt;/a>，容易开胶，Pro 系列只推荐联名 &lt;a href="https://www.vans.com/team/skate/geoff-rowley.html" target="_blank" rel="noopener">Geoff Rowley&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.esskateboarding.com/us/" target="_blank" rel="noopener">éS Skateboarding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.emerica.com/us/" target="_blank" rel="noopener">Emerica&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.etnies.com/us/" target="_blank" rel="noopener">Etnies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.converse.com.tw" target="_blank" rel="noopener">CONVERSE&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fallenfootwear.us" target="_blank" rel="noopener">FALLEN FOOTWEAR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.lakai.com" target="_blank" rel="noopener">LAKAI&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.dekline.com" target="_blank" rel="noopener">DEKLINE FOOTWEAR&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="养护方法">养护方法&lt;/h2>
&lt;h3 id="桥">桥&lt;/h3>
&lt;p>桥作为最重要的核心大件，零件较多需要分开讲。&lt;/p>
&lt;h4 id="主体">主体&lt;/h4>
&lt;p>桥作为一个较为耐用的部件，建议进行一定程度的保养。一些桥比如 I 桥的桥轴部分是锻造铬钼钢，空心桥轴内部非常生锈，建议用防锈油进行保养。切忌不要用桥撬轴承，桥的螺纹是很错弱的。&lt;/p>
&lt;h4 id="pu">PU&lt;/h4>
&lt;p>PU 作为减震器，和人的膝盖一样很脆弱，切忌主桥钉螺母不能拧过紧以避免 PU 开裂或者被挤爆，部分选手喜欢拧紧主要是不熟悉过软的桥导致的左右晃动，正确方式是换一个更硬的 PU。&lt;/p>
&lt;h4 id="桥端螺母">桥端螺母&lt;/h4>
&lt;p>侧螺母具有保护桥端螺纹的作用，一旦发现螺母形变或者滑牙需要及时更换，防止支架被的螺纹被螺母损坏。一般建议多备一些侧螺母，经常更换以保护桥主体。&lt;/p>
&lt;h3 id="板面">板面&lt;/h3>
&lt;p>滑板的板面通常是木制，相对其他的金属件来说会更脆弱，动作板为了保持弹性要注意尽量保持干燥，使用上切忌爱惜板面而放不开，每换一块板意味着你的一次成长。雨雪天的情况下不要玩板，如果不防水的板沾水，木头就会受潮变得酥软，从而失去弹性。&lt;/p>
&lt;h3 id="轴承">轴承&lt;/h3>
&lt;p>轴承是主要的承重部位，轮子受到强烈的冲击后，非常容易被挤压导致爆轴承。同时由于轴承非常贴近地面，间隙之间极易容易进入小的颗粒物，高速旋转的状态下很快就会磨损，顺滑度也会降低，慢慢的就会损坏。此外如果是不防锈的轴承则需要注意进水生锈，如果不小心轮子过水，需要快速转动轮子甩水。&lt;/p>
&lt;p>轴承特别容易藏污纳垢，高端的轴承建议常清洗。轴承清洗时需要把防尘盖拆除，具体方法用曲别针从轴承的另一侧将防尘盖顶出，拆下的防尘盖用水清洗做一下防锈即可。轴承部分可以用 95% 酒精、汽油、煤油等油污易溶溶剂清洗，讲究一点可以配合 Bones 的清洗瓶。清洗轴承的主要目的是去除原本的润滑油脂或者防锈油以及滑行过程中残留的污垢，洗完后去除水分保持干燥然后上润滑油接着使用或者上防锈油储藏，润滑油大同小异，讲究的可以用 Bones 的润滑油。一般新轴承上油脂是用于防止轴承生锈，没有润滑作用，所以在洗完之后需要上润滑油。&lt;/p>
&lt;h3 id="轮子">轮子&lt;/h3>
&lt;p>不怎么容易坏的耗材，变形或者坏了换新即可。&lt;/p>
&lt;h3 id="砂纸">砂纸&lt;/h3>
&lt;p>由于砂纸被踩在脚下，所以极其容易脏。砂纸不能用水清洗，会脱沙水失去摩擦力，板就没法被脚带起来。如果觉得没有到要换的程度的话，可以用砂纸擦进行处理，砂纸太脏建议直接更换。&lt;/p>
&lt;h3 id="桥钉">桥钉&lt;/h3>
&lt;p>最廉价的部件，不用怎么保养坏了就换。&lt;/p>
&lt;p>总结来说不用过于爱惜板，板存在的价值是用来滑的，板越新越说明是板混。滑板一旦长久搁置就容易受潮生锈，板也会失去弹性，一个玩了很久的板还和新的一样的话，它就失去了灵魂。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Skateboard" target="_blank" rel="noopener">Skateboard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://independenttrucks.com/truck-guide" target="_blank" rel="noopener">TRUCK GUIDE&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://venturetrucks.net/sizes/" target="_blank" rel="noopener">RIDE THE RIGHT SIZE TRUCK&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.thundertrucks.com/sizing/" target="_blank" rel="noopener">CHOOSE THE RIGHT SIZE FOR YOU&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://destructotrucks.com" target="_blank" rel="noopener">DESTRUCTO&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.skateone.com" target="_blank" rel="noopener">Skate One&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.startskateboardingnow.com/skateboard-anatomy-101.html" target="_blank" rel="noopener">Skateboard Anatomy 101&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="glossary">Glossary&lt;/h2>
&lt;h4 id="部件">部件&lt;/h4>
&lt;ul>
&lt;li>Deck 板&lt;/li>
&lt;li>Truck 桥&lt;/li>
&lt;li>Wheel 轮子&lt;/li>
&lt;li>Bearing 轴承&lt;/li>
&lt;li>Baseplate 底座&lt;/li>
&lt;/ul>
&lt;h4 id="truck">Truck&lt;/h4>
&lt;ul>
&lt;li>Tall 高度&lt;/li>
&lt;li>Axle nut 桥轴端螺母&lt;/li>
&lt;li>Axle washers 桥轴端垫片x&lt;/li>
&lt;li>Axle 桥轴&lt;/li>
&lt;li>Hanger 悬轴&lt;/li>
&lt;li>Kingpin 转向立轴&lt;/li>
&lt;li>Kingpin nut 立轴螺母&lt;/li>
&lt;li>Top cup washer 顶部杯形垫圈&lt;/li>
&lt;li>Bushing PU 垫&lt;/li>
&lt;li>Cone bushing 锥型 PU 垫&lt;/li>
&lt;li>Cushing 软垫&lt;/li>
&lt;li>Lower cup washer 底部杯形垫圈&lt;/li>
&lt;/ul>
&lt;h4 id="材料">材料&lt;/h4>
&lt;ul>
&lt;li>Aluminum 铝合金&lt;/li>
&lt;li>Chromoly 铬钼钢&lt;/li>
&lt;li>Forged Aluminum 锻造铝合金&lt;/li>
&lt;li>Hollow Chromoly 中空铬钼钢&lt;/li>
&lt;li>Solid Titanium 纯钛&lt;/li>
&lt;li>Grade 8 美制 8 级标准&lt;/li>
&lt;li>Inverted 倒置&lt;/li>
&lt;/ul></description></item><item><title>Typefaces 索引</title><link>/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/</link><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><guid>/2019/10/15/typefaces-%E7%B4%A2%E5%BC%95/</guid><description>&lt;h2 id="adobe-fonts">Adobe Fonts&lt;/h2>
&lt;h4 id="source-serifhttpsadobe-fontsgithubiosource-serif">&lt;a href="https://adobe-fonts.github.io/source-serif/" target="_blank" rel="noopener">Source Serif&lt;/a>&lt;/h4>
&lt;h4 id="source-sanshttpsadobe-fontsgithubiosource-sans">&lt;a href="https://adobe-fonts.github.io/source-sans/" target="_blank" rel="noopener">Source Sans&lt;/a>&lt;/h4>
&lt;h4 id="source-code-prohttpsadobe-fontsgithubiosource-code-pro">&lt;a href="https://adobe-fonts.github.io/source-code-pro/" target="_blank" rel="noopener">Source Code Pro&lt;/a>&lt;/h4>
&lt;h2 id="microsoft-fonts">Microsoft Fonts&lt;/h2>
&lt;h4 id="cascadia-codehttpsgithubcommicrosoftcascadia-code">&lt;a href="https://github.com/microsoft/cascadia-code" target="_blank" rel="noopener">Cascadia Code&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/microsoft/cascadia-code/main/images/cascadia-code.png" alt="" loading="lazy" data-zoomable width="300px" />&lt;/div>
&lt;/div>&lt;/figure>
&lt;ul>
&lt;li>&lt;code>Cascadia Code&lt;/code>: standard version of Cascadia&lt;/li>
&lt;li>&lt;code>Cascadia Mono&lt;/code>: a version of Cascadia that doesn&amp;rsquo;t have ligatures&lt;/li>
&lt;li>&lt;code>Cascadia (Code|Mono) PL&lt;/code>: a version of Cascadia that has embedded Powerline symbols&lt;/li>
&lt;/ul>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/microsoft/cascadia-code/main/images/cascadia-code-characters.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="google-fontshttpsfontsgooglecom">&lt;a href="https://fonts.google.com" target="_blank" rel="noopener">Google Fonts&lt;/a>&lt;/h2>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./google-fonts.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h4 id="google-noto-fontshttpswwwgooglecomgetnoto">&lt;a href="https://www.google.com/get/noto/" target="_blank" rel="noopener">Google Noto Fonts&lt;/a>&lt;/h4>
&lt;h2 id="jetbrains-fonts">JetBrains Fonts&lt;/h2>
&lt;h4 id="jetbrains-monohttpswwwjetbrainscomlpmono">&lt;a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">JetBrains Mono&lt;/a>&lt;/h4>
&lt;h2 id="other-fonts">Other Fonts&lt;/h2>
&lt;h4 id="firacodehttpsgithubcomtonskyfiracode">&lt;a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">FiraCode&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/tonsky/FiraCode/master/extras/download.png" alt="" loading="lazy" data-zoomable width="300px" />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure id="figure-ligatures-cheatsheet">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://raw.githubusercontent.com/tonsky/FiraCode/master/extras/ligatures.png" alt="ligatures cheatsheet" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ligatures cheatsheet
&lt;/figcaption>&lt;/figure>
&lt;h4 id="geomanisthttpswwwatipofoundrycomfontsgeomanist">&lt;a href="https://www.atipofoundry.com/fonts/geomanist" target="_blank" rel="noopener">geomanist&lt;/a>&lt;/h4>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.atipofoundry.com/media/pages/fonts/geomanist/2024424344-1591511652/geomanist-01.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">tonsky/FiraCode&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>如何写出一篇好博文</title><link>/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>/2019/09/11/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E5%8D%9A%E6%96%87/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>谈起这个博客，建立之初只是为了记录一些技术相关的话题，用来沉淀一些日常学习的技术知识点以及做备忘用。随着时间流逝已经 5 个年头了，写作也变成了一个习惯保持了下来，也不断的尝试从原来的计算机科学学术类逐渐扩大到 STEM 乃至其他的各类型的文章。&lt;/p>
&lt;ul class="cta-group">
&lt;li>
&lt;a href="/post/gossip/first-post" target="_blank" rel="noopener" class="btn btn-primary px-3 py-3">&lt;strong>创篇号&lt;/strong> (2014)&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>随着不断的学习与深入，就越发会觉得自身各类知识面的狭窄与片面，潜在的求知欲被这种外在的驱动力所激发，促使着你不断挖掘知识的深度与拓宽学术广度。在写作过程中，如何组织与管理跨学科文章，如何针对选题主旨拿捏文本表现形式成为了不小的问题。由于理工科和文科在学术侧重上的区别会导致行文风格和段落组织大相径庭，比如 STEM 更强调数理逻辑和科学证明，会以各类图表和数据来增加文本说服力；在文章的选题上存在强调客观事实的文档或者说明类，也存在发表个人观点的强主观意愿的内容，不同的文章会有不同的处理方式，后续有机会抽几个章节赘述。&lt;/p>
&lt;h2 id="为什么要写文章">为什么要写文章&lt;/h2>
&lt;p>就如美国物理学家&lt;a href="https://en.wikipedia.org/wiki/John_Archibald_Wheeler" target="_blank" rel="noopener">约翰·阿奇博尔德·惠勒&lt;/a>所说：&lt;/p>
&lt;blockquote>
&lt;p>“One can only learn by teaching.” — John Archibald Wheeler&lt;/p>
&lt;/blockquote>
&lt;p>以教为学是一个很好的学习方法，如果一个复杂深奥的问题能用直白浅显的语言讲清楚并传授给他人，那么说明这个知识点已经被学习者真正理解并运用。通常这么做可以促使你剖析知识要点，用你自己对领域知识的了解程度去做易懂的总结，这个过程会促使你回顾你学习过的内容，对知识盲区进行查漏补缺，直到最终能够用大白话、最简单的术语去描述并让人听懂。从个人角度来说，写文章的本质就是学习的沉淀，沉淀的目的是为了提炼再利用，这个过程就是一个知识的提炼总结以及教授传递。就好比字典、词典存在的意义：&lt;/p>
&lt;ul>
&lt;li>提供语言领域内的使用指南&lt;/li>
&lt;li>字、词汇、语言的知识点速查&lt;/li>
&lt;li>知识的传递&lt;/li>
&lt;/ul>
&lt;p>写文章简单，写出有深度的文章难，写出即易懂又有深度的文章是难中之难。只学不沉淀必然会遗忘，再次遇到同样的问题就需要花时间重新回忆或直接踩坑，这就是写作与沉淀的目的。同样，在提炼沉淀之余，分类与索引也是必不可少的，上文提到写作的重要目的之一是再利用，如果只是写了文章而从不去使用，那就好比把一篇很有营养的文章加入了你的收藏夹，心想下次一定能用到，渐渐的你就会发现收藏夹越来越臃肿难以管理，最终变成你成长过程中的过客，这样的场景是不是似曾相识。&lt;/p>
&lt;p>所以本博客的所有文章会以忽略选题的内容为前提，把文章内容涉及到的学科领域作为类别归属，在此基础上以 CIP 的策略作分类化管理，使得学科特定的知识点查找与索引会非常简便。&lt;/p>
&lt;h2 id="写作工具">写作工具&lt;/h2>
&lt;h3 id="博客系统">博客系统&lt;/h3>
&lt;h4 id="hugo">Hugo&lt;/h4>
&lt;p>开发者文档&lt;/p>
&lt;p>&lt;a href="https://gohugo.io/documentation/" target="_blank" rel="noopener">Docs&lt;/a>&lt;/p>
&lt;h4 id="hexo">Hexo&lt;/h4>
&lt;p>关于 Hexo 的搭建可以参考
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">用 Hexo 搭建个人博客&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/p>
&lt;h3 id="用富媒体润色文本">用富媒体润色文本&lt;/h3>
&lt;h4 id="图标">图标&lt;/h4>
&lt;p>&lt;a href="https://www.flaticon.com" target="_blank" rel="noopener">flaticon&lt;/a>&lt;/p>
&lt;h4 id="图床">图床&lt;/h4>
&lt;p>出于各种目的，比如减少服务器的压力、加快加载速度、减少发布包的体积等，图片资源会通常以 CDN 的形式来存储与部署，这里就要用到各种 CDN 服务。&lt;/p>
&lt;ul>
&lt;li>
&lt;h5 id="github-user-images">GitHub &lt;code>user-images&lt;/code>&lt;/h5>
&lt;p>在 GitHub 提 &lt;code>issue&lt;/code> 时添加图片，GitHub 会将图片资源会分发至 CDN，生成地址为 &lt;code>user-images.githubusercontent.com/{path}/{hash}&lt;/code> 的链接，从某种角度来看 GitHub 可以用来作图床。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="用更强说服力的图表代替语言">用更强说服力的图表代替语言&lt;/h3>
&lt;h4 id="mermaid">Mermaid&lt;/h4>
&lt;p>&lt;a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">Mermaid&lt;/a> 是一个集流程图、状态图、时序图、甘特图绘制库，使用 DSL 代码就可以绘制出漂亮清晰的图片，配合上 markdown 是 STEM 相关文章的利器，同时提供了&lt;a href="https://mermaid-js.github.io/mermaid-live-editor/" target="_blank" rel="noopener">在线编辑器&lt;/a>提供实时预览。&lt;/p>
&lt;h4 id="plotly">Plotly&lt;/h4>
&lt;p>&lt;a href="https://plotly.com" target="_blank" rel="noopener">Plotly&lt;/a> 是一个通过 &lt;code>JSON&lt;/code> 作为数据源的图标绘制工具，并且提供了可视化&lt;a href="http://plotly-json-editor.getforge.io" target="_blank" rel="noopener">在线编辑工具&lt;/a>。&lt;/p>
&lt;h2 id="文章的表现力">文章的表现力&lt;/h2>
&lt;p>表现力需要更具选题的内容来作具体调整。&lt;/p>
&lt;h3 id="stem">STEM&lt;/h3>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2014).
&lt;a href="/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/">创篇号&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol></description></item><item><title>鼻炎与鼻窦炎全解析</title><link>/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate><guid>/2019/05/11/%E9%BC%BB%E7%82%8E%E4%B8%8E%E9%BC%BB%E7%AA%A6%E7%82%8E%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>&lt;h2 id="鼻炎">鼻炎&lt;/h2>
&lt;p>鼻炎和咽炎有着密切的联系，临床上治咽炎先治鼻炎的病例很多，因为人体的五官是相通的，咽炎主要是由于咽喉位于呼吸道与消化道的要冲。长期鼻塞、张开呼吸造成干冷空气直达喉部而产生干痛。而粘稠痰常附于咽喉壁克引起刺激性咳嗽，甚至引起恶心、干呕。长期鼻涕倒流刺激咽喉引起咽喉炎如异物感、咽痒、灼热、干燥、微疼等。&lt;/p>
&lt;p>鼻炎是特别让人不舒服的病，得了鼻炎，呼吸不顺畅，连睡觉都睡不好真是让人烦恼。在大城市中，每十个人里面，就有一个是鼻炎患者，久治不愈很容易变成致死性的鼻咽癌，鼻咽癌是我国高发恶性肿瘤之一，发病率为耳鼻咽喉恶性肿瘤之首。全世界 80% 的鼻咽恶性肿瘤是鼻炎久治不愈恶化所致。鼻咽癌的表现为病侧耳鸣且逐渐加重，并伴有听力下降。鼻炎的主要危害有儿童毁容、学生智商降低、女性对生育造成严重影响、男性增加患高血压的风险、老年人危害生命。鼻炎是一种常见病，同时也是一种危险的疾病，如不及时治疗就会导致多种并发症如慢性鼻炎、鼻窦炎等。&lt;/p>
&lt;p>2017 年 11 月 29 日星尚频道 X 诊所节，主题《鼻炎知多少》，嘉宾刘环海，第二军医大学附属长征医院耳鼻咽喉头颈外科科室主任，上海市耳鼻咽喉头颈外科学会常委兼秘书长。&lt;/p>
&lt;h2 id="鼻窦炎病理">鼻窦炎病理&lt;/h2>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/RywHs4kKxjA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="窦道堵塞">窦道堵塞&lt;/h2>
&lt;h3 id="症状缓解">症状缓解&lt;/h3>
&lt;p>通常来说，窦道堵塞是由于鼻窦黏膜水肿导致。在不借助手术、洗鼻等外部手段的情况下，缓解堵塞的方法通常是以加速鼻腔部位的血脉循环为主要手段，所以鼻窦炎患者在一些特定的场景下，可能会出现窦道短暂的通畅，包括但不限于：&lt;/p>
&lt;ul>
&lt;li>精神紧张或者突然收到惊吓，交感神经的兴奋会使得血管收缩&lt;/li>
&lt;li>就寝时单侧窦道堵塞，采用对侧卧位睡姿，堵住侧会变得通畅&lt;/li>
&lt;li>进行运动之后，运动会使得全身血液更加循环畅通，通常窦道缓解的时间会相对更长，运动对于鼻窦炎以及自身免疫会有很大帮助&lt;/li>
&lt;/ul>
&lt;p>日常对脸部的穴位按摩也能促进血液循环，包括迎香穴和两眉之间，额窦的部位就是在眉间偏上部位，其带来效果的通畅常常持续几分钟左右。血液循环畅通了，黏膜水肿自然会暂时缓解，更多可以参考下方视频。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/-vBGW43EjG4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h3 id="注意事项">注意事项&lt;/h3>
&lt;p>鼻窦炎患者要注意尽量避免接触突然的冷空气或者其他刺激性气味或者各类过敏源。&lt;/p></description></item><item><title>Slides</title><link>/slides/example/</link><pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate><guid>/slides/example/</guid><description>&lt;h1 id="create-slides-in-markdown-with-wowchemy">Create slides in Markdown with Wowchemy&lt;/h1>
&lt;p>&lt;a href="https://wowchemy.com/" target="_blank" rel="noopener">Wowchemy&lt;/a> | &lt;a href="https://owchemy.com/docs/managing-content/#create-slides" target="_blank" rel="noopener">Documentation&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="features">Features&lt;/h2>
&lt;ul>
&lt;li>Efficiently write slides in Markdown&lt;/li>
&lt;li>3-in-1: Create, Present, and Publish your slides&lt;/li>
&lt;li>Supports speaker notes&lt;/li>
&lt;li>Mobile friendly slides&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="controls">Controls&lt;/h2>
&lt;ul>
&lt;li>Next: &lt;code>Right Arrow&lt;/code> or &lt;code>Space&lt;/code>&lt;/li>
&lt;li>Previous: &lt;code>Left Arrow&lt;/code>&lt;/li>
&lt;li>Start: &lt;code>Home&lt;/code>&lt;/li>
&lt;li>Finish: &lt;code>End&lt;/code>&lt;/li>
&lt;li>Overview: &lt;code>Esc&lt;/code>&lt;/li>
&lt;li>Speaker notes: &lt;code>S&lt;/code>&lt;/li>
&lt;li>Fullscreen: &lt;code>F&lt;/code>&lt;/li>
&lt;li>Zoom: &lt;code>Alt + Click&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://github.com/hakimel/reveal.js#pdf-export" target="_blank" rel="noopener">PDF Export&lt;/a>: &lt;code>E&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="code-highlighting">Code Highlighting&lt;/h2>
&lt;p>Inline code: &lt;code>variable&lt;/code>&lt;/p>
&lt;p>Code block:&lt;/p>
&lt;pre>&lt;code class="language-python">porridge = &amp;quot;blueberry&amp;quot;
if porridge == &amp;quot;blueberry&amp;quot;:
print(&amp;quot;Eating...&amp;quot;)
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="math">Math&lt;/h2>
&lt;p>In-line math: $x + y = z$&lt;/p>
&lt;p>Block math:&lt;/p>
&lt;p>$$
f\left( x \right) = ;\frac{{2\left( {x + 4} \right)\left( {x - 4} \right)}}{{\left( {x + 4} \right)\left( {x + 1} \right)}}
$$&lt;/p>
&lt;hr>
&lt;h2 id="fragments">Fragments&lt;/h2>
&lt;p>Make content appear incrementally&lt;/p>
&lt;pre>&lt;code>{{% fragment %}} One {{% /fragment %}}
{{% fragment %}} **Two** {{% /fragment %}}
{{% fragment %}} Three {{% /fragment %}}
&lt;/code>&lt;/pre>
&lt;p>Press &lt;code>Space&lt;/code> to play!&lt;/p>
&lt;p>&lt;span class="fragment " >
One
&lt;/span>
&lt;span class="fragment " >
&lt;strong>Two&lt;/strong>
&lt;/span>
&lt;span class="fragment " >
Three
&lt;/span>&lt;/p>
&lt;hr>
&lt;p>A fragment can accept two optional parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>class&lt;/code>: use a custom style (requires definition in custom CSS)&lt;/li>
&lt;li>&lt;code>weight&lt;/code>: sets the order in which a fragment appears&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="speaker-notes">Speaker Notes&lt;/h2>
&lt;p>Add speaker notes to your presentation&lt;/p>
&lt;pre>&lt;code class="language-markdown">{{% speaker_note %}}
- Only the speaker can read these notes
- Press `S` key to view
{{% /speaker_note %}}
&lt;/code>&lt;/pre>
&lt;p>Press the &lt;code>S&lt;/code> key to view the speaker notes!&lt;/p>
&lt;aside class="notes">
&lt;ul>
&lt;li>Only the speaker can read these notes&lt;/li>
&lt;li>Press &lt;code>S&lt;/code> key to view&lt;/li>
&lt;/ul>
&lt;/aside>
&lt;hr>
&lt;h2 id="themes">Themes&lt;/h2>
&lt;ul>
&lt;li>black: Black background, white text, blue links (default)&lt;/li>
&lt;li>white: White background, black text, blue links&lt;/li>
&lt;li>league: Gray background, white text, blue links&lt;/li>
&lt;li>beige: Beige background, dark text, brown links&lt;/li>
&lt;li>sky: Blue background, thin dark text, blue links&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>night: Black background, thick white text, orange links&lt;/li>
&lt;li>serif: Cappuccino background, gray text, brown links&lt;/li>
&lt;li>simple: White background, black text, blue links&lt;/li>
&lt;li>solarized: Cream-colored background, dark green text, blue links&lt;/li>
&lt;/ul>
&lt;hr>
&lt;section data-noprocess data-shortcode-slide
data-background-image="/media/boards.jpg"
>
&lt;h2 id="custom-slide">Custom Slide&lt;/h2>
&lt;p>Customize the slide style and background&lt;/p>
&lt;pre>&lt;code class="language-markdown">{{&amp;lt; slide background-image=&amp;quot;/media/boards.jpg&amp;quot; &amp;gt;}}
{{&amp;lt; slide background-color=&amp;quot;#0000FF&amp;quot; &amp;gt;}}
{{&amp;lt; slide class=&amp;quot;my-style&amp;quot; &amp;gt;}}
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="custom-css-example">Custom CSS Example&lt;/h2>
&lt;p>Let&amp;rsquo;s make headers navy colored.&lt;/p>
&lt;p>Create &lt;code>assets/css/reveal_custom.css&lt;/code> with:&lt;/p>
&lt;pre>&lt;code class="language-css">.reveal section h1,
.reveal section h2,
.reveal section h3 {
color: navy;
}
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h1 id="questions">Questions?&lt;/h1>
&lt;p>&lt;a href="https://github.com/wowchemy/wowchemy-hugo-modules/discussions" target="_blank" rel="noopener">Ask&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wowchemy.com/docs/managing-content/#create-slides" target="_blank" rel="noopener">Documentation&lt;/a>&lt;/p></description></item><item><title>Google Developer Days China 2018 参会记录</title><link>/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/</link><pubDate>Thu, 20 Sep 2018 09:00:00 +0000</pubDate><guid>/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/</guid><description>&lt;h2 id="tensorflow-亲儿子">TensorFlow 亲儿子&lt;/h2>
&lt;p>TensorFlow 是本届 GDD 的重点照顾对象，在开幕演讲中一位 Googla AI 的产品经理对 Google AI 的应用落地场景进行了简单的介绍，同时推荐了自家今年三月份的上线的 &lt;a href="https://developers.google.com/machine-learning/crash-course/" target="_blank" rel="noopener">MLCC&lt;/a>，旨在帮助广大爱好者快速无障碍入门 AI，在大幅降低门槛的前提下，使得每个人都能参与到其中。&lt;/p>
&lt;div class="gallery">
&lt;a data-fancybox="gallery-album-tensorflow" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/anna-goldie.jpg" data-caption="Google AI 妹子工程师上台对自家 TensorFlow 进行了一波带有东北腔的美式中文吹爆">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/anna-goldie_hu1fdb335153f0d2d0545519bf98049712_2163713_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Google AI 妹子工程师上台对自家 TensorFlow 进行了一波带有东北腔的美式中文吹爆" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-album-tensorflow" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/lstm-networks.jpg" data-caption="中国海洋大学的科研人员借助 TensorFlow，通过使用 LSTM NetWorks 对 SST 进行可靠的预测，以达到分析全球气候状况的目的">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/lstm-networks_hu4039956df141fc22aba2cdc6a530014a_2213994_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="中国海洋大学的科研人员借助 TensorFlow，通过使用 LSTM NetWorks 对 SST 进行可靠的预测，以达到分析全球气候状况的目的" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-album-tensorflow" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/opensource.jpg" data-caption="开源社区对于 TensorFlow 的贡献量，全球 1700 万的下载量中有 200 万来自中国用户贡献">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/opensource_hud1d1d31e0d1eba5a215940f27ce8804b_1596409_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="开源社区对于 TensorFlow 的贡献量，全球 1700 万的下载量中有 200 万来自中国用户贡献" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-album-tensorflow" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/tensorflow-china.jpg" data-caption="在中国正在使用 TensorFlow 的公司">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/album-tensorflow/tensorflow-china_hu5db801f804357f93cc2291fb1f1cbdf1_2398937_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="在中国正在使用 TensorFlow 的公司" width="253" height="190">
&lt;/a>
&lt;/div>
&lt;p>同时一起宣布的还有 Google AI 中国中心会在北京以及上海举行机器学习应用冬令营，并且在可能的情况下会提供 Google AI 工程师的实习机会，将其更好的运用到实战。&lt;/p>
&lt;p>紧接着开幕演讲，主会场在 11:00 召开了面向所有开发者的 TensorFlow 简介。&lt;/p>
&lt;figure id="figure-introduce-to-tensorflow">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Introduce to Tensorflow" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/introduce-to-tensorflow_hu23ce946b82d0ce5dd327bbcf3ba4e682_2091819_6fb137a1a1dd585dfd1162b78cc4eb15.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/introduce-to-tensorflow_hu23ce946b82d0ce5dd327bbcf3ba4e682_2091819_c101f7a97aa68b7481af0de65dcfabb3.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/introduce-to-tensorflow_hu23ce946b82d0ce5dd327bbcf3ba4e682_2091819_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/introduce-to-tensorflow_hu23ce946b82d0ce5dd327bbcf3ba4e682_2091819_6fb137a1a1dd585dfd1162b78cc4eb15.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Introduce to Tensorflow
&lt;/figcaption>&lt;/figure>
&lt;p>会上介绍了什么是 TensorFlow、它是如何运作的、它该如何使用。介绍了 TensorFlow 这个平台如何更方便的帮助开发者构建要用于人工智能应用中的机器学习模型。&lt;/p>
&lt;p>会上展示了一个 Fashion MNIST 的现场 Demo。&lt;/p>
&lt;figure id="figure-fashion-mnist">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Fashion MNIST" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/fashion-mnist_hub32d6cb42ca210947571c154672526ae_2056479_c69cc09e08735e50a4989b3a146242cc.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/fashion-mnist_hub32d6cb42ca210947571c154672526ae_2056479_1819129b27d44ab0240e031d165f51e6.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/fashion-mnist_hub32d6cb42ca210947571c154672526ae_2056479_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/fashion-mnist_hub32d6cb42ca210947571c154672526ae_2056479_c69cc09e08735e50a4989b3a146242cc.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Fashion MNIST
&lt;/figcaption>&lt;/figure>
&lt;p>具体演示了如何利用 Keras 对 70000 个训练样本、10 个类别进行神经网络训练，包涵 Keras 一系列的：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://keras.io/models/sequential/" target="_blank" rel="noopener">Sequential Model 的建立&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keras.io/losses" target="_blank" rel="noopener">loss 函数的配置&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keras.io/optimizers/" target="_blank" rel="noopener">Optimizer 的选择&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keras.io/getting-started/sequential-model-guide/#training" target="_blank" rel="noopener">Model 的训练方式&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>大部分演示内容的要点都可以在 &lt;a href="https://keras.io" target="_blank" rel="noopener">Keras Documentation&lt;/a> 中找到。&lt;/p>
&lt;p>在 20 号当天下午还有一场《编写机器学习的7个步骤》Keynote 以及 21 号一整天的《TensorFlow 专场》传销大会。内容涵盖了：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/tensorflow/swift" target="_blank" rel="noopener">Swift for TensorFlow&lt;/a> 以及 &lt;a href="https://js.tensorflow.org" target="_blank" rel="noopener">tensorflow.js&lt;/a>，Swift 版本的 TensorFlow 早在今年 4 月已经开源，笔者感到很欣慰，作为一个 Apple Developer 终于不用担心苹果倒闭后需要面临失业的问题&lt;/li>
&lt;li>TensorFlow Lite 允许 App 开发者压缩和优化 TensorFlow 模型，使之能在 Android、iOS 和各种物联网设备上运行，使得在未连接到云端的移动设备上运行智能应用变得可能&lt;/li>
&lt;li>TensorFlow 的 DistributionStrategy Class 使得将工作量分散到多个 GPU、多节点训练变得可能，为训练大型机器学习模型提供了实际的解决方案&lt;/li>
&lt;/ul>
&lt;p>不过由于时间关系上述的 Keynote 笔者都没能参与，还是非常可惜的。&lt;/p>
&lt;h2 id="flutter-的磅礴野心">Flutter 的磅礴野心&lt;/h2>
&lt;p>&lt;a href="https://flutter.io" target="_blank" rel="noopener">Flutter&lt;/a> 可以说是本届 GDD 上的焦点主题，在此次大会上 Google 公布了 Flutter Release Preview 2，距离 Flutter 正式 Release 也变得指日可待。&lt;/p>
&lt;figure id="figure-flutter-release-preview-2">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Flutter Release Preview 2" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-release-preview-2_hued49deb0a14b6e58ca973ce633a329a7_2063494_2ac1b74ec625e50e0576bf8cab2de7c0.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-release-preview-2_hued49deb0a14b6e58ca973ce633a329a7_2063494_7bd0764087684d87e2f3196cb07dc5c3.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-release-preview-2_hued49deb0a14b6e58ca973ce633a329a7_2063494_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-release-preview-2_hued49deb0a14b6e58ca973ce633a329a7_2063494_2ac1b74ec625e50e0576bf8cab2de7c0.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Flutter Release Preview 2
&lt;/figcaption>&lt;/figure>
&lt;p>在 20 日当天有关 Flutter 的 Keynote 一共被安排了 4 场，下午 4:45 开始的连续两场的内容关注点都在 Flutter 底层原理剖析以及 High Performance 上，因此笔者选择了去这两场。&lt;/p>
&lt;p>笔者在等待 Keynote 开始的期间，去产品展示区溜达了一圈，溜着溜着就溜到了 Flutter 展台，只见 Flutter 的几个工程师一直被围在人群之中回答问题，周围围观的吃瓜开发者疯狂输出问题，场面异常劲爆。Flutter 展台也是为数不多的吃瓜群众把注意力全放在内容本身而不是礼品和贴纸上的展台了。笔者靠着精致的走位顺利插入展台前排。在实际体验之后发现 Flutter 在运行过程中，除了部分场景下（大部分是 ScrollView 的场景下）出现了不跟手的情况，大部分情况下都十分流畅，在和 Flutter 工程师交流后也得到了解答，无论是 iOS 和 Android 都是基于 Skia 的 API 进行渲染，并且 iOS 底层和安卓一样也是基于 OpenGL ES 实现的，关于 iOS Skia 是如何编译可以参考这篇&lt;a href="https://skia.org/user/build" target="_blank" rel="noopener">文档&lt;/a>。&lt;/p>
&lt;div class="gallery">
&lt;a data-fancybox="gallery-youtube-and-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/flutter-booth.jpg" data-caption="带着蓝带子吊牌的老哥就是之后 Keynote 的主讲，一旁的 YouTube 展台异常冷清">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/flutter-booth_huf875a42ff9fca7575da9d1bff11b50d9_2320467_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="带着蓝带子吊牌的老哥就是之后 Keynote 的主讲，一旁的 YouTube 展台异常冷清" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-youtube-and-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/flutter-demo.jpg" data-caption="Flutter 展台 Demo 应用">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/flutter-demo_hu70c92a06a13a95bb3317a70bae1f5e0f_1447665_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 展台 Demo 应用" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-youtube-and-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/youtube-and-flutter.jpg" data-caption="Youtube and Flutter">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/youtube-and-flutter/youtube-and-flutter_hu4b9095b2f3544e6ecd551cf375daaa3b_2245381_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Youtube and Flutter" width="158" height="190">
&lt;/a>
&lt;/div>
&lt;p>回到 Flutter 分会场，第一场 Flutter Keynote 的主题是《剖析你的 Flutter App》。整场 Keynote 围绕着什么是性能展开。通过横向对比双平台的 Render Architecture 异同，纵向对比 Native 与 JS 调用 Native API 的产生的不必要的性能损耗，最终引出 Flutter 渲染理念，更少的计算量带来更多的性能提升。&lt;/p>
&lt;div class="gallery">
&lt;a data-fancybox="gallery-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-android.jpg" data-caption="Flutter 对比安卓渲染模式">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-android_hu1eff9f1b8e4d6ac497153867d3f5128c_1604899_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 对比安卓渲染模式" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-ios.jpg" >
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-ios_hua37f23709de7a837aebcf2805a48fc06_1508116_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="flutter-ios.jpg" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-render-trees.jpg" data-caption="Flutter 渲染树">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-render-trees_huab76dc0e2213f26375630af78f6da406_1519427_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 渲染树" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-render.jpg" data-caption="Flutter 渲染模式">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/flutter-render_huad1cc7d470f243fa02404ffa062974d8_1545912_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 渲染模式" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/rendering-performance.jpg" data-caption="Flutter 渲染性能">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter/rendering-performance_hub014db27618155f59f88c7a3734f609a_1367062_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 渲染性能" width="253" height="190">
&lt;/a>
&lt;/div>
&lt;p>不过虽然听上去很美好，但是 Flutter 的性能表现实际上是与开发者的实现息息相关。Flutter 和大部分视图渲染架构一样也是通过遍历树去寻找渲染节点，存在节点遍历即存在性能损失，而这部分性能损失需要开发者手动去优化，官方在 Build 与 Paint 这两个 Phase 中结合现场演示给出了几条性能优化的实战建议：&lt;/p>
&lt;p>如何提高 Build 效率？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>尽量降低遍历的出发点&lt;/p>
&lt;ul>
&lt;li>通过标脏 &lt;code>setState&lt;/code> 来实现&lt;/li>
&lt;li>通过 &lt;code>InheritedWidget&lt;/code> 来传递 &lt;code>state&lt;/code>&lt;/li>
&lt;li>热重载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>重用同一子组件实例&lt;/p>
&lt;ul>
&lt;li>能有效的做到在遍历至子组件时做到停止遍历&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如何提高 &lt;code>Paint&lt;/code> 效率？&lt;/p>
&lt;ul>
&lt;li>设置 &lt;code>RepaintBoundary&lt;/code>，在整个绘制树产生一次重绘时，通过 &lt;code>RepaintBoundary&lt;/code> 来阻断重绘的区域&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>因此性能优化的重任落到开发者的身上了，又是一项体力活。在整个演示过程中使用到了一部分 Profile 工具以及 Debug Flag 来监测 App 的 Performance，具体可以在 &lt;a href="https://flutter.io/ui-performance/" target="_blank" rel="noopener">Flutter Performance Profiling&lt;/a> 以及 &lt;a href="https://flutter.io/debugging/" target="_blank" rel="noopener">Debugging Flutter Apps&lt;/a> 找到。&lt;/p>
&lt;p>到了第二场 Keynote 上来了个幽默的老哥，这场的主题是《深入介绍 Flutter Graphics 性能》。&lt;/p>
&lt;figure id="figure-深入介绍-flutter-graphics-性能">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="深入介绍 Flutter Graphics 性能" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics-hero_hu87d6677356d87be9ca0c2ee20c4c44ca_1888068_6c511a255e8d12964d65702fc494d103.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics-hero_hu87d6677356d87be9ca0c2ee20c4c44ca_1888068_2b7405d7404827fd862d21175f9e3fc9.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics-hero_hu87d6677356d87be9ca0c2ee20c4c44ca_1888068_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics-hero_hu87d6677356d87be9ca0c2ee20c4c44ca_1888068_6c511a255e8d12964d65702fc494d103.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
深入介绍 Flutter Graphics 性能
&lt;/figcaption>&lt;/figure>
&lt;p>在进行了一轮 Skia 牛逼吹爆后，进入正题，主要内容围绕着通过分析绘图指令来不断优化 App 的性能。Flutter 的渲染原理是将一个渲染帧录制成 SkPicture (skp) 提交给 Skia 进行渲染，利用这个特点，通过捕捉一帧 skp，配合 &lt;a href="https://debugger.skia.org" target="_blank" rel="noopener">Skia Debugger&lt;/a>，可以精确分析到单个渲染帧中每一条绘图指令，整场 Keynote 大部分时间都花在现场演示优化，具体不在此赘述。&lt;/p>
&lt;div class="gallery">
&lt;a data-fancybox="gallery-flutter-graphics" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/flutter-performance.jpg" data-caption="Flutter 的性能">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/flutter-performance_hud6c8169b0e0a361d8eacd79e4f3ec7ff_1442523_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 的性能" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter-graphics" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/skia-engine.jpg" data-caption="Skia 渲染引擎">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/skia-engine_huaf124712f91153b8146f01355ddf9c63_1345155_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Skia 渲染引擎" width="253" height="190">
&lt;/a>
&lt;a data-fancybox="gallery-flutter-graphics" href="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/what-is-flutter.jpg" data-caption="Flutter 是什么">
&lt;img src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/flutter-graphics/what-is-flutter_hub0ee9d9ab335e333f022435f633609ed_1369568_0x190_resize_q75_lanczos.jpg" loading="lazy" alt="Flutter 是什么" width="253" height="190">
&lt;/a>
&lt;/div>
&lt;p>值得一提的是，在实际调试过程中，官方不推荐且极其不推荐使用 iOS 模拟器进行调试，理由是 Skia 在 iOS 模拟器使用 CPU 作为渲染后端，和真机的 GPU 后端会有较大的性能上的出入。&lt;/p>
&lt;h2 id="android-把路走宽了">Android 把路走宽了&lt;/h2>
&lt;p>随着业界毒瘤果的 iPhone X 开卖，国内各大安卓厂商也纷纷跟风推出刘海屏的机器，说实话笔者个人认为刘海屏这个设计真的很丑。面对这么一大波国产刘海屏手机，谷歌非但没置之不理，反而却十分接地气的在 Android 9 中添加了刘海屏的适配方案&lt;a href="https://developer.android.com/about/versions/pie/android-9.0" target="_blank" rel="noopener">显示屏缺口支持&lt;/a>，颇有大厂风范。&lt;/p>
&lt;p>在 Android 9 中利用 DeepMind 通过对 App 进行使用频率分组来尽可能降低 CPU 唤醒频率以达到延长电池的续航能力，官方称唤醒频率被有效的降低了 30%。&lt;/p>
&lt;figure id="figure-android-battery">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Android Battery" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-battery_huc9b07b7ba0118b71b01bc4577fc9716f_2402510_99adaac751857353187588045b0a0e20.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-battery_huc9b07b7ba0118b71b01bc4577fc9716f_2402510_6bedd627bdf5c3a621e5a2f850a75cda.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-battery_huc9b07b7ba0118b71b01bc4577fc9716f_2402510_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-battery_huc9b07b7ba0118b71b01bc4577fc9716f_2402510_99adaac751857353187588045b0a0e20.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Android Battery
&lt;/figcaption>&lt;/figure>
&lt;p>对于非 SDK 接口的调用在 Android 9 会被限制，具体可以参考&lt;a href="https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces" target="_blank" rel="noopener">对非 SDK 接口的限制&lt;/a>，旨在提高应用的稳定性。&lt;/p>
&lt;figure id="figure-android-sdk-restrict">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Android SDK Restrict" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-sdk-restrict_hu44e463f5ecadd5b47db528c89b2c9457_1734877_5b7d126874902607e0a757822b8f4ad0.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-sdk-restrict_hu44e463f5ecadd5b47db528c89b2c9457_1734877_5f840b63a1d51dd4de6616155dc8ea75.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-sdk-restrict_hu44e463f5ecadd5b47db528c89b2c9457_1734877_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-sdk-restrict_hu44e463f5ecadd5b47db528c89b2c9457_1734877_5b7d126874902607e0a757822b8f4ad0.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Android SDK Restrict
&lt;/figcaption>&lt;/figure>
&lt;p>Google 在 2018 Google I/O 上发布了新的框架组件 JetPack，今次在 GDD 上再次拿出来发酵一下，大致如上图所示。其中的 Navigation 和 iOS 中的 Storyboard 有着异曲同工之妙。JetPack 包含了大量的简化开发的新框架，具体可以参考官方文档 &lt;a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener">Android Jetpack&lt;/a>。&lt;/p>
&lt;figure id="figure-android-jetpack">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Android JetPack" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-jetpack_hu0f33d6c6dffc19f934386e70496598e5_2106348_07b8366a66eaef2ccee0b4df1b05f7f2.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-jetpack_hu0f33d6c6dffc19f934386e70496598e5_2106348_dd816be24917cc2ce422fda99a1e6a00.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-jetpack_hu0f33d6c6dffc19f934386e70496598e5_2106348_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-jetpack_hu0f33d6c6dffc19f934386e70496598e5_2106348_07b8366a66eaef2ccee0b4df1b05f7f2.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Android JetPack
&lt;/figcaption>&lt;/figure>
&lt;p>Google 通过 &lt;a href="https://developer.android.google.cn/platform/technology/app-bundle/" target="_blank" rel="noopener">Android App Bundle&lt;/a> 进行 apk 的动态分发，以提供 apk 的瘦身效果。在 iOS 中有类似的 &lt;a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/Tagging.html" target="_blank" rel="noopener">On Demand resource&lt;/a>，但比起 Android App Bundle] 有着更多的局限性。&lt;/p>
&lt;figure id="figure-android-app-bundle">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Android APP Bundle" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-app-bundle_hub1c43d67d0ff200f9045f7633b8e83ad_2221506_4716b29e07475790c33db4a0b8d50537.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-app-bundle_hub1c43d67d0ff200f9045f7633b8e83ad_2221506_24458c817490e57e22ef4a94084e97d4.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-app-bundle_hub1c43d67d0ff200f9045f7633b8e83ad_2221506_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/android-app-bundle_hub1c43d67d0ff200f9045f7633b8e83ad_2221506_4716b29e07475790c33db4a0b8d50537.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Android APP Bundle
&lt;/figcaption>&lt;/figure>
&lt;h2 id="还有-wearosfirebasearcore">还有 WearOS、Firebase、ARCore&lt;/h2>
&lt;h4 id="wearos">WearOS&lt;/h4>
&lt;p>WearOS 在这届 GDD 上更多的是商业上的介绍，广告以及产品上的介绍比较多，在开幕式上也花了一定的篇幅去介绍 WearOS 的合作伙伴以及品牌。与开发者相关的有《Wear OS 表盘开发入门》以及《Wear OS 应用开发入门》，由于时间有限没有前去与会。&lt;/p>
&lt;figure id="figure-arcore">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="ARCore" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/arcore_huaf8692f3e3b6ed4d627c2ba9337c3574_2508752_89142d9f41f3158fc5f79f1ed761cba7.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/arcore_huaf8692f3e3b6ed4d627c2ba9337c3574_2508752_cd41d06f2ab78b24febe848adc995f69.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/arcore_huaf8692f3e3b6ed4d627c2ba9337c3574_2508752_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/arcore_huaf8692f3e3b6ed4d627c2ba9337c3574_2508752_89142d9f41f3158fc5f79f1ed761cba7.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ARCore
&lt;/figcaption>&lt;/figure>
&lt;h4 id="arcore">ARCore&lt;/h4>
&lt;p>ARCore 也是本届 GDD 的焦点之一，ARCore 是 Google 的增强现实体验构建平台。 ARCore 利用不同的 API 让您的手机能够感知其环境、了解现实世界并与信息进行交互。今次 Google 一共安排了 2 场 Codelab 以及 4 场面向开发者的 Keynote 来帮助开发者更快更平滑的入门 ARCore 开发，非常遗憾的是笔者没有更多的时间去参与到其中。&lt;/p>
&lt;h4 id="firebase">Firebase&lt;/h4>
&lt;p>这次大会上重点介绍了下 Firebase 的 Realtime Database，看上去和 CloudKit 差不多，主要的重点还是之后的 ML Kit for Firebase。结合了 ML Kit 的 Firebase 在 TensorFlow Lite 助力下，App 可以动态加载训练模型而非直接打包在 App 中，从而达到模型热升级的目的，对中小型开发团队来说是相当有好的。&lt;/p>
&lt;figure id="figure-ml-kit">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="ML Kit" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/mlkit_hu40e6832b51e0a0438476c820377137ed_1577279_10c54f9eb7bda1369a3291fdd3131b18.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/mlkit_hu40e6832b51e0a0438476c820377137ed_1577279_f3bae333066a69be9381edd99c04aaff.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/mlkit_hu40e6832b51e0a0438476c820377137ed_1577279_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/mlkit_hu40e6832b51e0a0438476c820377137ed_1577279_10c54f9eb7bda1369a3291fdd3131b18.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ML Kit
&lt;/figcaption>&lt;/figure>
&lt;h2 id="最后">最后&lt;/h2>
&lt;p>总得来说，这次 GDD 还是收获不小，Google 给予了开发者对于未来技术的引导、解答以及分享。技术分享有深有浅，还有许多非开发相关、针对商业市场的 Keynote 可供选择。未来 TensorFlow 依然是 Google 的绝对重点，Android 的整个生态越发趋于完善与规范，Flutter 蓄势待发准备大一统。不过比较可惜的是今年没有 IoT 的开发版可以拿，期待明年的 GDD。&lt;/p>
&lt;figure id="figure-終わり">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="終わり" srcset="
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/end_hu13e20c60a373f387b083b057ce766f7c_1133942_ee8a5097cd79f390bb91dc4983fac579.jpg 400w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/end_hu13e20c60a373f387b083b057ce766f7c_1133942_ce6aaedc1cab9145d244bb9d25ffbf4e.jpg 760w,
/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/end_hu13e20c60a373f387b083b057ce766f7c_1133942_1200x1200_fit_q75_lanczos.jpg 1200w"
src="/talk/google-developer-days-china-2018-%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/end_hu13e20c60a373f387b083b057ce766f7c_1133942_ee8a5097cd79f390bb91dc4983fac579.jpg"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
終わり
&lt;/figcaption>&lt;/figure></description></item><item><title>隐私条款</title><link>/privacy/</link><pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate><guid>/privacy/</guid><description>&lt;h5 id="我们收集哪些信息">我们收集哪些信息&lt;/h5>
&lt;p>通常，您能在匿名的状态下访问本网站网并获取信息。当我们需要能识别您的个人信息或者可以与您联系的信息时，我们会征求您的同意。&lt;/p></description></item><item><title>深入了解 Protocol Buffers</title><link>/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/</link><pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate><guid>/2018/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-protocol-buffers/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protocolbuffers/protobuf: Protocol Buffers &lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Protocol Buffers | Google Developers&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 QUIC Transport Protocol</title><link>/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/</link><pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate><guid>/2017/06/15/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-quic-transport-protocol/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/draft-ietf-quic-transport-34.pdf" target="_blank" rel="noopener">QUIC: A UDP-Based Multiplexed and Secure Transport&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.ietf.org/proceedings/98/slides/slides-98-edu-sessf-quic-tutorial-00.pdf" target="_blank" rel="noopener">QUIC Tutorial&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://blog.cloudflare.com/the-road-to-quic/" target="_blank" rel="noopener">The Road to QUIC&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC, a multiplexed stream transport over UDP&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 HTTPS</title><link>/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/</link><pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-https/</guid><description>&lt;p>Hypertext Transfer Protocol Secure，超文本传输安全协议，又称 HTTP over TLS。是经由 HTTP 进行通信，并利用 SSL/TLS 来加密。HTTPS 主要目的是为了提供对服务器的身份认证，与传输过程中的数据完整性不被篡改，最早由网景（Netscape）在 1994 年提出，应用在网景领航员浏览器中。&lt;/p>
&lt;p>HTTP 在作数据传输协议使用时，由于是明文传输无任何安全保证，会存在内容被窃听的问题；由于没有身份认证机制，通信过程中会面临中间人攻击，例如数据被篡改、服务器身份伪装等。正因为 HTTP 存在这些风险问题才诞生了 HTTPS。&lt;/p>
&lt;p>HTTPS 本质上是一个复合协议，由 HTTP、TSL/SSL、TCP 协同工作，因此会涉及到较多领域的内容比如密码学、公钥与私钥、加密与认证、数字证书、数字签名等。&lt;/p>
&lt;p>此外 HTTPS 可能会与 &lt;a href="https://tools.ietf.org/pdf/rfc2660.pdf" target="_blank" rel="noopener">RFC 2660&lt;/a> 中的安全超文本传输协议 S-HTTP 相混淆。两者都为 HTTP 安全传输的实现，S-HTTP 为应用层协议，主要对传输内容加密；HTTPS 的核心为 SSL/TSL，SSL/TSL 协议位于传输层与应用层之间，确保整个通信过程都是安全的。&lt;/p>
&lt;h2 id="https-通信流程">HTTPS 通信流程&lt;/h2>
&lt;p>如上文所述，HTTPS 是对 HTTP 的扩展，由三部分组成，通信流程可以简化为：&lt;/p>
&lt;ol>
&lt;li>通信双方通过三次握手建立 TCP 连接&lt;/li>
&lt;li>通信双方通过四次握手建立 TLS 连接&lt;/li>
&lt;li>HTTP Client 向 Server 发送请求，Server 响应返回 Response&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-mermaid">sequenceDiagram
autonumber
participant Client
participant Server
rect rgb(191, 223, 255)
Client -&amp;gt;&amp;gt; Server: Request https://www.google.com
note right of Server: Encrypt Algorithm&amp;lt;br/&amp;gt;Hash Algorithm
end
rect rgb(200, 150, 255)
Server-&amp;gt;&amp;gt;Client: Return Certificate
Client-&amp;gt;&amp;gt;Client: Is Certificate Valid?
Note over Client, Server: Invalid, show prompt.
Client-&amp;gt;&amp;gt;Client: Is Valid, Random Magic Number R.
Client-&amp;gt;&amp;gt;Client: Encrypt R with Public Key In Certificate
end
rect rgb(191, 223, 255)
Client-&amp;gt;&amp;gt;Server: Transfer Encrypted R to Server
Server-&amp;gt;&amp;gt;Server: Decrypted R with Private Key
Server-&amp;gt;&amp;gt;Server: Encrypt Content with R
end
rect rgb(200, 150, 255)
Server-&amp;gt;&amp;gt;Client: Return Encrypted Content
Client-&amp;gt;&amp;gt;Client: Decrypt Content with R
end
&lt;/code>&lt;/pre>
&lt;h3 id="建立-tcp-链接">建立 TCP 链接&lt;/h3>
&lt;p>更多关于 TCP 的内容从以下这篇文章进一步了解。&lt;/p>
&lt;div class="card-simple">
&lt;div class="article-metadata">
&lt;div>
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/div>
&lt;span class="article-date">
Wed, May 03, 2017
&lt;/span>
&lt;span class="middot-divider">&lt;/span>
&lt;span class="article-reading-time">
1 分钟阅读时长
&lt;/span>
&lt;br>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-feather-alt">&lt;/i>
&lt;strong class="mr-1">CIP&lt;/strong>
&lt;/font>&lt;a href="/cip/11.07-computer-science/">11.07) Computer Science&lt;/a>
,
&lt;a href="/cip/11.0701-computer-science/">11.0701) Computer Science&lt;/a>&lt;/span>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-hashtag mr-1">&lt;/i>
&lt;/font>
&lt;a href="/category/nc.-networking-and-communication/">NC. Networking and Communication&lt;/a>&lt;/span>
&lt;/div>
&lt;div class="section-subheading article-title mb-1 mt-3">
&lt;a href="/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/">深入了解 TCP&lt;/a>
&lt;/div>
&lt;a href="/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/" class="summary-link">
&lt;div class="article-style">
&lt;p>TCP 详解&lt;/p>
&lt;/div>
&lt;/a>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc793.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 793
&lt;/a>
&lt;/div>
&lt;/div>
&lt;h3 id="建立-tls-链接">建立 TLS 链接&lt;/h3>
&lt;p>建立 TCP 链接后需要进行 TLS 握手，以浏览器和服务器的通信为例，通常 HTTPS 做单向认证，用于鉴别服务端的真伪，简化流程的如下：&lt;/p>
&lt;ol>
&lt;li>浏览器向服务器的 TLS 端口（一般为 443）发起请求，此次请求携带了支持的加密算法和哈希算法。&lt;/li>
&lt;li>服务器收到请求，选择浏览器支持的加密算法和哈希算法。&lt;/li>
&lt;li>服务器将数字证书返回给浏览器，这里的数字证书可以是向权威机构比如 CA 申请的，也可以是自签名证书。&lt;/li>
&lt;li>浏览器进入数字证书认证环节，这一部分是浏览器内置的 TLS 模块完成的。
&lt;ul>
&lt;li>首先浏览器会从系统内置的证书列表中索引，找到服务器下发证书对应的机构。&lt;/li>
&lt;li>如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。&lt;/li>
&lt;li>如果查到了对应的机构，则取出该机构颁发的公钥。&lt;/li>
&lt;li>用机构的证书公钥解密得到证书的内容和证书数字签名，内容包括服务器的地址、服务器的公钥、证书的有效期等。&lt;/li>
&lt;li>浏览器首先验证数字签名的合法性，验证过程类似 Bob 和 Pat 的通信过程。&lt;/li>
&lt;li>签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。&lt;/li>
&lt;li>如果网址一致会检查证书有效期，证书过期了也会提示用户。&lt;/li>
&lt;li>以上都通过认证时，浏览器就可以安全使用证书中的服务器公钥了。&lt;/li>
&lt;li>浏览器生成一个随机数 R，并使用服务器的公钥对 R 进行加密。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>浏览器将加密之后的 R 传送给服务器。&lt;/li>
&lt;li>服务器用自己的私钥解密得到 R。&lt;/li>
&lt;li>服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。&lt;/li>
&lt;li>浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。&lt;/li>
&lt;/ol>
&lt;p>整个过程主要为了认证服务端证书以及的公钥的合法性，因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法，主要是用来保护传输客户端生成的 &lt;code>Premaster Secret&lt;/code> 用于对称加密的随机数私钥。后续内容传输都为对称加密。&lt;/p>
&lt;p>通常 TLS 会在系统内置的可信证书列表内索引匹配的证书链。这一过程也有例外，例如 macOS 上，Safari、Edge 和 Chrome 建立 TLS 连接时会从系统的 Keychain Access 根证书去索引；而 Firefox 安全度更高，会在浏览器内置的证书中索引，防止在系统被注入证书时 HTTPS 被窃听，常见的抓包软件就是通过把自签名证书注入到系统的证书链中以实现 HTTPS 的拦截。&lt;/p>
&lt;p>更多关于 SSL/TLS 的详细内容从以下这篇文章进一步了解。&lt;/p>
&lt;div class="card-simple">
&lt;div class="article-metadata">
&lt;div>
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/div>
&lt;span class="article-date">
Tue, May 09, 2017
&lt;/span>
&lt;br>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-feather-alt">&lt;/i>
&lt;strong class="mr-1">CIP&lt;/strong>
&lt;/font>&lt;a href="/cip/11.07-computer-science/">11.07) Computer Science&lt;/a>
,
&lt;a href="/cip/11.0701-computer-science/">11.0701) Computer Science&lt;/a>&lt;/span>
&lt;span class="article-categories">
&lt;font color="#005cc5">
&lt;i class="fas fa-hashtag mr-1">&lt;/i>
&lt;/font>
&lt;a href="/category/nc.-networking-and-communication/">NC. Networking and Communication&lt;/a>&lt;/span>
&lt;/div>
&lt;div class="section-subheading article-title mb-1 mt-3">
&lt;a href="/post/tech-for-good/deep-dive-into-ssl-tls/">深入了解 SSL/TLS Protocol&lt;/a>
&lt;/div>
&lt;a href="/post/tech-for-good/deep-dive-into-ssl-tls/" class="summary-link">
&lt;div class="article-style">
&lt;p>SSL/TLS 协议详解&lt;/p>
&lt;/div>
&lt;/a>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://toolietf.org/pdf/rfc6101.pdfs." target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 6101
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc2246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 2246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc4346.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 4346
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc5246.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 5246
&lt;/a>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://tools.ietf.org/pdf/rfc8446.pdf" target="_blank" rel="noopener">
&lt;i class="far fa-file-pdf mr-1">&lt;/i>
RFC 8446
&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2818.pdf" target="_blank" rel="noopener">HTTP Over TLS&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2660.pdf" target="_blank" rel="noopener">The Secure HyperText Transfer Protocol&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 HTTP</title><link>/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/</link><pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/11/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-http/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2616.pdf" target="_blank" rel="noopener">Hypertext Transfer Protocol &amp;ndash; HTTP/1.1&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc7231.pdf" target="_blank" rel="noopener">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener">An overview of HTTP&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>TLS Handshaking Protocols</title><link>/2017/05/09/tls-handshaking-protocols/</link><pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/09/tls-handshaking-protocols/</guid><description>&lt;h2 id="tls-10">TLS 1.0&lt;/h2>
&lt;h2 id="tls-20">TLS 2.0&lt;/h2>
&lt;h2 id="tls-30">TLS 3.0&lt;/h2>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2246.pdf" target="_blank" rel="noopener">The TLS Protocol Version 1.0&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc8446.pdf" target="_blank" rel="noopener">The Transport Layer Security (TLS) Protocol Version 1.3&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/rfc8446/" target="_blank" rel="noopener">Datatracker The Transport Layer Security (TLS) Protocol Version 1.3&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security - Wikipedia&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>TLS Record Protocol</title><link>/2017/05/09/tls-record-protocol/</link><pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/09/tls-record-protocol/</guid><description>&lt;h2 id="tls-10">TLS 1.0&lt;/h2>
&lt;h2 id="tls-20">TLS 2.0&lt;/h2>
&lt;h2 id="tls-30">TLS 3.0&lt;/h2>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc2246.pdf" target="_blank" rel="noopener">The TLS Protocol Version 1.0&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc8446.pdf" target="_blank" rel="noopener">The Transport Layer Security (TLS) Protocol Version 1.3&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/rfc8446/" target="_blank" rel="noopener">Datatracker The Transport Layer Security (TLS) Protocol Version 1.3&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security - Wikipedia&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 WebSocket Protocol</title><link>/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/</link><pubDate>Sat, 06 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/06/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-websocket-protocol/</guid><description>&lt;h2 id="websocket-握手">WebSocket 握手&lt;/h2>
&lt;p>WebSocket 为第 7 层应用层协议，建立连接的握手流程依赖于 4 层 TCP，由于 WebSocket 通过利用 HTTP 发起握手，所以这里的握手更类似于一次对 HTTP 协议切换的请求。&lt;/p>
&lt;h3 id="client-请求">Client 请求&lt;/h3>
&lt;p>WebSocket 的请求和 HTTP 的格式是一致的, 每行会以 &lt;code>\r\n&lt;/code> 字符结尾，请求头的结束处也需要另起一行空白行：&lt;/p>
&lt;pre>&lt;code class="language-http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
&lt;/code>&lt;/pre>
&lt;p>最大的区别在于 WebSoeckt 的请求头会在 HTTP 的基础上带上 WS 协议切换标志位，告诉服务端将 HTTP 升级为 WebSocket。&lt;/p>
&lt;pre>&lt;code class="language-http">Upgrade: websocket
Connection: Upgrade
&lt;/code>&lt;/pre>
&lt;h3 id="server-响应">Server 响应&lt;/h3>
&lt;pre>&lt;code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc6455.pdf" target="_blank" rel="noopener">The WebSocket Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener">The WebSocket API (WebSockets)&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 TCP</title><link>/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/</link><pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/03/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-tcp/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc793.pdf" target="_blank" rel="noopener">TRANSMISSION CONTROL PROTOCOL): Semantics and Content&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol - Wikipedia&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>深入了解 UDP</title><link>/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>/2017/05/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-udp/</guid><description>&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc768.pdf" target="_blank" rel="noopener">User Datagram Protocol&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/pdf/rfc8085.pdf" target="_blank" rel="noopener">UDP Usage Guidelines&lt;/a>.&lt;/li>
&lt;/ol></description></item><item><title>再谈 Swift Performance</title><link>/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/</link><pubDate>Sat, 26 Nov 2016 18:00:05 +0000</pubDate><guid>/2016/11/26/%E5%86%8D%E8%B0%88-swift-performance/</guid><description>&lt;p>随着 WWDC 2016 的离去，WWDC 2017 也已悄然竟接近，明年苹果将重回加州圣何塞 &lt;code>McEnery&lt;/code> 举办开发者大会，这个时候那些该展望的、还没展望的，也基本被讨论的差不多了，虽然在这个时间点来讨论 Swift Performance 虽然有些老生常谈，但也不失为一个好的话题。&lt;/p>
&lt;h2 id="class-与-struct-的取舍">&lt;code>class&lt;/code> 与 &lt;code>struct&lt;/code> 的取舍&lt;/h2>
&lt;p>什么情况下该用哪种 &lt;code>first class type&lt;/code> 来建立我们的 &lt;code>Model&lt;/code>，虽然各路英才心里自有图谱，但还是很有必要拉出来讨论一下。到底是用 &lt;code>class&lt;/code> 还是 &lt;code>struct&lt;/code>、用 &lt;code>value&lt;/code> 还是 &lt;code>reference&lt;/code> ，关键的约束点在于性能开销与多态的实现方式。&lt;/p>
&lt;h3 id="内存分配">内存分配&lt;/h3>
&lt;p>人尽皆知 &lt;code>heap&lt;/code> 比 &lt;code>stack&lt;/code> 更昂贵，&lt;code>heap&lt;/code> 牺牲了性能以换取比 &lt;code>stack&lt;/code> 更自由的内存管理，&lt;code>stack&lt;/code> 牺牲了复杂的数据结构来获取和 &lt;code>Int&lt;/code> 赋值一样快的 allocation。&lt;/p>
&lt;p>&lt;code>heap&lt;/code> 之所以昂贵、性能开销大，是因为开辟内存时需要考虑到多线程申请同一块内存 &lt;code>block&lt;/code> 而产生的竞争问题，因此首先需要加锁来达到 Thread Safety，然后，需要去找到未被使用使用的内存并申请初始化，用完了之后还得还回去将其 deallocate，而我们能得到的好处则是更加动态的内存生命周期。并且不像 C++，Swift 只能在堆上初始化 &lt;code>class&lt;/code>，对于 &lt;code>class&lt;/code> 选型的取舍显得尤其重要。&lt;/p>
&lt;p>反观 &lt;code>stack&lt;/code>，之所以其性能好是因为其开辟内存仅仅依赖于 &lt;code>ESP&lt;/code> 的上下移动，以典型自底向上的栈结构为例，一次函数调用所需要的 stack allocate 仅仅需要上移 &lt;code>ESP&lt;/code>，而当函数体结束时再把 &lt;code>ESP&lt;/code> 指回入栈之前的位置，上段内存自然就 deallocate 了。每个线程有自己的 &lt;code>stack&lt;/code>，不要考虑多线程加锁，也不需要考虑下一块内存是否可用。但限制在于，当执行一次完整的 &lt;code>call stack&lt;/code>，&lt;code>EBP&lt;/code> 的位置是固定的，意味着可以使用内存就这点，所以在栈上能做的事就被大大的限制，否则就等着 Overflow。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var serial: Int
}
let car = Car(serial: 123456)
// Fake car, have a fake serial, which is equal to car.serial
let fakeCar = aCar
// do sth with car, fakeCar
&lt;/code>&lt;/pre>
&lt;p>这样一段代码在 &lt;code>stack&lt;/code> 上仅仅用了 2 个字的大小，用于存储两个 &lt;code>car&lt;/code> 的 &lt;code>serial&lt;/code>。就轻量级，开销低这些特点来说，在工程中用 &lt;code>struct&lt;/code> 来建模看上去是挺美滋滋的，但抛开多态单就性能来说，是否意味着 &lt;code>struct&lt;/code> 总是能成为 &lt;code>Modeling&lt;/code> 的首选？答案是否定的，当 &lt;code>struct&lt;/code> 遇见 &lt;code>ARC&lt;/code> 时，她就变得并不那么轻量级了。&lt;/p>
&lt;h3 id="arc">&lt;code>ARC&lt;/code>&lt;/h3>
&lt;p>Swift 对于 &lt;code>heap&lt;/code> 上实例的内存管理，采用的机制依旧是 &lt;code>ARC&lt;/code>。&lt;/p>
&lt;p>ARC 的在性能上的开销主要是在 &lt;code>swift_retain&lt;/code> &amp;amp; &lt;code>swift_release&lt;/code> 所产生的多次 &lt;code>indirection&lt;/code> 以及多线程的加锁保护。对于 &lt;code>trivial&lt;/code> 的 &lt;code>struct&lt;/code> 来说因为不涉及 &lt;code>ARC&lt;/code>，因此没有影响。但当 &lt;code>struct&lt;/code> 本身如果包含了需要 &lt;code>ARC&lt;/code> 的实例时，他就变得不那么高效了。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var name: String
var model: String
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
print(myCar.name)
&lt;/code>&lt;/pre>
&lt;p>就 &lt;code>Car&lt;/code> 来说，&lt;code>name&lt;/code> 和 &lt;code>model&lt;/code> 虽然是 &lt;code>String&lt;/code>， 是一个 &lt;code>struct&lt;/code>，但是 &lt;code>String&lt;/code> 的 &lt;code>underlying buffer storage&lt;/code> 是开辟在堆上的，需要和 &lt;code>Class&lt;/code> 一样的作 &lt;code>retain count&lt;/code>，所以会产生如下所示代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct Car {
var name: String
var model: String
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
print(myCar.name)
swift_retain(myCar.name._storage)
swift_retain(myCar.model._storage)
swift_release(myCar.name._storage)
swift_release(myCar.model._storage)
swift_release(newCar.name._storage)
swift_release(newCar.model._storage)
&lt;/code>&lt;/pre>
&lt;p>过多的 &lt;code>retain&lt;/code> &amp;amp; &lt;code>release&lt;/code> 带来性能开销是我们不想看到的，而如果我们采用 &lt;code>class&lt;/code> 来实现则展开成如下形式。&lt;/p>
&lt;pre>&lt;code class="language-swift">class Car {
var name: String
var model: String
init(name: String, model: String) {
self.name = name
self.model = model
}
}
let newCar = Car(name: &amp;quot;Tesla&amp;quot;, model: &amp;quot;Model S&amp;quot;)
let myCar = newCar
swift_retain(myCar)
print(myCar.name)
swift_retain(myCar)
// ... do sth
swift_release(myCar)
swift_release(newCar)
&lt;/code>&lt;/pre>
&lt;p>在实际的过程中，&lt;code>Model&lt;/code> 显然不会这么简单，一个对象上有 10 几 20 个需要的 &lt;code>ARC&lt;/code> 的 &lt;code>property&lt;/code> 也不是不可能的，这时候谨慎使用 &lt;code>struct&lt;/code> 是我们需要注意的雷区。&lt;/p>
&lt;p>一个好的实践是多用 &lt;code>built-in&lt;/code> 的 &lt;code>type&lt;/code> 和结构来构建模型，比如 &lt;code>Car.model&lt;/code>，作为一个 &lt;code>String&lt;/code>，它其实没有很好的约束 &lt;code>Car.model&lt;/code> 所想表达的内容，它可以是任何字符串例如 &lt;code>Car.model = &amp;quot;foo&amp;quot;&lt;/code>，这是一个非常差的设计。因此如下所示，在这里我们可以采用 &lt;code>enum&lt;/code> 来对 &lt;code>model&lt;/code> 做约束。&lt;/p>
&lt;pre>&lt;code class="language-swift">extension Car {
enum Model {
case s
case x
}
}
struct Car {
var name: String
var model: Car.Model
}
&lt;/code>&lt;/pre>
&lt;p>虽然是一个很小的优化点，但结果即提高了语义的清晰度，又减少了不必要的开销，可谓一石双鸟。&lt;/p>
&lt;h2 id="多态">多态&lt;/h2>
&lt;p>&lt;code>Dyanmic Dispatch&lt;/code> 作为类多态实现的基础之一，也是讨论了比较多的话题，对于 &lt;code>class&lt;/code> 来说，编译器会给其添加额外的 &lt;code>field&lt;/code> 来储存 &lt;code>Type&lt;/code> 的信息，&lt;code>runtime&lt;/code> 通过 &lt;code>Type&lt;/code> 的 &lt;code>v-table&lt;/code> 来找到对应的方法，具体关于 &lt;code>Dynamic Dispatch&lt;/code> 的讨论可见之前的 &lt;a href="../whole-module-optimizations/">Whole Module Optimization 分析&lt;/a>，这里就不再赘述。&lt;/p>
&lt;p>回到 &lt;code>struct&lt;/code>，如果我们需要在 &lt;code>struct&lt;/code> 上实现多态，那就得依靠 &lt;code>protocol&lt;/code> 来实现。&lt;/p>
&lt;pre>&lt;code class="language-swift">protocol Turboable {
func turbo()
}
func turbo(_ stuffs: [Turboable]) {
stuffs.forEach {
$0.turbo()
}
}
struct Car {
var name: String
}
extension Car: Turboable {
func turbo() {
print(&amp;quot;turbo Car&amp;quot;)
}
}
struct Jet {
var name: String
}
extension Jet: Turboable {
func turbo() {
print(&amp;quot;turbo Jet&amp;quot;)
}
}
struct Tractor {
var name: String
var serail: Int
}
extension Tractor: Turboable {
func turbo() {
print(&amp;quot;turbo Tractor&amp;quot;)
}
}
let myStuffs: [Turboable] = [
Jet(name: &amp;quot;MiG-25&amp;quot;),
Car(name: &amp;quot;Chevrolet&amp;quot;),
Tractor(name: &amp;quot;Mercedes-Benz&amp;quot;,serial: 1)
]
turbo(myStuffs)
&lt;/code>&lt;/pre>
&lt;p>这是一段很常见的 &lt;code>Protocol Oriented Programming&lt;/code>，实际上这并不是没有额外性能开销的。和 &lt;code>Class&lt;/code> 不一样，通过 &lt;code>protocol&lt;/code> 实现的多态是通过 &lt;code>Protocol Witness Table&lt;/code> 来做 &lt;code>Dispatch&lt;/code>，每一个实现了 &lt;code>Turboable&lt;/code> 的类型，编译器都会生成一份 &lt;code>PWT&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct JetPWT {
func turbo(_ jet: Jet) {
jet.turbo()
}
}
struct CarPWT {
func turbo(_ car: Car) {
car.turbo()
}
}
struct TractorPWT {
func turbo(_ tractor: Tractor) {
tractor.turbo()
}
}
&lt;/code>&lt;/pre>
&lt;p>同时对于 &lt;code>Array&lt;/code>，底层的 &lt;code>buffer&lt;/code> 显然更喜欢以固定的大小去连续的存储元素，而不同的 &lt;code>type&lt;/code> 却有着不同的内存布局，因此 Swift 使用了 &lt;code>Existential Containner&lt;/code> 去存储元素，这样一个容器提供了个三个字大小的 &lt;code>value Buffer&lt;/code> 用于存储元素。&lt;/p>
&lt;p>但如果元素的内存布局过大导致 &lt;code>value Buffer&lt;/code> 放不下，例如三个字对于 &lt;code>struct Jet&lt;/code> 足够大，但对于 &lt;code>struct Tractor&lt;/code>，因为 &lt;code>String&lt;/code>.&lt;code>size&lt;/code> + &lt;code>Int&lt;/code>.&lt;code>size&lt;/code> &amp;gt; 3 使得它无法存放在只有三个字大小的 &lt;code>buffer&lt;/code> 中。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 24 bytes, 3 word
let jetSize = MemoryLayout&amp;lt;Jet&amp;gt;.size
// 32 bytes, 4 words
let tractorSize = MemoryLayout&amp;lt;Tractor&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>因此 &lt;code>Existential Containner&lt;/code> 会在堆上开辟空间用来拷贝存储一份 &lt;code>Tractor&lt;/code>，同时将指针存放在 &lt;code>value Buffer&lt;/code> 中。&lt;/p>
&lt;p>所以调用 &lt;code>func turbo(_ stuffs: [Turboable])&lt;/code> 实际上绝大部分的性能开销都花费在对结构体进行内存分配上。&lt;/p>
&lt;p>同时，谈及了内存操作，不同的 &lt;code>type&lt;/code> 对应的内存布局是不同的，&lt;code>Existential Containner&lt;/code> 需要额外信息才能为这些 &lt;code>type&lt;/code> 做堆内存初始化、拷贝、释放，因此 Swift 引入了 &lt;code>Value Witness Table&lt;/code> 来管理 &lt;code>value type&lt;/code> 在堆上的生命周期。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct JetVWT {
// 在堆上初始化一块用于存放 Jet 的内存，并把地址赋给 Existential Containner
func allocate()
// 把 stack Jet 的内存 copy 到 heap 上
func copy()
// 用于 class type 引用计数递减
func destruct()
// 释放堆内存
func deallocate()
}
struct CarVWT {
...
}
struct TractorVWT {
...
}
&lt;/code>&lt;/pre>
&lt;p>因此 &lt;code>Existential Containner&lt;/code> 还需要额外的两个字的空间用来存放 &lt;code>PWT&lt;/code> 和 &lt;code>VWT&lt;/code> 的地址。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct ExistContTurboable {
var valueBuffer: (Int, Int, Int)
var vwt: ValueWitnessTable
var pwt: TurboableProtocolWitnessTable
}
&lt;/code>&lt;/pre>
&lt;p>通常来说 &lt;code>Existential Containner&lt;/code> 的大小是 5 个字。&lt;/p>
&lt;pre>&lt;code>// 40 bytes, 5 words
let turboableSize = MemoryLayout&amp;lt;Turboable&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>虽然官方没声明，但是多个 &lt;code>protocol&lt;/code> 的情况下一份 &lt;code>pwt&lt;/code> 应该是不够的。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 48 bytes, 6 words
let turboableSize = MemoryLayout&amp;lt;Turboable &amp;amp; CustomReflectable&amp;gt;.size
&lt;/code>&lt;/pre>
&lt;p>所以多个 &lt;code>protocol&lt;/code> 的结构会是如下所示的布局。&lt;/p>
&lt;pre>&lt;code class="language-swift">struct ExistContTurboableCustomReflectable {
var valueBuffer: (Int, Int, Int)
var vwt: ValueWitnessTable
var pwt: (TurboableProtocolWitnessTable, CustomReflectableWitnessTable)
}
&lt;/code>&lt;/pre>
&lt;p>以上整个流程实现了 &lt;code>protocol&lt;/code> 的 &lt;code>Dynamic Dispatch&lt;/code>，那么最终 &lt;code>func turbo(_ stuffs: [Turboable])&lt;/code> 会生成下文所示的伪代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">
func turbo(val: [ExistContTurboable]) {
val.forEach { element in
// on the heap
var local = ExistContTurboable()
let vwt = element.vwt
let pwt = element.pwt
local.vwt = vwt
local.pwt = pwt
// 拷贝 local var 至 valueBuffer 或者堆上的内存
vwt.allocateBufferAndCopyValue(&amp;amp;local, element)
// 获取到 valueBuffer 或者堆上的实例
pwt.turbo(vwt.projectBuffer(&amp;amp;local))
// 清理现场
vwt.destructAndDeallocateBuffer()
}
}
&lt;/code>&lt;/pre>
&lt;p>相比于 &lt;code>class&lt;/code>，通过 &lt;code>protocol&lt;/code> 实现的 &lt;code>Dynamic Dispatch&lt;/code> 所带来的性能下降根据数据大小的不同可能高达数倍，并且不仅仅是 &lt;code>protocol type&lt;/code>，也包括了 &lt;code>stdlib&lt;/code> 中的一些函数。&lt;/p>
&lt;pre>&lt;code class="language-swift">public func max&amp;lt;T&amp;gt;(_ x: T, _ y: T) -&amp;gt; T where T : Comparable
&lt;/code>&lt;/pre>
&lt;p>这是一个很典型的范型函数，编译器在优化 Scope 被限制的条件下，会保守的生成符合所有 case 的函数。&lt;/p>
&lt;pre>&lt;code class="language-swift">public func max&amp;lt;T&amp;gt;(_ x: T, _ y: T, _ pwt: TypePWT, _ vwt: TypeVWT) -&amp;gt; T where T : Comparable
&lt;/code>&lt;/pre>
&lt;p>同样用到了 &lt;code>PWT&lt;/code> 和 &lt;code>VWT&lt;/code>，函数体的内部也同样用 &lt;code>valueBuffer&lt;/code> 来存储数据，一样是 3 个字的大小（苹果估计和 G 胖有仇），唯一的区别是没用 &lt;code>Existential Container&lt;/code> 到，因为这个对于每次调用只有一种 &lt;code>type&lt;/code> 的参数是没有必要的。&lt;/p>
&lt;p>当然这种通过范型实现的 &lt;code>Static Polymorphism&lt;/code> 仍然是 &lt;code>Dynamic Dispathc&lt;/code> 虽然对性能开销有影响，但是通过 &lt;code>Generic Specialization&lt;/code> 可以使其达到 &lt;code>Static Dispathc&lt;/code>，同样之前的 &lt;a href="../whole-module-optimizations/">Whole Module Optimization 分析&lt;/a> 有提及，所以不再赘述。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
2017-07-14 Updated
&lt;/div>
&lt;/div>
&lt;p>在 WWDC 2017 上，苹果终于出手这个解决 &lt;code>valueBuffer&lt;/code> 的性能问题了，&lt;code>Unpredictable Performance Cliff&lt;/code>。苹果的方案是采用 &lt;code>COW Existential Buffers&lt;/code>，简单来说就是太大没法放进 &lt;code>valueBuffer&lt;/code> 的 value，苹果对其采用和类一样的 &lt;code>reference counting&lt;/code>，多个 &lt;code>Existential Container&lt;/code> 可以共享相同的 &lt;code>buffer&lt;/code> 直到这个 value 需要被修改才会被重新分配内存，以减少 &lt;code>heap allocation&lt;/code> 的次数，典型的 COW 机制。&lt;/p>
&lt;p>同样对于范型的 &lt;code>valueBuffer&lt;/code>，原来的 &lt;code>heap allocation&lt;/code> 被替换为 &lt;code>stack allocation&lt;/code>，规避了堆内存管理，这下可以更加肆无忌惮的使用范型和 &lt;code>protocol&lt;/code> 了。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>我们数据建模的方式小改动会对性能造成巨大的影响，所以在我们设计每一个代码环节时，我们都有这样思维，这段代码发生了什么、会产生怎么样的性能开销、内存是如何分配的。&lt;/p>
&lt;p>在工程中都应该根据实际场景仔细斟酌采取哪种机制来获取优雅的实现，并在此基础上对性能做优化，是需要 &lt;code>class&lt;/code> 的 OOP 特性，还是 &lt;code>struct&lt;/code> 的 value 特性，是需要 &lt;code>protocol&lt;/code> 的更加灵活的 &lt;code>Dynamic Polymorphism&lt;/code>，还是由范型带来的更加 &lt;code>static&lt;/code> 的 &lt;code>Static Polymorphism&lt;/code>。&lt;/p>
&lt;p>总之还是那句话，工欲善其事，必先利其器，了解你的编译器，这样才能让编译器更好的理解你。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2017/402/" target="_blank" rel="noopener">What&amp;rsquo;s New in Swift 4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://academy.realm.io/posts/goto-mike-ash-exploring-swift-memory-layout/" target="_blank" rel="noopener">Exploring Swift Memory Layout&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://academy.realm.io/posts/real-world-swift-performance/" target="_blank" rel="noopener">Real World Swift Performance&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Whole-Module Optimization 分析</title><link>/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/</link><pubDate>Thu, 14 Jul 2016 18:00:05 +0000</pubDate><guid>/2016/07/14/whole-module-optimization-%E5%88%86%E6%9E%90/</guid><description>&lt;p>Swift 自诞生以来，就标榜了 &lt;strong>Performance&lt;/strong>。WWDC 2015 上苹果为 Swift 2 引入的 Swift Compiler 特性 &lt;code>Whole-Module Optimization&lt;/code> 将其再一次拉上了 &lt;strong>Performance&lt;/strong> 的舞台，那么 &lt;code>WMO&lt;/code> 到底做了些什么？&lt;/p>
&lt;p>通常来说，Swift 文件是单独编译的，这样的编译模式不但可以充分发挥多核心的优势做到并行编译而且还能做到单文件维度的增量编译。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">stateDiagram-v2
File1.swift --&amp;gt; Compiler
Compiler --&amp;gt; File1.o
File2.swift --&amp;gt; Compiler
Compiler --&amp;gt; File2.o
File3.swift --&amp;gt; Compiler
Compiler --&amp;gt; File3.o
&lt;/code>&lt;/pre>
&lt;p>这很合情也和很合理，用 Apple 的话来说就是&lt;/p>
&lt;blockquote>
&lt;p>That&amp;rsquo;s &lt;strong>good&lt;/strong> 😀&lt;/p>
&lt;/blockquote>
&lt;p>然而这样会把 Optimizer 能获取到的上下文局限在单个文件内，那么显而易见的问题是，整个模块内的死函数、&lt;code>Dynamic Dispatch&lt;/code> 的 &lt;code>V-Table&lt;/code> 查询、泛型特例化等等都无法被很好的优化，所以精益求精的 Apple 认为，这还是不够 &lt;strong>good&lt;/strong>，因此引入了 &lt;code>Whole-Moudle Optimization&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">stateDiagram-v2
File1.swift --&amp;gt; Compiler
File2.swift --&amp;gt; Compiler
File3.swift --&amp;gt; Compiler
Compiler --&amp;gt; File.o
&lt;/code>&lt;/pre>
&lt;p>&lt;code>WMO&lt;/code> 将整个模块的内的 Swift 文件合并成一个，把颗粒度提升到整个模块，这样可以做到在 Build Source 阶段，Optimizer 只进行一次模块级别的优化，用 Apple 的话来说就是：&lt;/p>
&lt;blockquote>
&lt;p>Analyze everything at once, aggressive optimization, very &lt;strong>good&lt;/strong> 😀&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>WMO&lt;/code> 对于 Swift 所能带来的提升官方称有 2x ~ 5x，如此 &lt;strong>good&lt;/strong> 的性能提升使得从 Xcode 8 开始 WMO 就成为了默认标配，所以 &lt;code>WMO&lt;/code> 快在哪？&lt;/p>
&lt;h3 id="泛型特例化">泛型特例化&lt;/h3>
&lt;p>以 &lt;a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Algorithm.swift" target="_blank" rel="noopener">stdlib&lt;/a> 中的函数为例。&lt;/p>
&lt;pre>&lt;code>// File1.swift
@_inlineable
public func max&amp;lt;T : Comparable&amp;gt;(_ x: T, _ y: T) -&amp;gt; T {
// In case `x == y`, we pick `y`. See min(_:_:).
return y &amp;gt;= x ? y : x
}
&lt;/code>&lt;/pre>
&lt;p>由于是泛型，编译器无从知道 &lt;code>type T&lt;/code> 具体类型是 &lt;code>Int&lt;/code>、&lt;code>Double&lt;/code> 还是其它任何 &lt;code>Comparable&lt;/code> 的类型，所以编译器会去函数表里找类型匹配函数， 同时编译器也无从知道 &lt;code>type T&lt;/code> 是否需要为其 &lt;code>reference counting&lt;/code>(e.g &lt;code>class Foo: Comparable&lt;/code>)，所以为了应付所有可能的 &lt;code>type T&lt;/code> 情况下，编译器会保守的生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>// File1.swift
@_inlineable
func max&amp;lt;T : Comparable&amp;gt;(x: T, y: T, FTable: FunctionTable) -&amp;gt; T {
let xCopy = FTable.copy(x)
let yCopy = FTable.copy(y)
let ret = !FTable.lessThan(yCopy, xCopy) ? y : x
FTable.release(x)
FTable.release(y)
return ret
}
&lt;/code>&lt;/pre>
&lt;p>然而在 &lt;code>runtime&lt;/code> 时期，对于诸如 Int 这类的基本类型来说，编译器插入的 &lt;code>copy()&lt;/code>、&lt;code>release()&lt;/code> 是毫无意义却又是确实存在的，所以和 &lt;code>Template Specialization&lt;/code> 类似，Swift Compiler 引入了 &lt;code>Generic Specialization&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// File1.swift
func foo() {
let x: Int = ...
let y: Int = ...
let ret = max(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;p>在这样一个上下文内，&lt;code>Compiler&lt;/code> 能清楚的得知 &lt;code>type T = Int&lt;/code>，因此 &lt;code>max&amp;lt;T&amp;gt;&lt;/code> 会被拷贝并被特例化成 &lt;code>max&amp;lt;Int&amp;gt;&lt;/code>。&lt;/p>
&lt;pre>&lt;code>func max&amp;lt;Int&amp;gt;(x: Int, y: Int) -&amp;gt; Int {
return y &amp;lt; x ? x : y
}
&lt;/code>&lt;/pre>
&lt;p>然而问题是在如下的情况也是大部分工程中最常见的情况下，对于 File1.swift 来说 File2.Swift 在编译期是不可见的，&lt;code>Generic Specialization&lt;/code> 也因此失去了作用。&lt;/p>
&lt;pre>&lt;code>// Module Foo
// File1.swift
@_inlineable
public func max&amp;lt;T : Comparable&amp;gt;(_ x: T, _ y: T) -&amp;gt; T {
// In case `x == y`, we pick `y`. See min(_:_:).
return y &amp;gt;= x ? y : x
}
// File2.swift
func bar() {
let x: Int = ...
let y: Int = ...
let ret = max(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>It&amp;rsquo;s not &lt;strong>good&lt;/strong> 🙁.&lt;/p>
&lt;/blockquote>
&lt;p>就时候就能体现出 &lt;code>WMO&lt;/code> 的优势，颗粒度上升至模块之后，File1，File2 会被合并，所有 Source 处于同一上下文，因此编译器有足够的信息去优化生成成如下 high &lt;strong>perfromace&lt;/strong> 的代码。&lt;/p>
&lt;pre>&lt;code>// Module Foo
// Foo-Merged.swift
@_inlineable
public func max&amp;lt;Int&amp;gt;(_ x: Int, _ y: Int) -&amp;gt; Int {
return y &amp;gt;= x ? y : x
}
func bar() {
let x: Int = ...
let y: Int = ...
let ret = max&amp;lt;T&amp;gt;(x, y)
...
}
&lt;/code>&lt;/pre>
&lt;h3 id="dynamic-dispatch">Dynamic Dispatch&lt;/h3>
&lt;p>假设有一个 &lt;code>class Car&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// Module A
// File1.Swift
class Car {
// should not override
var brand: String
func turboCharge()
// turboCharge implementation, called by turboCharge(), should not override
func turboChargeImpl()
}
// File1.swift
class Porsche: Car {
var model: String
override func turboCharge()
// 对于子类，任何继承于父类的非 private func、property 都是以 Dynamic Dispatch
// 的形式调用的，即使没有被 override
// assumed to be overridden by compiler
// func turboChargeImpl()
}
&lt;/code>&lt;/pre>
&lt;p>然后我们有个 &lt;code>class Driver&lt;/code>。&lt;/p>
&lt;pre>&lt;code>// File2.swift
class Driver {
var name: String
func turbo(of car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
car.turboCharge()
}
}
&lt;/code>&lt;/pre>
&lt;p>那么对于 &lt;code>Driver.turbo&lt;/code> 编译器会生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a car: Car) {
let brandGetter = Car.brandGetter(car)
print(&amp;quot;Strat turbo of \(brandGetter(car))&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>由于局限于单文件 &lt;code>Scope&lt;/code>，编译器无从得知所给到类的层级信息，自然无法得知有哪些 &lt;code>property&lt;/code>，&lt;code>func&lt;/code> 是被 &lt;code>override&lt;/code>的，所以编译器必须插入间接运算以完成 &lt;code>Dynamic Dispatch&lt;/code>。对于不会被 &lt;code>override&lt;/code> 的 &lt;code>Car.brand&lt;/code>、&lt;code>Car.turboChargeImpl&lt;/code>，可以通过 &lt;code>final&lt;/code> 限制子类的 &lt;code>override&lt;/code> 或者通过 &lt;code>private&lt;/code> 限制子类的 &lt;code>Access Control&lt;/code> 来达到 &lt;code>Static Dispatch&lt;/code>。&lt;/p>
&lt;pre>&lt;code>class Car {
···
final var brand: String
private func turboChargeImpl()
}
&lt;/code>&lt;/pre>
&lt;p>于是编译器就会生成如下伪代码。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>回到 &lt;code>WMO&lt;/code>，在上文基础上，假设有这样一个情景。&lt;/p>
&lt;pre>&lt;code>// Module A
// File2.swift
class Driver {
···
func turbo(a porsche: Porsche) {
porsche.turbo()
}
···
}
&lt;/code>&lt;/pre>
&lt;p>这样一段代码会被改写成如下。&lt;/p>
&lt;pre>&lt;code>class Driver {
···
func turbo(a porsche: Porsche) {
let turboCharge = Porsche.turboCharge(porsche)
turboCharge(car)
}
···
}
&lt;/code>&lt;/pre>
&lt;p>在 &lt;code>class Prosche&lt;/code> 没有任何 &lt;code>subclass&lt;/code> 的情况下，&lt;code>Dynamic Dispatch&lt;/code> 实际上是毫无意义的，因此 &lt;code>WMO&lt;/code> 又一次发挥了作用，把 Visibility 提升到整个模块之后 Compiler 能理解 &lt;code>Prosche&lt;/code> 的类层级、并且 &lt;code>Prosche&lt;/code> 没有子类，因此 &lt;code>func turbo(a porsche: Porsche)&lt;/code> 是完全 Static 的，所以代码最终会被改写成如下。&lt;/p>
&lt;pre>&lt;code>// Module A
// A-Merged.Swift
class Car {
final var brand: String
func turboCharge()
private func turboChargeImpl()
}
class Porsche: Car {
final var model: String
override func turboCharge()
}
class Driver {
func turbo(a car: Car) {
print(&amp;quot;Strat turbo of \(car.brand)&amp;quot;)
let turboCharge = Car.turboCharge(car)
turboCharge(car)
}
func turbo(a porsche: Porsche) {
porsche.turbo()
}
}
&lt;/code>&lt;/pre>
&lt;p>相比于 objc 的一切皆动态，Swift 在编译器能获得丰富的信息去避免 &lt;code>Dynamic Dispatch&lt;/code> 这也为什么 Swift 在 Object-Oriented Benchmark 上能秒杀 objc，可见一个设计优良的 &lt;code>class&lt;/code> 不仅在工程易维护性上带来许多方便，同时在性能上也能获得巨大的收益。&lt;/p>
&lt;h2 id="wmo-的适用范围">&lt;code>WMO&lt;/code> 的适用范围&lt;/h2>
&lt;p>但就如上文所说的，&lt;code>WMO&lt;/code> 下增量编译颗粒度上升至整个模块，意味着不管修改哪个文件，下一次 build 总是 Whole-Module build，大大增加了 build time，虽然 &lt;code>WMO&lt;/code> 带来的 clean build 时间缩短是可观的，但和 &lt;code>-Onone&lt;/code>、&lt;code>SFO&lt;/code> 下的增量编译相比并不在一个量级，所以这对于日常的开发是没有必要的，因此 &lt;code>WMO&lt;/code> 作为标配来说也仅仅是在 release build 的情况下，它并不是无敌的。&lt;/p>
&lt;p>&lt;img src="./wmo.png" alt="wmo">&lt;/p>
&lt;p>同时在开启了优化的情况下，&lt;code>LLDB&lt;/code> 也会表现的不正常&lt;/p>
&lt;pre>&lt;code>MyApp was compiled with optimization - stepping may behave oddly; variables may not be available.
&lt;/code>&lt;/pre>
&lt;p>所以，如果有无法避免的理由需要在 &lt;strong>Debug&lt;/strong> 情况下要用到 &lt;code>WMO&lt;/code>，那么&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Debug&lt;/strong> 下打开 &lt;code>WMO&lt;/code>，&lt;code>Other Swift Flags&lt;/code> 里添加 &lt;code>-Onone&lt;/code>&lt;/li>
&lt;li>&lt;strong>Debug&lt;/strong> 下关闭 &lt;code>WMO&lt;/code>，&lt;code>User-Defined&lt;/code> 里添加 &lt;code>SWIFT_WHOLE_MODULE_OPTIMIZATION&lt;/code> = &lt;code>YES&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>以上两种方式都可以把所有文件合并，且不做任何编译优化，减少了 Context 的分析，不但能够 Debug，而且相比于 &lt;code>Whole-Module Optimization&lt;/code> 还可以达到更快的编译速度。对于 CocoaPods 引入的 Swift framework，可以在 hook 里为每个 target 做配置。&lt;/p>
&lt;pre>&lt;code class="language-ruby">post_install do |installer|
installer.pods_project.targets.each do |target|
target.build_configurations.each do |config|
if config.name == 'Debug'
config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Owholemodule'
config.build_settings['OTHER_SWIFT_FLAGS'] = '-Onone $(inherited)'
end
end
end
end
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;code>WMO&lt;/code> 的情况下，配合良好的代码设计会给予整个工程带来不容忽视的收益，用 Apple 的话来说就是：&lt;/p>
&lt;blockquote>
&lt;p>All I need to do is to turn on Whole-Module Optimization. I don&amp;rsquo;t need to change code at all. By giving the compiler more information, by allowing the compiler to understand my class hierachy with more information, I was able to get this optimization for &lt;strong>free&lt;/strong> without any work on your part.&lt;/p>
&lt;/blockquote>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol start="0">
&lt;li>&lt;a href="https://swift.org/blog/whole-module-optimizations/" target="_blank" rel="noopener">Whole-Module Optimization in Swift 3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2015/409/" target="_blank" rel="noopener">Optimizing Swift Performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://developear.com/blog/2016/12/30/Speed-Swift-Compilation.html" target="_blank" rel="noopener">Speeding Up Compile Times of Swift Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.skilled.io/u/swiftsummit/swift-with-a-hundred-engineers" target="_blank" rel="noopener">Swift with a hundred engineers&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nondot.org/sabre/" target="_blank" rel="noopener">Chris Lattner&amp;rsquo;s Homepage&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Introduce Objective-C Evolution</title><link>/2016/06/25/introduce-objective-c-evolution/</link><pubDate>Sat, 25 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/25/introduce-objective-c-evolution/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;p>Swift 3.0 问世之际，随之而来的是 &lt;code>API&lt;/code> 的清晰语意、更加完备的泛型、更 Swift Style 的 C APIs 等等。这也意味着 Swift 未来霸主地位越来越难被撼动。回看 Objective-C，作为一门 1980s 诞生的语言，在 Swift 的持续迭代下，ObjC 越发失去生机，&lt;code>Type Inference&lt;/code> 的缺失、&lt;code>Dynamic Dispatch&lt;/code> 的性能开销、不安全的 &lt;code>runtime&lt;/code>，过度啰嗦的 API 设计，都使得其在各方面被 Swift 全面碾压，大概目前能谈得上优势的也只剩下强大的 &lt;code>runtime&lt;/code> 动态性和 C/C++ 混编了。&lt;/p>
&lt;p>今次回顾下 Objective-C，依稀能看出语言设计上的年代感，对于 Objective-C 来说，如果当初 Swift 没有出现的话，Objective-C 3.0 是否能如期问世？&lt;/p>
&lt;ul class="cta-group">
&lt;li>
&lt;a href="../objc-evolution-proposals" target="_blank" rel="noopener" class="btn btn-primary px-3 py-3">View &lt;strong>The Objective-C Programming Language Evolution&lt;/strong>&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h2 id="objective-c-evolution">Objective-C Evolution&lt;/h2>
&lt;h3 id="开端">开端&lt;/h3>
&lt;p>尽管 Swift 的语法与性能以其压倒性的优势凌驾于 ObjC 之上，但缺点和短板的也很明显：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从 Swift 1.0 到 2.3 再到目前的 3.0，Swift 的飞速发展有目共睹，但与此同时其不稳定的 ABI 也一直被诟病，开发者们戏称道 Swift 1.0/2.0/3.0 是三门语言，虽然并没有那么夸张，但其对于代码的冲击性是确确实实的，对于小型团队来说 Swift 的版本迁移可能就几天就解决了，然而对大型项目来说，这个变化是毁灭性的。同时 Swift 持续迭代中产生的 &lt;code>bug&lt;/code>、&lt;code>issue&lt;/code> 并不能被很快的解决，那么势必我们会偶然间为 Swift 的发展而踩坑。通常来说，这些迁移所带来的额外成本在快速迭代的开发环境下是不被允许的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Swift 表现和 C++ 在很多地方都十分相似，非常 static，这也意味着 Swift 在动态性上非常薄弱，stdlib 中的 &lt;code>Mirror&lt;/code> 相比于 ObjC 的 &lt;code>runtime&lt;/code>，简直就是小巫见大巫，再者 &lt;code>Foundation&lt;/code> 中的 &lt;code>KVC&lt;/code>、&lt;code>KVO&lt;/code> 在 Swift 中需要借助 &lt;code>NSObject&lt;/code> 和 &lt;code>dynamic&lt;/code> 来完成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于一些有历史包袱或者偏底层的框架来说，它们无法从 C/C++ 剥离，而对于 C++，Swift 则必须通过 C、ObjC 来作为桥梁，无形中增加了开发成本，同时 Swift 对于指针的支持特别是函数指针并不是那么的友好，虽然这也无可厚非，毕竟 Swift 强调 &lt;code>safe&lt;/code>，指针本身就是 &lt;code>unsafe&lt;/code> 的，但使用上总有那么些许的不流畅。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>虽然目前的 Swift 依然有不少缺点，但作为一个积极的 Swift 布道者来说，其仍然是我目前为止评价最高的一门语言，其强大而优雅的语法特性、涵盖了多种模式的编码环境、内存管理哲学、以及针对性能所做的优化是目前的 Objective-C 望成莫及的。&lt;/p>
&lt;div class="alert alert-info">
&lt;div>
了解更多
&lt;/div>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/">Swift 设计哲学&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;h3 id="共生">共生&lt;/h3>
&lt;p>事实上 Apple 为了让 Swift 和 Objective-C、Foundation 层面互相兼容，在 LLVM 上做了非常多的工作，同样在 Swift Native 层面也做了大量的 Cast 和 Bridge，以至于导致了好多 Bug，列举几个我遇到过的:&lt;/p>
&lt;ul>
&lt;li>NSError 的 &lt;code>overrelease&lt;/code>，出现在 NSError 和 Error 互相 Cast 的场景，主要挂在 &lt;code>tryDynamicCastNSErrorObjectToValue&lt;/code>，通过 Allocation 最终定位为 swift runtime 的 bug
&lt;ul>
&lt;li>&lt;a href="https://bugs.swift.org/browse/SR-9207" target="_blank" rel="noopener">SR-9207&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/62410980/crash-while-casting-object-in-swift" target="_blank" rel="noopener">Crash while casting object in swift&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>引入 Swift 的代价是巨大的，但带来的收益同样也很可观，客观来说 Objective-C 的地位已然被撼动，试问一句还能战多久？&lt;/p>
&lt;h3 id="理想">理想&lt;/h3>
&lt;p>Objective-C 最大优点在于非常动态，这同样也是其缺点。高度的动态性导致其类型的不安全，冗长的自描述语法导致编码时效率低下，和 C/C++ 高度兼容的多语言特性增加了编码方式的可能性，但也导致潜在要处理的编码场景变得更为复杂。&lt;/p>
&lt;p>汲取现代语言的特性，展望 Objective-C 3.0 可拓展的特性：&lt;/p>
&lt;ul>
&lt;li>类似 &lt;code>var&lt;/code> 和 &lt;code>let&lt;/code> 关键字，参考 Swift，既满足了类型推导，又满足了可变性控制&lt;/li>
&lt;li>&lt;code>guard&lt;/code> 和 &lt;code>defer&lt;/code> 关键字，参考 Go 和 Swift 构建优雅 Control Flow 的必要元素&lt;/li>
&lt;li>&lt;code>aysnc&lt;/code> 和 &lt;code>await&lt;/code> 关键字和协程，参考 .NET&lt;/li>
&lt;li>支持泛型和模版，目前的 Objective-C 仅支持轻量型泛型&lt;/li>
&lt;li>以 &lt;code>.&lt;/code> 语法代替 &lt;code>[]&lt;/code>，事实上 Foundation 中大量的 &lt;code>getter&lt;/code> 都在逐渐适配成 @property，&lt;code>.&lt;/code> 语法的可用范围正在逐渐变多&lt;/li>
&lt;li>参数的空指针自描述，参考 Swift，在 Swift 中由 Optional 完成，Objective-C 中有 &lt;code>nullability&lt;/code> 关键字，不过主要服务于 Objective-C 到 Swift 的 API naming&lt;/li>
&lt;li>Protocol 的默认实现，参考 Swift&lt;/li>
&lt;li>Access Control&lt;/li>
&lt;/ul>
&lt;h3 id="evolution">Evolution&lt;/h3>
&lt;p>得益于 LLVM 以及出色的 Clang 前端，使得 Swift 以及一些现代语言的语法特性在 ObjC 中出现具有了可能性。拟参考 &lt;a href="https://github.com/apple/swift-evolution" target="_blank" rel="noopener">apple/swift-evolution&lt;/a> 的形式，基于对 Objective-C 原生特性拓展研究以及衍生特性的挖掘目的，建立 The Objective-C Programming Language Evolution 作为 Objective-C 的 CodeLab。&lt;/p>
&lt;h3 id="结语">结语&lt;/h3>
&lt;p>虽然目前 Swift 在苹果的推动下气势越来越猛、野心也越来越大，未来越来越多的语言特性、更完备的 &lt;code>stdlib&lt;/code> 以及更加稳定的 ABI 成为了苹果当下的主要目标。但包括苹果自己的框架在内，以及仍然有许多应用、优秀的开源库无法从 Objective-C/C++ 剥离。个人认为一些优秀并且已经被开源社区实现的特性是可以作为语言的标准特性加入到 Objective-C 的，就看 Apple 有没有这个意愿发布 Objective-C 3.0，毕竟 Apple 和 &lt;strong>
&lt;i class="fab fa-steam pr-1 fa-fw">&lt;/i>G 胖&lt;/strong>还是不一样的。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/post/tech-for-good/objc-evolution-proposals/">The Objective-C Programming Language Evolution&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div></description></item><item><title>Objective-C Evolution</title><link>/project/project-objc-evolution/</link><pubDate>Sat, 25 Jun 2016 10:31:29 +0000</pubDate><guid>/project/project-objc-evolution/</guid><description>&lt;h2 id="关于">关于&lt;/h2>
&lt;blockquote>
&lt;p>That day, if swift had never been released&amp;hellip;, would Objective-C be different?&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>objc-evolutions&lt;/code> project maintains the personal major proposals for changes and enhancements to the The Objective-C Programming Language.&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;p>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/2016/06/25/introduce-objective-c-evolution/">Introduce Objective-C Evolution&lt;/a>.
&lt;p>
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="/project/project-objc-evolution/">
项目
&lt;/a>
&lt;/p>
&lt;/div>
&lt;div class="pub-list-item" style="margin-bottom: 1rem">
&lt;i class="far fa-file-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;span class="article-metadata li-cite-author">
&lt;span class="author-highlighted">
徐旭栋&lt;/span>
&lt;/span>
(2016).
&lt;a href="/post/tech-for-good/objc-evolution-proposals/">The Objective-C Programming Language Evolution&lt;/a>.
&lt;p>
&lt;/p>
&lt;/div>
&lt;/p></description></item><item><title>Swift 设计哲学</title><link>/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link><pubDate>Sat, 25 Jun 2016 10:31:29 +0000</pubDate><guid>/2016/06/25/swift-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid><description>&lt;h2 id="序">序&lt;/h2>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/forums/thread/16363" target="_blank" rel="noopener">Design decisions / goals / philosophy of Swift&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://forums.swift.org/t/language-design-philosophy-swift-vs-other-recent-languages/1338" target="_blank" rel="noopener">Language design philosophy, Swift vs Other recent languages&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>什么是数字签名【译注】</title><link>/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/</link><pubDate>Wed, 25 May 2016 00:00:00 +0000</pubDate><guid>/2016/05/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%91%E6%B3%A8/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>故事的主人翁是 Bob，他有三个朋友 Pat、Doug 和 Susan。Bob 经常和他们网上冲浪，因为他的消息是明文传输的，在传递过程可能被人截获偷窥，也可能被人截获然后又篡改了，更有可能别人伪装成 Bob 本人跟他的好友通信，为了规避消息泄漏以及被篡改的风险，整个通信过程中会引入非对称加密算法以及数字签名。正文部分会添加个人的译注作为补充介绍一些背景与看法，接下来我们来看看 Bob 是怎么用非对称加密与好友通信的。&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>主人翁 Bob 得到了两把钥匙。其中一把称为&lt;strong>公钥&lt;/strong>，另一把称为&lt;strong>私钥&lt;/strong>。&lt;/p>
&lt;div align="center">
&lt;div align="center" style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-meh pr-1 fa-fw">&lt;/i> &lt;/font>
&lt;/div>
&lt;div align="center" style="display:inline-block">
&lt;font style="font-size:1rem;color:#005cc5;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Public Key&lt;/font>&lt;br>
&lt;font style="font-size:1rem;color:#c5005c;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Private Key&lt;/font>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>非对称加密算法（RSA）是内容加密的一类算法，它有两个密钥，公钥与私钥：&lt;/p>
&lt;ul>
&lt;li>公开的、可以被所有人都可以获取的称之为公钥。&lt;/li>
&lt;li>只有持有者知道，其他任何人获取不到的称之为私钥。&lt;/li>
&lt;/ul>
&lt;p>通过公钥加密的内容，只能通过私钥解密，同样通过私钥加密的内容也只能用公钥解密，公钥和私钥只有称谓上不同，本质上没有任何区别，是很典型的用途决定命名。通常私钥加密公钥解密，我们称之为身份认证；公钥加密私钥解密，我们称之为加密。非对称加密算法的安全性很高，但因为计算量庞大，比较消耗性能。&lt;/p>
&lt;/blockquote>
&lt;p>Bob 的公钥可供任何需要的人使用，而他的私钥由他自己保密保存。密钥用于加密信息。将信息加密意味着“干扰”，只有拥有正确密钥的人才能将其解密并恢复成可读内容。Bob 两个密钥中的任意一个密钥都可以用来加密数据，并且使用另一个密钥解密数据。&lt;/p>
&lt;div align="center">
&lt;div style="display:inline-block">
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-tie pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Pat
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-nurse pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Susan
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-user-secret pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Doug
&lt;/div>
&lt;div style="display:inline-block">
&lt;font style="font-size:3rem;color:#555555;">
&lt;i class="far fa-users pr-1 fa-fw">&lt;/i>&lt;/font>&lt;br>Others
&lt;/div>
&lt;p>&lt;b>Bob's Co-workers&lt;/b>&lt;/p>
&lt;/div>
&lt;div style="display:inline-block">&amp;nbsp&amp;nbsp&amp;nbsp&lt;/div>
&lt;div align="left" style="display:inline-block">
&lt;font style="font-size:1rem;color:#005cc5;">
&lt;i class="fas fa-key pr-1 fa-fw">&lt;/i> Public Key&lt;/font>&lt;br>
&lt;p>Anyone can get Bob's Public Key, &lt;br>but Bob keeps his Private Key &lt;br>to himself.&lt;/p>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>这里可以理解成 Bob 把公钥直接复制成三份传输给了 Pat、Susan 以及 Doug。&lt;/p>
&lt;/blockquote>
&lt;p>Susan 可以使用 Bob 的公钥加密消息，Bob 获取到加密消息之后可以用他的私钥去解密消息。Bob 的每个同事都可以获取到 Susan 的加密消息，但在没有 Bob 的私钥的情况下，这些数据毫无价值。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(&amp;quot;Hey Bob, how about lunch &amp;lt;br/&amp;gt; at Taco Bell. I hear they &amp;lt;br/&amp;gt;have free refills!&amp;quot;)
a2(HNFmsEm6Un&amp;lt;br/&amp;gt;BejhhyCGKOK&amp;lt;br/&amp;gt;JUxhiygSBCEiC&amp;lt;br/&amp;gt;0QYIh/Hn3xgiK&amp;lt;br/&amp;gt;BcyLK1UcYiY&amp;lt;br/&amp;gt;lxx2lCFHDC/A)
b1(HNFmsEm6Un&amp;lt;br/&amp;gt;BejhhyCGKOK&amp;lt;br/&amp;gt;JUxhiygSBCEiC&amp;lt;br/&amp;gt;0QYIh/Hn3xgiK&amp;lt;br/&amp;gt;BcyLK1UcYiY&amp;lt;br/&amp;gt;lxx2lCFHDC/A)
b2(&amp;quot;Hey Bob, how about lunch &amp;lt;br/&amp;gt; at Taco Bell. I hear they &amp;lt;br/&amp;gt;have free refills!&amp;quot;)
subgraph Susan
a1--&amp;gt; |Encrypt with &amp;lt;br/&amp;gt;Public Key| a2
end
a2--&amp;gt; |Transfer| b1
subgraph Bob
b1--&amp;gt;|Decrypt with &amp;lt;br/&amp;gt;Private Key| b2
end
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>比如 Susan 要和 Bob 讨论去哪吃午饭，Susan 就可以先把自己的明文内容用 Bob 给她的公钥做一次加密，然后把加密的内容传送给 Bob，Bob 收到消息后，用他的私钥解密消息的内容。&lt;/p>
&lt;p>通常公钥加密，私钥解密的过程我们称之为加密，完整的加密过程为：&lt;/p>
&lt;ol>
&lt;li>发送方（Susan）通过可逆算法对内容 Message 用公钥进行加密，得到加密后的内容并发送&lt;/li>
&lt;li>接收方（Bob）接收 Message，并用私钥解密得到 Message，这个消息只有 Bob 的私钥能够解密&lt;/li>
&lt;/ol>
&lt;p>密码学范畴内，加密的目的是为了不让别人看到传送的内容，加密的策略是在特定加密算法以及双方约定的密钥的基础上进行的，比如使用非对称加密算法和用公钥加密；而解密的策略则需要相关的解密算法及约定的密钥，比如非对称加密算法和用私钥解密，整个加密的过程是可逆的。&lt;/p>
&lt;p>更多可以参考分类 &lt;a href="">IAS. Information Assurance and Security&lt;/a>, &lt;a href="">Cryptography&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在有了私钥和对应的软件后，Bob 可以在文档和其他数据上进行数字签名。数字签名可以理解为 Bob 在数据上打上了印记，这个印记对于 Bob 来说是独一无二的，很难伪造。此外，针对已经进行过签名的数据，数字签名能够保障对数据所做的任何篡改都可以被探知。&lt;/p>
&lt;p>为了给一个文档签名，Bob 的软件通过“散列化”将数据压缩成几行，这几行的数据被称为消息摘要，并且没有任何方法能够将消息摘要还原成原始数据。Bob 的软件用私钥加密生成的消息摘要，这个结果就是数字签名。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Message)
a2(Message Digest)
a3(Digital Signature)
a1--&amp;gt; |Hash| a2
a2--&amp;gt; |Encrypt with &amp;lt;br/&amp;gt;Private Key| a3
&lt;/code>&lt;/pre>
&lt;p>最后，Bob 的软件将数字签名附加到文档中，此时所有被散列化的数据都已经被签名。Bob 现在把文件传给了 Pat。&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>假设 Bob 收到 Pat 的消息后，决定给 Pat 回复。为了防止内容被篡改或者别人伪装成他的身份跟 Pat 通信，他决定先对消息的内容用散列算法做一次处理，得到一个哈希值，Bob 又用自己的私钥对哈希值做了一次加密得到一个数字签名，然后把签名和消息一起发送给 Pat。&lt;/p>
&lt;p>Bob 的内容为明文传输，这个过程是可以被人拦截，但是 Bob 最担心的是内容被人篡改或者有人冒充自己跟 Pat 通信，而不是内容被窥探。这里其实涉及到了身份认证的概念，Bob 要向 Pat 证明通信的对方是 Bob 本人，同时也需要确保自己的内容是没被篡改的。&lt;/p>
&lt;/blockquote>
&lt;p>首先，Pat 的软件用 Bob 的公钥解密签名，将其还原为消息摘要。如果成功了，那么它证明了在文件上签名的人是 Bob，因为只有 Bob 才有他的私钥。随后，Pat 的软件将文档数据散列化成消息摘要，如果 Pat 生成的消息摘要与解密 Bob 的签名得到的消息摘要相同，则 Pat 知道被签名数据没有被更改。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Message &amp;lt;br/&amp;gt;+&amp;lt;br/&amp;gt;Digital Signature)
a2(Message Digest)
a3(Message Digest)
a1--&amp;gt; |Hash| a2
a1--&amp;gt; |Decrypt with Public Key| a3
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>Pat 接收到了 Bob 的消息，首先用 Bob 给的公钥对签名作了解密处理，得到了哈希值 A，然后 Pat 用了同样的哈希算法对消息内容作了一次散列化处理，得到另外一个哈希值 B，对比 A 和 B 如果相同，那么可以确认内容是由 Bob 本人撰写并没有被篡改。&lt;/p>
&lt;p>通常私钥加密，公钥解密的过程我们称之为身份认证，完整的认证过程为：&lt;/p>
&lt;ol>
&lt;li>发送方（Bob）通过不可逆算法对内容 Message 进行处理（散列化也就是哈希），得到的结果值 Hash Bob&lt;/li>
&lt;li>发送方（Bob）用私钥加密 Hash Bob 得到结果值作为数字签名 Digital Signature 与 Message 一起发送&lt;/li>
&lt;li>接收方（Pat）接收 Message 和 Digital Signature，用公钥解密数字签名，如果成功得到结果 Hash Bob 说明是由 Bob 的私钥进行的签名&lt;/li>
&lt;li>接收方（Pat）同样对 Message 哈希处理得到 Hash Pat&lt;/li>
&lt;li>如果 Hash Pat 和 Hash Bot 一致，则说明内容没被篡改&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>Doug 是我们的一个心怀不满的员工，他想欺骗 Pat。Doug 十分确定 Pat 收到一条被签名过消息以及一个属于 Bob 的公钥。在 Pat 不知情的情况下，Doug 用 Bob 的名字创建了一对密钥，带有欺骗性伪装成 Bob 并发送了这个生成的公钥。Pat 在没有亲自收到 Bob 的公钥的情况下，如何确定 Bob 的公钥是真实的？&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>假设 Bob 是通过网络把公钥发送给他人的，如果 Doug 或者其他任何人截获了 Bob 给 Pat 的公钥。Doug 就开始伪装成 Bob 跟 Pat 无法确认对方是否是 Bob，所以需要引入第三方机构来验证 Bob 的真伪。&lt;/p>
&lt;/blockquote>
&lt;p>碰巧 Susan 在公司内的证书颁发中心工作，Susan 只需将 Bob 的公钥以及一些关于 Bob 的身份息进行数字签名，就可以为 Bob 创建数字证书。&lt;/p>
&lt;pre>&lt;code class="language-mermaid">flowchart LR
a1(Basic Info: &amp;lt;br/&amp;gt;Name &amp;lt;br/&amp;gt;Department &amp;lt;br/&amp;gt;Cubical Number&amp;lt;br/&amp;gt;Certificate Info: &amp;lt;br/&amp;gt;Expiration Date &amp;lt;br/&amp;gt;Serial Number&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;Bob's Public Key)
a2(Digital Certificate)
subgraph Bob
a1
end
a1--&amp;gt; |Sign Data| a2
&lt;/code>&lt;/pre>
&lt;p>现在，Bob 的同事们可以检查 Bob 的受信证书，以确保这个获取到的公钥的确属于 Bob。事实上除了 Susan 生成的证书签名，Bob 的公司没有人会接受其他任何签名。这使得 Susan 有权在私钥被盗或不再需要时撤销签名，甚至还有更广为接受的证书颁发机构来认证 Susan 的身份。现在假设 Bob 给 Pat 发送了一份签名文件，为了验证文档上的签名，Pat 的软件首先使用 Susan（证书颁发机构）的公钥来检查 Bob 证书上的签名，证书解密成功证明这个签名是用 Susan 的私钥创建的，表示是 Susan 创建了这个证书。证书的签名解密后，Pat 的软件可以检查 Bob 在证书颁发机构中是否信誉良好，以及所有与 Bob 身份相关的证书信息是否有被修改。随后，Pat 的软件从证书中提取 Bob 的公钥，并用它来检查 Bob 的签名。&lt;/p>
&lt;blockquote>
&lt;p>【&lt;strong>译注&lt;/strong>】&lt;/p>
&lt;p>Bob 发现了自己的公钥被 Doug 获取之后，意识到公钥传输这个过程是有漏洞的，可以被拦截并伪装。所以文中的 Susan 作为第三方的权威认证就起到了关键作用，现实中我们会通过以权威机构“证书中心” (Certificate Authority, CA) 做认证。证书中心会用自己的私钥对 Bob 的公钥和 Bob 身份相关的信息一次加密。这样 Bob 通过网络将带有签名的数字证书传输给 Pat 后，Pat 可以用 CA 的公钥解密证书的签名，这样就可以安全获取 Bob 的公钥。&lt;/p>
&lt;/blockquote>
&lt;p>如果 Bob 的公钥成功解密了签名，那么 Pat 大可安心，签名是使用 Bob 的私钥创建的，这是因为 Susan 已经认证了匹配的公钥。当然如果签名有效，那么我们知道 Doug 没有试图更改签名内容。虽然这些步骤听起来可能很复杂，但它们都由 Pat 的软件在幕后处理。要验证一个签名，Pat 只需单击它。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">What is a Digital Signature?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>objc4 runtime</title><link>/project/project-objc4/</link><pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate><guid>/project/project-objc4/</guid><description>&lt;p>A latest buildable and debuggable Objective-C runtime project.&lt;/p></description></item><item><title>swift-cartool</title><link>/project/project-cartool/</link><pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate><guid>/project/project-cartool/</guid><description>&lt;p>&lt;img src="https://raw.githubusercontent.com/0xxd0/cartools/master/static/media/AppIcon.png" alt="AppIcon">&lt;/p>
&lt;p>ToolKit for Compiled Asset Catalogs (.car file) written in Swift.&lt;/p></description></item><item><title>快速枚举与迭代器</title><link>/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate><guid>/2016/01/25/%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>&lt;h2 id="swift-中的快速枚举">Swift 中的快速枚举&lt;/h2>
&lt;h3 id="swift-中的-forin">Swift 中的 &lt;code>for...in&lt;/code>&lt;/h3>
&lt;p>在 Swift 中所有实现了 &lt;code>Sequence&lt;/code> 的类型都能用 &lt;code>for...in&lt;/code> 来进行快速枚举，究其根本是因为 &lt;code>Sequence&lt;/code> 都实现了一个迭代器 &lt;code>func makeIterator() -&amp;gt; Iterator: IteratorProtocol&lt;/code>，我们实现一个支持随机枚举的类型。&lt;/p>
&lt;pre>&lt;code class="language-swift">// 首先定义一个随机迭代器
struct RandomIterator&amp;lt;T&amp;gt;: IteratorProtocol {
typealias Element = T
private var elements: [Element]
private var index: Int = 0
init(_ elements: [Element]) {
self.elements = elements
}
mutating func next() -&amp;gt; T? {
guard elements.count &amp;gt; 0 else {
return nil
}
index = Int(arc4random_uniform(UInt32(elements.count)));
let element = elements[index]
defer {
elements.remove(at: index)
}
return element;
}
}
// 定义一个随机序列
struct RandomSequence&amp;lt;T&amp;gt;: Sequence {
typealias Element = T
private var elements: [Element]
init(_ elements: [Element]) {
self.elements = elements
}
typealias Iterator = RandomIterator&amp;lt;Element&amp;gt;
func makeIterator() -&amp;gt; Iterator {
return RandomIterator(elements)
}
}
&lt;/code>&lt;/pre>
&lt;p>输出为如下所示。&lt;/p>
&lt;pre>&lt;code class="language-swift">let seq = RandomSequence([1, 2, 3, 4, 5, 6, 7, 8, 9])
let loopBegin = { print(&amp;quot;========= loop =========&amp;quot;) }
loopBegin()
for (i, e) in seq.enumerated() {
print(&amp;quot;Elemet \(i) is \(e)&amp;quot;)
}
loopBegin()
for (i, e) in seq.enumerated() {
print(&amp;quot;Elemet \(i) is \(e)&amp;quot;)
}
// terminal
========= loop =========
Elemet 0 is 7
Elemet 1 is 8
Elemet 2 is 2
Elemet 3 is 4
Elemet 4 is 5
Elemet 5 is 1
Elemet 6 is 3
Elemet 7 is 9
Elemet 8 is 6
========= loop =========
Elemet 0 is 3
Elemet 1 is 6
Elemet 2 is 7
Elemet 3 is 4
Elemet 4 is 5
Elemet 5 is 9
Elemet 6 is 2
Elemet 7 is 1
Elemet 8 is 8
&lt;/code>&lt;/pre>
&lt;h3 id="swift-下的-forin-展开">Swift 下的 &lt;code>for...in&lt;/code> 展开&lt;/h3>
&lt;p>Swift 下 &lt;code>for...in&lt;/code> 最终会被展开成如下代码。&lt;/p>
&lt;pre>&lt;code class="language-swift">var iterator = seq.makeIterator()
while let element = iterator.next() {
print(element)
}
&lt;/code>&lt;/pre>
&lt;h2 id="cocoa-中的-nsfastenumeration">Cocoa 中的 &lt;code>NSFastEnumeration&lt;/code>&lt;/h2>
&lt;p>谈到 Cocoa 的 &lt;code>for...in&lt;/code>，自然会联系到 &lt;code>@protocol NSFastEnumeration&lt;/code>，其只一个方法需要实现。&lt;/p>
&lt;pre>&lt;code class="language-objc">typedef struct {
unsigned long state;
id __unsafe_unretained _Nullable * _Nullable itemsPtr;
unsigned long * _Nullable mutationsPtr;
unsigned long extra[5];
} NSFastEnumerationState;
@protocol NSFastEnumeration
- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;
@end
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>@param state&lt;/code> 它保存了整个快速枚举过程所需要的 &lt;code>Context&lt;/code>
&lt;ul>
&lt;li>&lt;code>itemsPtr&lt;/code> 迭代元素的数组&lt;/li>
&lt;li>&lt;code>mutationsPtr&lt;/code> 一个标识符用于保证在枚举过程中的集合不被修改，这也是为什么在 &lt;code>for...in&lt;/code> Loop 中修改 &lt;code>Mutable Collection&lt;/code> 会导致 Crash 的原因&lt;/li>
&lt;li>&lt;code>state&lt;/code> 和 &lt;code>extra&lt;/code> 保留字段，用于给 &lt;code>Iterator&lt;/code> 保存上下文的信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>@param buffer&lt;/code> 缓冲区，用于存放当前需要被迭代的元素&lt;/li>
&lt;li>&lt;code>@param len&lt;/code> 缓冲区的长度&lt;/li>
&lt;li>&lt;code>@return&lt;/code> 当前迭代缓冲区的元素个数，如果是 0 表示迭代完成&lt;/li>
&lt;/ul>
&lt;h3 id="protocol-nsfastenumeration-与-forin">&lt;code>@protocol NSFastEnumeration&lt;/code> 与 &lt;code>for...in&lt;/code>&lt;/h3>
&lt;p>一段 &lt;code>for...in&lt;/code> Loop。&lt;/p>
&lt;pre>&lt;code class="language-objc">id&amp;lt;NSFastEnumeration&amp;gt; enumatable;
for (id element in enumatable) {
NSLog(@&amp;quot;%@&amp;quot;, element);
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>$ clang -rewrite-objc main.m&lt;/code> 之后如下所示：&lt;/p>
&lt;pre>&lt;code class="language-cpp">id/*&amp;lt;NSFastEnumeration&amp;gt;*/ enumatable;
{
id element;
// 初始化 NSFastEnumerationState Context
struct __objcFastEnumerationState enumState = { 0 };
// 开辟一块 size = 16 的缓冲区，用于给 Iterator 填充每次被迭代的元素
id __rw_items[16];
// 被迭代的集合
id l_collection = (id) enumatable;
// 首次迭代，向实现了 NSFastEnumeration 的该集合对象对象发送消息 &amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;
_WIN_NSUInteger limit =
((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
((id)l_collection,
sel_registerName(&amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;),
&amp;amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16);
// 检查 ret == 0 ?，如果为 0 表示迭代结束
if (limit) {
// 获取 Mutations flag，用于集合修改校验
unsigned long startMutations = *enumState.mutationsPtr;
do {
unsigned long counter = 0;
do {
// 保证集合不被修改，否则抛出异常
if (startMutations != *enumState.mutationsPtr) objc_enumerationMutation(l_collection);
// 获取枚举的元素
element = (id)enumState.itemsPtr[counter++];
// for...in 的 body
NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders__7_td3r8r7j44s2gh39zqkkhlym0000gn_T_main_b0cf04_mi_0, element);
} while (counter &amp;lt; limit);
// 当前元素遍历完毕，开始下一次迭代
} while (
(limit = ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
((id)l_collection,
sel_registerName(&amp;quot;countByEnumeratingWithState:objects:count:&amp;quot;),
&amp;amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16))
);
element = ((id)0)
} else {
element = ((id)0);
}
}
&lt;/code>&lt;/pre>
&lt;p>简而言之，在完整的迭代流程中，每次会给 Iterator 传入一个缓冲区 &lt;code>buffer&lt;/code>，用于填充需要被迭代的元素，同时会传入一个 &lt;code>NSFastEnumerationState&lt;/code> 用来提供当前迭代状态的上下文，当该方法返回值 &lt;code>ret != 0&lt;/code>，表示迭代并没有结束，反之亦然。相比于 &lt;code>IteratorProtocol&lt;/code> 的单个返回元素，&lt;code>NSFastEnumeration&lt;/code> 在调用过程中是批量返回元素的，在 &lt;code>Cocoa&lt;/code> 中和 &lt;code>IteratorProtocol&lt;/code> 的表现更加类似的则是 &lt;code>NSEnumerator&lt;/code> 这个抽象类。&lt;/p>
&lt;pre>&lt;code class="language-objc">@interface NSEnumerator&amp;lt;ObjectType&amp;gt; : NSObject &amp;lt;NSFastEnumeration&amp;gt;
- (nullable ObjectType)nextObject;
@end
&lt;/code>&lt;/pre>
&lt;h3 id="实现一个基于-nsfastenumeration-的随机迭代器">实现一个基于 &lt;code>NSFastEnumeration&lt;/code> 的随机迭代器&lt;/h3>
&lt;pre>&lt;code class="language-objc">// main.mm
@interface RandomIterator: NSObject &amp;lt;NSFastEnumeration&amp;gt;
@property (nonatomic, assign) std::vector&amp;lt;id&amp;gt; elements;
@property (nonatomic, assign) int capicity;
- (id)initWithElements:(NSArray&amp;lt;id&amp;gt; *)elements;
@end
@implementation RandomIterator
- (id)initWithElements:(NSArray&amp;lt;NSObject *&amp;gt; *)elements {
if ((self = super.init)) {
for (auto e in elements) {
_elements.push_back(e);
}
_capicity = (int)_elements.size();
}
return self;
}
- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id _Nullable __unsafe_unretained [])buffer count:(NSUInteger)len {
auto countOfItemsAlreadyEnumerated = state-&amp;gt;state;
// This is the initialization condition, so we'll do one-time setup here.
if (countOfItemsAlreadyEnumerated == 0) {
// state-&amp;gt;mutationsPtr MUST NOT be NULL and SHOULD NOT be set to self.
state-&amp;gt;mutationsPtr = &amp;amp;state-&amp;gt;extra[0];
}
auto count = 0;
if (countOfItemsAlreadyEnumerated &amp;lt; _elements.size()) {
state-&amp;gt;itemsPtr = buffer;
while(count &amp;lt; len) {
auto randomIndex = (int)arc4random() % MAX(1, (_capicity - 1 - countOfItemsAlreadyEnumerated));
buffer[countOfItemsAlreadyEnumerated++] = _elements[randomIndex];
count++;
if (_elements.size() == 1) {
break;
} else {
_elements.erase(_elements.begin() + randomIndex);
}
}
} else {
count = 0;
}
state-&amp;gt;state = countOfItemsAlreadyEnumerated;
return count;
}
@end
&lt;/code>&lt;/pre>
&lt;p>输出如下&lt;/p>
&lt;pre>&lt;code class="language-cpp">int main(int argc, const char * argv[]) {
auto elements = @[@1, @2, @3, @4, @5, @6, @7, @8, @9];
id&amp;lt;NSFastEnumeration&amp;gt; enumatable = [RandomIterator.alloc initWithElements: elements];
for (id element in enumatable) {
NSLog(@&amp;quot;%@&amp;quot;, element);
}
return 0;
}
// terminal
Iterator[30557:6346806] 3
Iterator[30557:6346806] 1
Iterator[30557:6346806] 7
Iterator[30557:6346806] 5
Iterator[30557:6346806] 6
Iterator[30557:6346806] 2
Iterator[30557:6346806] 8
Iterator[30557:6346806] 4
Iterator[30557:6346806] 9
&lt;/code>&lt;/pre>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://developer.apple.com/library/content/samplecode/FastEnumerationSample/Introduction/Intro.html" target="_blank" rel="noopener">Enumeration Sample&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Clang Attributes 使用文档</title><link>/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</link><pubDate>Sat, 28 Nov 2015 15:44:16 +0000</pubDate><guid>/2015/11/28/clang-attributes-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</guid><description>&lt;div class="alert alert-note">
&lt;div>
Continually Updated
&lt;/div>
&lt;/div>
&lt;p>&lt;code>__attribute__&lt;/code> 最初作为 GNU C 的特性，为 C/C++、Objective-C/C++ 提供了编译器级别的标注，用来修饰一个变量、函数或类型，包括但不限于以下特性。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html" target="_blank" rel="noopener">Function Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html" target="_blank" rel="noopener">Variable Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html" target="_blank" rel="noopener">Type Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html" target="_blank" rel="noopener">Label Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html" target="_blank" rel="noopener">Enumerator Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Attributes.html" target="_blank" rel="noopener">Statement Attributes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>同样 Clang 也很好的兼容了 GGC 这一特性，并做了额外的扩展。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#calling-conventions" target="_blank" rel="noopener">Calling Conventions&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#nullability-attributes" target="_blank" rel="noopener">Nullability Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#amd-gpu-attributes" target="_blank" rel="noopener">AMD GPU Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#consumed-annotation-checking" target="_blank" rel="noopener">Consumed Annotation Checking&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#type-safety-checking" target="_blank" rel="noopener">Type Safety Checking&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html#opencl-address-spaces" target="_blank" rel="noopener">OpenCL Address Spaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://clang.llvm.org/docs/AttributeReference.html#customizing-swift-import" target="_blank" rel="noopener">Customizing Swift Import&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>诸如优化、错误检查之类的机械化任务理应由编译器去完成，但常言道“工欲善其事，必先利其器”只有让编译器更加懂你，才能把编译器的性能、优化发挥到极致。&lt;/p>
&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">目录&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#variable-attributes">Variable Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#noescape">&lt;code>noescape&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#section-__declspecallocate">&lt;code>section, __declspec(allocate)&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#used">&lt;code>used&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#type-attributes">Type Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#objc_root_class">&lt;code>objc_root_class&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#function-attributes">Function Attributes&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#overloadable">&lt;code>overloadable&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#customizing-swift-import">Customizing Swift Import&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#swift_bridge">&lt;code>swift_bridge&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_bridged">&lt;code>swift_bridged&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_name">&lt;code>swift_name&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#swift_newtype">&lt;code>swift_newtype&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#进一步了解">进一步了解&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="variable-attributes">Variable Attributes&lt;/h2>
&lt;h3 id="noescape">&lt;code>noescape&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>noescape&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::noescape&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::noescape&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="section-__declspecallocate">&lt;code>section, __declspec(allocate)&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>section&lt;/code>&lt;/td>
&lt;td>&lt;code>gnu::section&lt;/code>&lt;/td>
&lt;td>&lt;code>gnu::section&lt;/code>&lt;/td>
&lt;td>&lt;code>allocate&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>section&lt;/code> 特性使得我们能将指定的变量或者函数插入到指定 section 中，比如把一个字符串直接塞入数据段。&lt;/p>
&lt;pre>&lt;code class="language-c">char *string __attribute((section(&amp;quot;__DATA, Custom&amp;quot;))) = &amp;quot;I'm a pure string.&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="used">&lt;code>used&lt;/code>&lt;/h3>
&lt;p>&lt;code>__attribute((used))&lt;/code> 用来修饰变量或者函数。通常默认情况下，没有被引用的符号会被链接器优化去除。标注 &lt;code>used&lt;/code> 之后意味着即使符号没有被引用，也不会被连接器优化掉。&lt;/p>
&lt;h2 id="type-attributes">Type Attributes&lt;/h2>
&lt;h3 id="objc_root_class">&lt;code>objc_root_class&lt;/code>&lt;/h3>
&lt;p>在 &lt;code>Foundation&lt;/code> 中对应 &lt;code>OBJC_ROOT_CLASS&lt;/code>，&lt;code>__attribute__((objc_root_class))&lt;/code> 用于申明一个没有根类的 objc class，我们可以利用这个特性实现类似 &lt;code>name space&lt;/code> 的效果，使得 ObjC 变得更 Swift。&lt;/p>
&lt;pre>&lt;code class="language-objc">__attribute__((objc_root_class)) @interface NotificationName
@property (class, readonly) NSNotificationName NSApplicationDidFinishLaunching;
@end
@implementation NotificationName
+ (NSNotificationName)NSApplicationDidFinishLaunching {
return NSApplicationDidFinishLaunchingNotification;
}
@end
&lt;/code>&lt;/pre>
&lt;h2 id="function-attributes">Function Attributes&lt;/h2>
&lt;h3 id="overloadable">&lt;code>overloadable&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>overloadable&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::overloadable&lt;/code>&lt;/td>
&lt;td>&lt;code>clang::overloadable&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Clang 为 C 引入了和 C++ 一样的 &lt;code>name mangling&lt;/code>，使用 &lt;code>overloadable&lt;/code> 对 C 函数进行 &lt;code>overload&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;math.h&amp;gt;
float __attribute__((overloadable)) tgsin(float x) {
return sinf(x);
}
double __attribute__((overloadable)) tgsin(double x) {
return sin(x);
}
long double __attribute__((overloadable)) tgsin(long double x) {
return sinl(x);
}
&lt;/code>&lt;/pre>
&lt;p>会得到类似于 &lt;code>_Z5tgsinf&lt;/code>、&lt;code>_Z5tgsind&lt;/code>、&lt;code>_Z5tgsine&lt;/code> 这三个符号，同样对于 ObjC Type。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
void __attribute__((overloadable)) detectTypeof(NSInteger i) {
fprintf(stdout, &amp;quot;%s\n&amp;quot;, @encode(typeof(i)));
}
void __attribute__((overloadable)) detectTypeof(CGFloat f) {
fprintf(stdout, &amp;quot;%s\n&amp;quot;, @encode(typeof(f)));
}
void __attribute__((overloadable)) detectTypeof(NSString *string) {
fprintf(stdout, &amp;quot;%s: NSString\n&amp;quot;, @encode(typeof(string)));
}
void __attribute__((overloadable)) detectTypeof(NSArray *array) {
fprintf(stdout, &amp;quot;%s: NSArray\n&amp;quot;, @encode(typeof(array)));
}
void __attribute__((overloadable)) detectTypeof(NSObject *object) {
fprintf(stdout, &amp;quot;%s: NSObject\n&amp;quot;, @encode(typeof(object)));
}
int main(int argc, const char * argv[]) {
detectTypeof((NSInteger)1);
detectTypeof(1.0);
detectTypeof(@&amp;quot;Hello&amp;quot;);
detectTypeof(@[@(1)]);
detectTypeof(NSObject.new);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>运行结果如下所示。&lt;/p>
&lt;pre>&lt;code class="language-bash">q
d
@: NSString
@: NSArray
@: NSObject
&lt;/code>&lt;/pre>
&lt;h2 id="customizing-swift-import">Customizing Swift Import&lt;/h2>
&lt;h3 id="swift_bridge">&lt;code>swift_bridge&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_bridge&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>swift_bridge&lt;/code> 用于将 ObjC 的声明和 Swift 类型进行 Bridge，为 Swift Interoperability 的体现，更多可以参考 &lt;a href="https://developer.apple.com/videos/play/wwdc2015/401/" target="_blank" rel="noopener">WWDC&lt;/a>。Swift 标准库中的相当一部分类型都有 Interoperability 特性，与 Cocoa 有一层隐式 bridge，比如 &lt;code>NSArray&lt;/code>、&lt;code>NSMutableArray&lt;/code> 和 &lt;code>Swift.Array&lt;/code>。&lt;/p>
&lt;p>下方例子中，ObjC 类 &lt;code>DerivatedObjCClass&lt;/code> 被 bridge 到 Swift 中的 &lt;code>DerivatedClass&lt;/code>。&lt;/p>
&lt;pre>&lt;code>__attribute__((objc_root_class))
@interface BaseClass
- (instancetype)init;
@end
__attribute__((__swift_bridge__(&amp;quot;DerivatedClass&amp;quot;)))
@interface DerivatedObjCClass: BaseClass
@end
&lt;/code>&lt;/pre>
&lt;p>更多相关内容可以参考 LLVM 的 Phab Review D87532 &lt;a href="https://reviews.llvm.org/D87532" target="_blank" rel="noopener">Sema: add support for &lt;code>__attribute__((__swift_bridge__))&lt;/code>&lt;/a> 以及 swift 的 &lt;a href="https://github.com/apple/swift/blob/41d5e57b5586fccd4ba3823e8ac4690b7b30ec59/lib/ClangImporter/ImportType.cpp#L944" target="_blank" rel="noopener">ClangImporter&lt;/a>。&lt;/p>
&lt;h3 id="swift_bridged">&lt;code>swift_bridged&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_bridged&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>CF_SWIFT_BRIDGED_TYPEDEF&lt;/code>，配合 &lt;code>swift_bridge&lt;/code> 使用，用于被 &lt;code>swift_bridge&lt;/code> 描述的类型的 &lt;code>typedef&lt;/code> 类型。以 &lt;code>NSString&lt;/code> -&amp;gt; &lt;code>Swift.String&lt;/code> 为例，在 ObjC 中有如下声明：&lt;/p>
&lt;pre>&lt;code class="language-objc">@interface NSString;
typedef NSString *AliasedString __attribute__((__swift_bridged_typedef__));
extern void foo(AliasedString _Nonnull str);
&lt;/code>&lt;/pre>
&lt;p>在 Swift 中会被 Bridge 为：&lt;/p>
&lt;pre>&lt;code class="language-swift">func foo(_ str: String) -&amp;gt; Void
&lt;/code>&lt;/pre>
&lt;p>这个操作同样会由 Swift Compiler 直接完成，无需开发者手动声明。&lt;/p>
&lt;h3 id="swift_name">&lt;code>swift_name&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_name&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>CF_SWIFT_NAME&lt;/code>，&lt;code>swift_name&lt;/code> 为 C/ObjC 的声明提供了在 Swift 中符号名，默认情况会根据 Swift Compiler 的算法规则自动生成。&lt;/p>
&lt;pre>&lt;code>@interface NSData
- (instancetype)initWithData:(NSData *)data __attribute__((__swift_name__(&amp;quot;Data.init(_:)&amp;quot;)));
@end
void __attribute__((__swift_name__(&amp;quot;squareRoot()&amp;quot;))) sqrtf(float f);
&lt;/code>&lt;/pre>
&lt;h3 id="swift_newtype">&lt;code>swift_newtype&lt;/code>&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GNU&lt;/th>
&lt;th>C++11&lt;/th>
&lt;th>C2x&lt;/th>
&lt;th>__declspec&lt;/th>
&lt;th>Keyword&lt;/th>
&lt;th>Pragma&lt;/th>
&lt;th>Pragma clang attribute&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>swift_newtype&lt;/code> &lt;code>swift_wrapper&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 CoreFoundation 中对应 &lt;code>_CF_TYPED_EXTENSIBLE_ENUM&lt;/code>。&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://clang.llvm.org/docs/AttributeReference.html" target="_blank" rel="noopener">Attributes in Clang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html" target="_blank" rel="noopener">Attribute Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html" target="_blank" rel="noopener">Enumerator Attributes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.keil.com/support/man/docs/armcc/armcc_chr1359124965789.htm" target="_blank" rel="noopener">Compiler-specific Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nshipster.com/__attribute__" target="_blank" rel="noopener">NSHipster __ attribute __&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Xcode 插件整理</title><link>/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</link><pubDate>Sat, 03 Jan 2015 00:00:01 +0000</pubDate><guid>/2015/01/03/xcode-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Xocde Plug-in 在 Xcode 8 之后已被禁用
&lt;/div>
&lt;/div>
&lt;h2 id="xcode-插件备忘清单">Xcode 插件备忘清单&lt;/h2>
&lt;h3 id="alcatrazhttpsgithubcomalcatrazalcatraz">&lt;a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="noopener">Alcatraz&lt;/a>&lt;/h3>
&lt;p>用于搜索、安装、管理 Xcode 插件的插件，持项目模版和 Xcode 字体主题，省去了手动 Clone 再编译的过程。&lt;/p>
&lt;h3 id="bbudebuggertuckawayhttpsgithubcomneonichubbudebuggertuckaway">&lt;a href="https://github.com/neonichu/BBUDebuggerTuckAway" target="_blank" rel="noopener">BBUDebuggerTuckAway&lt;/a>&lt;/h3>
&lt;p>当编辑代码的时候，能自动隐藏 &lt;code>Debugger&lt;/code>，尤其适用于边调试边修改的情况。&lt;/p>
&lt;h3 id="clangformat-xcodehttpsgithubcomtravisjefferyclangformat-xcode">&lt;a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="noopener">ClangFormat-Xcode&lt;/a>&lt;/h3>
&lt;p>使用 &lt;code>ClangFormat&lt;/code> 来格式化代码风格，支持 LLVM，Google，Chromium，Mozilla，WebKit，或者自定义设置，代码洁癖必备之一。使用自定义格式时 &lt;code>ClangFormat&lt;/code> 会从当前正在输入的文件的最近一级的父目录依次向上查找，直到找到用于确定代码风格的 &lt;code>.clang-format&lt;/code> 文件，因此通常放在工程文件根目录即可，文件内容使用 YAML 格式，具体风格配置可以参考 &lt;a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options&lt;/a> ，或者 &lt;a href="http://clangformat.com" target="_blank" rel="noopener">clangformat.com&lt;/a>。&lt;/p>
&lt;h3 id="cocoapods-xcode-pluginhttpsgithubcomkattralicocoapods-xcode-plugin">&lt;a href="https://github.com/kattrali/cocoapods-xcode-plugin" target="_blank" rel="noopener">cocoapods-xcode-plugin&lt;/a>&lt;/h3>
&lt;p>CocoaPods 的 Xcode 插件，省去命令行的步骤，直接在 Xcode 中对 CocoaPods 进行管理。&lt;/p>
&lt;h3 id="colorsense-for-xcodehttpsgithubcomomzcolorsense-for-xcode">&lt;a href="https://github.com/omz/ColorSense-for-Xcode" target="_blank" rel="noopener">ColorSense-for-Xcode&lt;/a>&lt;/h3>
&lt;p>高效插件，可视化的 &lt;code>UIColor/NSColor&lt;/code>。&lt;/p>
&lt;h3 id="fuzzyautocompletepluginhttpsgithubcomfuzzyautocompletefuzzyautocompleteplugin">&lt;a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="noopener">FuzzyAutocompletePlugin&lt;/a>&lt;/h3>
&lt;p>模糊匹配输入，比 Xcode 的前缀匹配要方便许多，主要通过 &lt;code>hook&lt;/code> 了 Xcode 自带的 &lt;code>IDEOpenQuicklyPattern&lt;/code> 实现。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
Xcode 8 自带了模糊匹配
&lt;/div>
&lt;/div>
&lt;h3 id="hostringsense-for-xcodehttpsgithubcomholtwickhostringsense-for-xcode">&lt;a href="https://github.com/holtwick/HOStringSense-for-Xcode" target="_blank" rel="noopener">HOStringSense-for-Xcode&lt;/a>&lt;/h3>
&lt;p>在 &lt;code>ColorSense-for-Xcode&lt;/code> 基础上进行的修改，可视化编辑多种文本，正则表达式、多行文本、内联 &lt;code>HTML&lt;/code> 等等。&lt;/p>
&lt;h3 id="ksimagenamed-xcodehttpsgithubcomksutherksimagenamed-xcode">&lt;a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="noopener">KSImageNamed-Xcode&lt;/a>&lt;/h3>
&lt;p>使用 &lt;code>[NSImage/UIImage imageNamed:]&lt;/code> 方法时，会给出所有工程文件中可选图片，并提图片预览。&lt;/p>
&lt;h3 id="scxcodeminimaphttpsgithubcomstefanceriuscxcodeminimap">&lt;a href="https://github.com/stefanceriu/SCXcodeMiniMap" target="_blank" rel="noopener">SCXcodeMiniMap&lt;/a>&lt;/h3>
&lt;p>为 Xcode 编辑器增加了一个 MiniMap，不过会挡住报错提示以及较长的的代码的末端，同时支持各种语法高亮。&lt;/p>
&lt;h3 id="scxcodeswitchexpanderhttpsgithubcomstefanceriuscxcodeswitchexpander">&lt;a href="https://github.com/stefanceriu/SCXcodeSwitchExpander" target="_blank" rel="noopener">SCXcodeSwitchExpander&lt;/a>&lt;/h3>
&lt;p>与 SCXcodeMiniMap 为同一作者，为 swith 语句自动补全所有的 case，只能适用于枚举类型。&lt;/p>
&lt;h3 id="vvdocumenter-xcodehttpsgithubcomonevcatvvdocumenter-xcode">&lt;a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">VVDocumenter-Xcode&lt;/a>&lt;/h3>
&lt;p>输入 &lt;code>///&lt;/code> 即可生成一个简易文档模版。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
在 Xcode 8 已被苹果集成
&lt;/div>
&lt;/div>
&lt;h3 id="xalignhttpsgithubcomqfishxalign">&lt;a href="https://github.com/qfish/XAlign" target="_blank" rel="noopener">XAlign&lt;/a>&lt;/h3>
&lt;p>用于对齐代码，可以根据 =、Marco、Property 进行对齐，强迫症和代码洁癖必备&lt;/p>
&lt;h3 id="xcodecolorshttpsgithubcomrobbiehansonxcodecolors">&lt;a href="https://github.com/robbiehanson/XcodeColors" target="_blank" rel="noopener">XcodeColors&lt;/a>&lt;/h3>
&lt;p>更改 NSLog 在 console 中输出的颜色，CocoaLumberjack 的依赖项&lt;/p>
&lt;h3 id="xtodohttpsgithubcomtraworxtodo">&lt;a href="https://github.com/trawor/XToDo" target="_blank" rel="noopener">XToDo&lt;/a>&lt;/h3>
&lt;p>允许使用 &lt;code>TODO&lt;/code>，&lt;code>FIXME&lt;/code>，&lt;code>???&lt;/code>，&lt;code>!!!&lt;/code> 这些符号来标记需要完成的工作，汇总显示。&lt;/p>
&lt;h3 id="xvimhttpsgithubcomxvimprojectxvim">&lt;a href="https://github.com/XVimProject/XVim" target="_blank" rel="noopener">XVim&lt;/a>&lt;/h3>
&lt;p>让熟悉使用 &lt;code>vim&lt;/code> 的开发者在 Xcode 中也能够有完整的 Vim 体验。&lt;/p></description></item><item><title>关于 NSURL +URLWithString: 返回 nil</title><link>/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/</link><pubDate>Wed, 03 Dec 2014 20:44:39 +0000</pubDate><guid>/2014/12/03/%E5%85%B3%E4%BA%8E-nsurl-urlwithstring-%E8%BF%94%E5%9B%9E-nil/</guid><description>&lt;p>当 url 字符串中含有特殊字符时，例如空格、汉字等，则必须对 url 字符串进行转义编码，否则 &lt;code>[NSURL URLWithString: urlString]&lt;/code> 将返回 &lt;code>nil&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat: @&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString:urlString];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>输出的 url 结果为。&lt;/p>
&lt;pre>&lt;code>21:07:11.784 test[8883:320995] (null)
&lt;/code>&lt;/pre>
&lt;p>对 &lt;code>urlString&lt;/code> 进行编码以及输出的 &lt;code>url&lt;/code> 结果。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat: @&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014
&lt;/code>&lt;/pre>
&lt;p>空格被转义为 &lt;code>UTF-8&lt;/code> 编码，例如汉字&amp;quot;的&amp;quot;的 &lt;code>UTF-8&lt;/code> 编码为 &lt;code>0xE7 0x9A 0x84&lt;/code>，percent encode 之后就是 &lt;code>%E7%9A%84&lt;/code>。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
2015-07-20 Updated
&lt;/div>
&lt;/div>
&lt;p>在 iOS 9.0 / OSX 10.11 之后 &lt;code>- stringByReplacingPercentEscapesUsingEncoding:&lt;/code> 就被废弃了，我们可以用 &lt;code>- stringByAddingPercentEncodingWithAllowedCharacters:&lt;/code> 代替，参数类型为 &lt;code>NSCharacterSet&lt;/code>。这个方法会把所有 Character Set 以外的字符进行 &lt;code>UTF-8 Percent Encoding&lt;/code>，支持 url 编码的 Character Set 有如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">+ URLFragmentAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%&amp;lt;&amp;gt;[\]^`{|}
+ URLHostAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/&amp;lt;&amp;gt;?@\^`{|}
+ URLPasswordAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/:&amp;lt;&amp;gt;?@[\]^`{|}
+ URLPathAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%;&amp;lt;&amp;gt;?[\]^`{|}
+ URLQueryAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%&amp;lt;&amp;gt;[\]^`{|}
+ URLUserAllowedCharacterSet // 7-bit ASCII 不包含 &amp;quot;#%/:&amp;lt;&amp;gt;?@[\]^`
&lt;/code>&lt;/pre>
&lt;p>自定义的 &lt;code>NSCharacterSet&lt;/code> 如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">[[NSCharacterSet characterSetWithCharactersInString:@&amp;quot; \&amp;quot;#%/:&amp;lt;&amp;gt;?@[\\]^`{|}&amp;quot;] invertedSet]
&lt;/code>&lt;/pre>
&lt;p>所以最终的编码以及控制台输出就如下所示。&lt;/p>
&lt;pre>&lt;code class="language-objc">#import &amp;lt;Foundation/Foundation.h&amp;gt;
int main(int argc, const char * argv[]) {
@autoreleasepool {
NSString *urlString = [NSString stringWithFormat:@&amp;quot;https://www.google.com.hk/search?q=WWDC 2014&amp;quot;];
NSURL *url = [NSURL URLWithString: [urlString stringByAddingPercentEncodingWithAllowedCharacters: NSCharacterSet.URLQueryAllowedCharacterSet]];
NSLog(@&amp;quot;%@&amp;quot;, url);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>21:09:18.640 test[8985:327779] https://www.google.com.hk/search?q=WWDC%202014
&lt;/code>&lt;/pre></description></item><item><title>git submodule 使用过程中遇到的问题</title><link>/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 04 Oct 2014 21:01:15 +0000</pubDate><guid>/2014/10/04/git-submodule-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="添加-submodule">添加 submodule&lt;/h2>
&lt;p>为仓库添加 &lt;code>submodule&lt;/code> ⬇&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule add {repo-url} /local/repo/path
&lt;/code>&lt;/pre>
&lt;h2 id="git-clone-带有-submodule-的工程">git clone 带有 submodule 的工程&lt;/h2>
&lt;pre>&lt;code class="language-bash">$ git clone {repo-url}
&lt;/code>&lt;/pre>
&lt;p>完成之后，submodule 的代码并没有一起 clone 到本地，查看工作区可以发现 &lt;code>submodule&lt;/code> 的上下文内容。&lt;/p>
&lt;ul>
&lt;li>&lt;code>.gitmodules&lt;/code> 存在，里面包含了 submodule 的 url 和 &lt;code>{path/to/submodule-name}&lt;/code>&lt;/li>
&lt;li>&lt;code>{path/to/submodule-name}&lt;/code> 存在，但是文件夹是空的&lt;/li>
&lt;li>&lt;code>.git/config&lt;/code> 里没有submodule库的信息&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">$ git status
&lt;/code>&lt;/pre>
&lt;p>没有发现有更改的地方。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule status
&lt;/code>&lt;/pre>
&lt;p>可以看到 submodule &lt;code>hash&lt;/code>，前面带有 &lt;code>-&lt;/code> 表示 submodule 还没有 &lt;code>checkout&lt;/code>。&lt;/p>
&lt;h2 id="拉取-submodule">拉取 submodule&lt;/h2>
&lt;p>&lt;code>git submodule init&lt;/code> 利用工作区 &lt;code>.gitmodules&lt;/code> 的信息，在 &lt;code>.git/config&lt;/code> 里建立了 &lt;code>submodule&lt;/code> 索引 &lt;code>submodule.$name.url&lt;/code>，通过如下命令可以看到 &lt;code>submodule&lt;/code> 的索引。&lt;/p>
&lt;pre>&lt;code class="language-bash">cat .git/config
&lt;/code>&lt;/pre>
&lt;p>&lt;code>git submodule update&lt;/code> 默认走的是 &lt;code>git submodule update --checkout&lt;/code>，利用 &lt;code>superproject&lt;/code> 里记录的 &lt;code>hash&lt;/code> 来 &lt;code>checkout&lt;/code> submodule，这里就有个坑了。&lt;/p>
&lt;p>文档中是这么描述的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>checkout&lt;/strong>
the commit recorded in the superproject will be checked out in the submodule on a detached HEAD.
If &amp;ndash;force is specified, the submodule will be checked out (using git checkout &amp;ndash;force if appropriate), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>detached HEAD&lt;/code> 不属于任何一条 &lt;code>tree&lt;/code>，如果之后忘记 &lt;code>checkout&lt;/code> 到某条分支上的话，那之后所有 submodule 的 commit 都基于这个 &lt;code>detached HEAD&lt;/code>，那么我们就不得不使用 &lt;code>cherry-pick&lt;/code>，把基于 &lt;code>detached HEAD&lt;/code> 提交的 commit 提交 pick 到已有的分支上。&lt;/p>
&lt;p>并且当 &lt;code>submodule&lt;/code> 的嵌套层级太深的话，一层层的去 submodule 进行 &lt;code>init&lt;/code> 以及 &lt;code>update&lt;/code> 显然是不可取的，所以可以通过递归的方式去执行命令，这样能够做到 clone 主库以及递归拉取所有 submodule。&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone {path/to/repo-name} --recurse
&lt;/code>&lt;/pre>
&lt;h2 id="修改-submodule">修改 submodule&lt;/h2>
&lt;p>通常在实际项目中执行 &lt;code>submodule update&lt;/code> 的流程如下所示。&lt;/p>
&lt;ol>
&lt;li>当 repo-A 目录下的 repo-B 为 submodule，在对其进行修改之后，查看此时的工作区状态。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
(commit or discard the untracked or modified content in submodules)
modified: repo-B (modified content, untracked content)
$ git diff
diff --git a/submodules/repo-B b/submodules/repo-B
--- a/submodules/repo-B
+++ b/submodules/repo-B
@@ -1 +1 @@
-Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e
+Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e-dirty
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>发现 submodule 是 modified 并且工作目录 dirty，执行 submodule 提交修改。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ cd submodules/repo-B
$ git stage *
$ git commit -am 'Update content'
$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
(use &amp;quot;git push&amp;quot; to publish your local commits)
nothing to commit, working directory clean
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>回到主项目，查看状态输出，显示 submodule 的 &lt;code>hash&lt;/code> 已更新。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
modified: repo-B (new commits)
$ git diff
diff --git a/submodules/repo-B b/submodules/repo-B
--- a/submodules/repo-B
+++ b/submodules/repo-B
@@ -1 +1 @@
-Subproject commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e
+Subproject commit db560723ded8d1a0839dc08fb1e4324b30545c05
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>主工程提交修改。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ git stage *
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
modified: repo-B
$ git commit -am 'Update submodule'
&lt;/code>&lt;/pre>
&lt;h2 id="从远程库更新-submodule">从远程库更新 submodule&lt;/h2>
&lt;p>当远程库的提交里记录的 submodule hash 有更新时，拉取远程库后，我们需要 update 本地的 submodule。git submodule update 会比较主项目记录的 submodule hash 和 submodule 自身当前的 HEAD hash，git 会强制把 submodule 的 HEAD checkout 到 git 记录的 hash，因为是 checkout 所以 detached HEAD 的问题会再一次出现。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ git submodule update
Submodule path 'submodules/repo-B': checked out 'db560723ded8d1a0839dc08fb1e4324b30545c05'
$ cd submodules/repo-B
$ git log --decorate --all
commit 3b754aca54077269aedb328c6e738ab8a7ab3077 (master) # current submodule HEAD hash
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Sat Dec 5 22:26:21 2015 +0800
Modify _config.yml
commit db560723ded8d1a0839dc08fb1e4324b30545c05 (HEAD) # main project submodule hash
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Sat Dec 5 21:46:40 2015 +0800
Modify _config.yml, Add two image
commit b449370e24b331e97f6d74ca2862fcd4e3c5bd4e (origin/master, origin/HEAD)
Author: username &amp;lt;username@exmail.com&amp;gt;
Date: Tue Dec 1 20:06:31 2015 +0800
Modify _config.yml
$ git status
HEAD detached at db56072
$ git branch
* (HEAD detached at db56072)
master
&lt;/code>&lt;/pre>
&lt;p>要从根本上摆脱 &lt;code>detached HEAD&lt;/code> 的问题，使用 &lt;code>rebase&lt;/code>、&lt;code>merge&lt;/code> 是正确的方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git submodule update --rebase&lt;/code>
the current branch of the submodule will be rebased onto the commit recorded in the superproject.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git submodule update --merge&lt;/code>
the commit recorded in the superproject will be merged into the current branch in the submodule.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://git-scm.com/doc" target="_blank" rel="noopener">git Documentation&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>用 Hexo 搭建个人博客</title><link>/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Thu, 12 Jun 2014 00:00:00 +0000</pubDate><guid>/2014/06/12/%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>&lt;p>今次通过 Hexo 生成静态博客网站，所以配置服务器的流程可以省去，直接托管在 Github Pages 上即可，这也目前轻量级博客的趋势。&lt;/p>
&lt;h2 id="环境安装">环境安装&lt;/h2>
&lt;h3 id="node-环境安装">Node 环境安装&lt;/h3>
&lt;h4 id="安装-nvmhttpsgithubcomcreationixnvm">安装 &lt;a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM&lt;/a>&lt;/h4>
&lt;p>在终端中运行如下命令。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
&lt;/code>&lt;/pre>
&lt;h4 id="安装-nodejshttpsnodejsorgen">安装 &lt;a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js&lt;/a>&lt;/h4>
&lt;p>使用如下命令查找远程库版本。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ nvm ls-remote
&lt;/code>&lt;/pre>
&lt;p>找到合适的版本并安装。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ nvm install 5.1.0
&lt;/code>&lt;/pre>
&lt;h3 id="安装-hexohttpshexoio">安装 &lt;a href="https://hexo.io" target="_blank" rel="noopener">Hexo&lt;/a>&lt;/h3>
&lt;p>Hexo 有丰富的&lt;a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件&lt;/a>和&lt;a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题&lt;/a>，如果不能满足需求的话还可以&lt;a href="https://hexo.io/api/" target="_blank" rel="noopener">自己动手&lt;/a>，使用如下命令全局安装 &lt;code>hexo-cli&lt;/code>。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm install hexo-cli -g
&lt;/code>&lt;/pre>
&lt;p>安装 Hexo 所需的依赖包。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm install hexo-renderer-ejs --save
$ npm install hexo-renderer-stylus --save
$ npm install hexo-renderer-marked --save
&lt;/code>&lt;/pre>
&lt;p>或者直接通过 &lt;code>package.json&lt;/code> 一步到位。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ npm intall
&lt;/code>&lt;/pre>
&lt;h2 id="添加文章-posts">添加文章 Posts&lt;/h2>
&lt;p>找个文件夹初始化 Blog 的工作目录。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd &amp;quot;/path/to/blog&amp;quot;
$ hexo init
&lt;/code>&lt;/pre>
&lt;p>生成一篇文章。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo new &amp;quot;用 Hexo 搭建个人博客&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>使用 &lt;code>vim&lt;/code> 或者其他 &lt;code>Markdown Editor&lt;/code> 编辑文章。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd source/_posts
$ vim 用-Hexo-搭建个人博客.md
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>附上 &lt;code>Markdown&lt;/code> &lt;a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">语法&lt;/a>&lt;/strong>。写完博文之后生成 &lt;code>html&lt;/code>、&lt;code>css&lt;/code>、&lt;code>.js&lt;/code> 等静态网页文件，生成之后的内容在博客根目录 &lt;code>public&lt;/code> 文件夹下，里面就是博客需要部署的内容。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo generate
&lt;/code>&lt;/pre>
&lt;p>启动本地 Hexo 服务器。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ hexo server
INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
&lt;/code>&lt;/pre>
&lt;p>在浏览器内输入&lt;a href="http:localhost:4000/" target="_blank" rel="noopener">本地服务器地址&lt;/a>预览博客。&lt;/p>
&lt;h2 id="部署至-github">部署至 Github&lt;/h2>
&lt;p>部署到 Github 上用于 Github Pages 的 repo 有两种形式：&lt;/p>
&lt;ol>
&lt;li>主页级 repo，页面部署到 &lt;code>master&lt;/code> 分支下，访问 Github Pages 时使用 &lt;code>username.github.io&lt;/code>，常用于个人主页。&lt;/li>
&lt;li>项目级 repo，页面部署到 &lt;code>gh-pages&lt;/code> 分支，访问 Github Pages 时使用 &lt;code>username.github.io/repo-name&lt;/code>，常用于项目主页。&lt;/li>
&lt;/ol>
&lt;p>在 _config.yml 内配置完部署信息后 (&lt;code>deploy&lt;/code> 字段) 执行如下命令。&lt;/p>
&lt;pre>&lt;code>$ hexo clean
$ hexo generate
$ hexo deploy
&lt;/code>&lt;/pre>
&lt;p>或者使用如下命令。&lt;/p>
&lt;pre>&lt;code>$ hexo g
$ hexo d
&lt;/code>&lt;/pre>
&lt;p>完成部署至 Github，过个几分钟等 Github 更新完缓存再打开 &lt;code>{username}.github.io/{blog-repo}&lt;/code> 或者 &lt;code>{username}.github.io&lt;/code> 就能看到 Github Pages。&lt;/p>
&lt;h2 id="绑定域名">绑定域名&lt;/h2>
&lt;p>Github 使用一系列 &lt;strong>name-based&lt;/strong> 虚拟 &lt;code>WWW&lt;/code> server 部署所有静态博客的 wwwroot 目录。虚拟服务器的地址就是上文提及的 &lt;code>{username}.github.io&lt;/code> 和 &lt;code>{username}.github.io/{repo-name}&lt;/code>，因此将需要绑定的域名指向 Github 的服务器 &lt;a href="https://github.io">https://github.io&lt;/a>，把域名解析权下放到 Github。&lt;/p>
&lt;p>同时 Github 服务器需要知道如何解析域名，所以 Github Pages 用户需要将绑定的域名通过 wwwroot 目录下的 CNAME 文件告知 WWW server 域名 =&amp;gt; &lt;code>repo/branch&lt;/code> 的映射关系，所以在根目录 source 文件夹下建立一个 CNAME 文本文件，内容为绑定的域名。&lt;/p>
&lt;p>完成之后，输入命令查询下 dns 解析结果。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ dig blog.alchemistxxd.com
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.3-P1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.alchemistxxd.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 45658
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0
;; QUESTION SECTION:
;blog.alchemistxxd.com. IN A
;; ANSWER SECTION:
blog.alchemistxxd.com. 600 IN CNAME alchemistxxd.github.io.
alchemistxxd.github.io. 2816 IN CNAME github.map.fastly.net.
github.map.fastly.net. 142 IN A 103.245.222.133
;; Query time: 299 msec
;; SERVER: 222.44.10.48#53(222.44.10.48)
;; WHEN: Wed Dec 2 23:41:45 2015
;; MSG SIZE rcvd: 126
&lt;/code>&lt;/pre>
&lt;p>终わり&lt;/p>
&lt;h2 id="进一步了解">进一步了解&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hexo.io/" target="_blank" rel="noopener">Hexo.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm Docs&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>创篇号</title><link>/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/</link><pubDate>Wed, 11 Jun 2014 00:00:00 +0000</pubDate><guid>/2014/06/11/%E5%88%9B%E7%AF%87%E5%8F%B7/</guid><description>&lt;p>在浮躁快餐文化的催化下，人逐渐变的懒散与缺乏耐性，在这样的环境下要想压抑住浮躁的内心、放平心态好好学习也成了一件非常不容易的事情。&lt;/p>
&lt;p>走马观花是很多人在学习过程中遇到的问题，在从外部获取各种信息时我们总想着尽可能多的去汲取知识，却忽略了对于知识的复习与运用，渐渐的就会丧失了自我思考的能力，并且根据 &lt;a href="https://en.wikipedia.org/wiki/Forgetting_curve" target="_blank" rel="noopener">Forgetting curve&lt;/a>，学过的东西如果不用也不整理那要不了多久就会忘的一干二净，所以知识点的沉淀与复习运用是很重要的。于是乎觉着学习的东西要有个地方来沉淀复盘下，一直想趁着有时间搭个博客来纪录下以后学习的历程，沉淀下有关技术学习以及生活的点滴。所以，从今天开始写博文，在学习之路上留下点技术印记。&lt;/p></description></item><item><title>An example conference paper</title><link>/publication/example/</link><pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate><guid>/publication/example/</guid><description>&lt;div class="alert alert-note">
&lt;div>
Click the &lt;em>Cite&lt;/em> button above to demo the feature to enable visitors to import publication metadata into their reference management software.
&lt;/div>
&lt;/div>
&lt;div class="alert alert-note">
&lt;div>
Create your slides in Markdown - click the &lt;em>Slides&lt;/em> button to check out the example.
&lt;/div>
&lt;/div>
&lt;p>Supplementary notes can be added here, including &lt;a href="https://wowchemy.com/docs/writing-markdown-latex/" target="_blank" rel="noopener">code, math, and images&lt;/a>.&lt;/p></description></item></channel></rss>